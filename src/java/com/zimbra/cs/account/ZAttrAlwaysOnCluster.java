/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Server
 * Copyright (C) 2013, 2014 Zimbra, Inc.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software Foundation,
 * version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License along with this program.
 * If not, see <http://www.gnu.org/licenses/>.
 * ***** END LICENSE BLOCK *****
 */

package com.zimbra.cs.account;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import com.zimbra.common.account.ZAttr;
import com.zimbra.common.account.ZAttrProvisioning;
import com.zimbra.common.util.StringUtil;
import com.zimbra.cs.ldap.LdapDateUtil;


/**
 * AUTO-GENERATED. DO NOT EDIT.
 *
 */
public abstract class ZAttrAlwaysOnCluster extends NamedEntry {

    public ZAttrAlwaysOnCluster(String name, String id, Map<String,Object> attrs, Map<String,Object> defaults, Provisioning prov) {
        super(name, id, attrs, defaults, prov);
    }

    ///// BEGIN-AUTO-GEN-REPLACE

    /**
     * RFC2256: common name(s) for which the entity is known by
     *
     * @return cn, or null if unset
     */
    @ZAttr(id=-1)
    public String getCn() {
        return getAttr(Provisioning.A_cn, null);
    }

    /**
     * RFC2256: common name(s) for which the entity is known by
     *
     * @param cn new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setCn(String cn) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_cn, cn);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: common name(s) for which the entity is known by
     *
     * @param cn new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setCn(String cn, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_cn, cn);
        return attrs;
    }

    /**
     * RFC2256: common name(s) for which the entity is known by
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetCn() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_cn, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: common name(s) for which the entity is known by
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetCn(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_cn, "");
        return attrs;
    }

    /**
     * RFC2256: descriptive information
     *
     * @return description, or empty array if unset
     */
    @ZAttr(id=-1)
    public String[] getDescription() {
        return getMultiAttr(Provisioning.A_description);
    }

    /**
     * RFC2256: descriptive information
     *
     * @param description new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setDescription(String[] description) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_description, description);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: descriptive information
     *
     * @param description new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setDescription(String[] description, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_description, description);
        return attrs;
    }

    /**
     * RFC2256: descriptive information
     *
     * @param description new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void addDescription(String description) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_description, description);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: descriptive information
     *
     * @param description new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> addDescription(String description, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_description, description);
        return attrs;
    }

    /**
     * RFC2256: descriptive information
     *
     * @param description existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void removeDescription(String description) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_description, description);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: descriptive information
     *
     * @param description existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> removeDescription(String description, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_description, description);
        return attrs;
    }

    /**
     * RFC2256: descriptive information
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetDescription() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_description, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: descriptive information
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetDescription(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_description, "");
        return attrs;
    }

    /**
     * Size of the zimbra auth token cache size
     *
     * @return zimbaAuthTokenCacheSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1888)
    public int getZimbaAuthTokenCacheSize() {
        return getIntAttr(Provisioning.A_zimbaAuthTokenCacheSize, -1);
    }

    /**
     * Size of the zimbra auth token cache size
     *
     * @param zimbaAuthTokenCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1888)
    public void setZimbaAuthTokenCacheSize(int zimbaAuthTokenCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbaAuthTokenCacheSize, Integer.toString(zimbaAuthTokenCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Size of the zimbra auth token cache size
     *
     * @param zimbaAuthTokenCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1888)
    public Map<String,Object> setZimbaAuthTokenCacheSize(int zimbaAuthTokenCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbaAuthTokenCacheSize, Integer.toString(zimbaAuthTokenCacheSize));
        return attrs;
    }

    /**
     * Size of the zimbra auth token cache size
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1888)
    public void unsetZimbaAuthTokenCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbaAuthTokenCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Size of the zimbra auth token cache size
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1888)
    public Map<String,Object> unsetZimbaAuthTokenCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbaAuthTokenCacheSize, "");
        return attrs;
    }

    /**
     * Zimbra access control list
     *
     * @return zimbraACE, or empty array if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public String[] getACE() {
        return getMultiAttr(Provisioning.A_zimbraACE);
    }

    /**
     * Zimbra access control list
     *
     * @param zimbraACE new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public void setACE(String[] zimbraACE) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraACE, zimbraACE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra access control list
     *
     * @param zimbraACE new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public Map<String,Object> setACE(String[] zimbraACE, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraACE, zimbraACE);
        return attrs;
    }

    /**
     * Zimbra access control list
     *
     * @param zimbraACE new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public void addACE(String zimbraACE) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraACE, zimbraACE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra access control list
     *
     * @param zimbraACE new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public Map<String,Object> addACE(String zimbraACE, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraACE, zimbraACE);
        return attrs;
    }

    /**
     * Zimbra access control list
     *
     * @param zimbraACE existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public void removeACE(String zimbraACE) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraACE, zimbraACE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra access control list
     *
     * @param zimbraACE existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public Map<String,Object> removeACE(String zimbraACE, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraACE, zimbraACE);
        return attrs;
    }

    /**
     * Zimbra access control list
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public void unsetACE() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraACE, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra access control list
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public Map<String,Object> unsetACE(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraACE, "");
        return attrs;
    }

    /**
     * Flag to use AutoDiscover service url
     *
     * @return zimbraActiveSyncAutoDiscoverUseServiceUrl, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1776)
    public boolean isActiveSyncAutoDiscoverUseServiceUrl() {
        return getBooleanAttr(Provisioning.A_zimbraActiveSyncAutoDiscoverUseServiceUrl, false);
    }

    /**
     * Flag to use AutoDiscover service url
     *
     * @param zimbraActiveSyncAutoDiscoverUseServiceUrl new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1776)
    public void setActiveSyncAutoDiscoverUseServiceUrl(boolean zimbraActiveSyncAutoDiscoverUseServiceUrl) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncAutoDiscoverUseServiceUrl, zimbraActiveSyncAutoDiscoverUseServiceUrl ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to use AutoDiscover service url
     *
     * @param zimbraActiveSyncAutoDiscoverUseServiceUrl new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1776)
    public Map<String,Object> setActiveSyncAutoDiscoverUseServiceUrl(boolean zimbraActiveSyncAutoDiscoverUseServiceUrl, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncAutoDiscoverUseServiceUrl, zimbraActiveSyncAutoDiscoverUseServiceUrl ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to use AutoDiscover service url
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1776)
    public void unsetActiveSyncAutoDiscoverUseServiceUrl() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncAutoDiscoverUseServiceUrl, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to use AutoDiscover service url
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1776)
    public Map<String,Object> unsetActiveSyncAutoDiscoverUseServiceUrl(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncAutoDiscoverUseServiceUrl, "");
        return attrs;
    }

    /**
     * ActiveSync auto discovery url
     *
     * @return zimbraActiveSyncAutoDiscoveryUrl, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1775)
    public String getActiveSyncAutoDiscoveryUrl() {
        return getAttr(Provisioning.A_zimbraActiveSyncAutoDiscoveryUrl, null);
    }

    /**
     * ActiveSync auto discovery url
     *
     * @param zimbraActiveSyncAutoDiscoveryUrl new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1775)
    public void setActiveSyncAutoDiscoveryUrl(String zimbraActiveSyncAutoDiscoveryUrl) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncAutoDiscoveryUrl, zimbraActiveSyncAutoDiscoveryUrl);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * ActiveSync auto discovery url
     *
     * @param zimbraActiveSyncAutoDiscoveryUrl new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1775)
    public Map<String,Object> setActiveSyncAutoDiscoveryUrl(String zimbraActiveSyncAutoDiscoveryUrl, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncAutoDiscoveryUrl, zimbraActiveSyncAutoDiscoveryUrl);
        return attrs;
    }

    /**
     * ActiveSync auto discovery url
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1775)
    public void unsetActiveSyncAutoDiscoveryUrl() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncAutoDiscoveryUrl, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * ActiveSync auto discovery url
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1775)
    public Map<String,Object> unsetActiveSyncAutoDiscoveryUrl(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncAutoDiscoveryUrl, "");
        return attrs;
    }

    /**
     * Maximum allowed contact image size in bytes. Default value in 2MB
     *
     * @return zimbraActiveSyncContactImageSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1774)
    public int getActiveSyncContactImageSize() {
        return getIntAttr(Provisioning.A_zimbraActiveSyncContactImageSize, -1);
    }

    /**
     * Maximum allowed contact image size in bytes. Default value in 2MB
     *
     * @param zimbraActiveSyncContactImageSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1774)
    public void setActiveSyncContactImageSize(int zimbraActiveSyncContactImageSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncContactImageSize, Integer.toString(zimbraActiveSyncContactImageSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum allowed contact image size in bytes. Default value in 2MB
     *
     * @param zimbraActiveSyncContactImageSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1774)
    public Map<String,Object> setActiveSyncContactImageSize(int zimbraActiveSyncContactImageSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncContactImageSize, Integer.toString(zimbraActiveSyncContactImageSize));
        return attrs;
    }

    /**
     * Maximum allowed contact image size in bytes. Default value in 2MB
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1774)
    public void unsetActiveSyncContactImageSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncContactImageSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum allowed contact image size in bytes. Default value in 2MB
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1774)
    public Map<String,Object> unsetActiveSyncContactImageSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncContactImageSize, "");
        return attrs;
    }

    /**
     * General cache size for ActiveSync. It is used by active sync in
     * pingLockCache, syncLockCache, syncRequest and syncResponse cache.
     *
     * @return zimbraActiveSyncGeneralCacheSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1767)
    public int getActiveSyncGeneralCacheSize() {
        return getIntAttr(Provisioning.A_zimbraActiveSyncGeneralCacheSize, -1);
    }

    /**
     * General cache size for ActiveSync. It is used by active sync in
     * pingLockCache, syncLockCache, syncRequest and syncResponse cache.
     *
     * @param zimbraActiveSyncGeneralCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1767)
    public void setActiveSyncGeneralCacheSize(int zimbraActiveSyncGeneralCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncGeneralCacheSize, Integer.toString(zimbraActiveSyncGeneralCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * General cache size for ActiveSync. It is used by active sync in
     * pingLockCache, syncLockCache, syncRequest and syncResponse cache.
     *
     * @param zimbraActiveSyncGeneralCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1767)
    public Map<String,Object> setActiveSyncGeneralCacheSize(int zimbraActiveSyncGeneralCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncGeneralCacheSize, Integer.toString(zimbraActiveSyncGeneralCacheSize));
        return attrs;
    }

    /**
     * General cache size for ActiveSync. It is used by active sync in
     * pingLockCache, syncLockCache, syncRequest and syncResponse cache.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1767)
    public void unsetActiveSyncGeneralCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncGeneralCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * General cache size for ActiveSync. It is used by active sync in
     * pingLockCache, syncLockCache, syncRequest and syncResponse cache.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1767)
    public Map<String,Object> unsetActiveSyncGeneralCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncGeneralCacheSize, "");
        return attrs;
    }

    /**
     * ActiveSync maximum value for heartbeat interval in seconds. Make sure
     * it&#039;s less than nginx&#039;s
     * zimbraReverseProxyUpstreamPollingTimeout, which is now 3600 seconds.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getActiveSyncHeartbeatIntervalMaxAsString to access value as a string.
     *
     * @see #getActiveSyncHeartbeatIntervalMaxAsString()
     *
     * @return zimbraActiveSyncHeartbeatIntervalMax in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1780)
    public long getActiveSyncHeartbeatIntervalMax() {
        return getTimeInterval(Provisioning.A_zimbraActiveSyncHeartbeatIntervalMax, -1L);
    }

    /**
     * ActiveSync maximum value for heartbeat interval in seconds. Make sure
     * it&#039;s less than nginx&#039;s
     * zimbraReverseProxyUpstreamPollingTimeout, which is now 3600 seconds.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraActiveSyncHeartbeatIntervalMax, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1780)
    public String getActiveSyncHeartbeatIntervalMaxAsString() {
        return getAttr(Provisioning.A_zimbraActiveSyncHeartbeatIntervalMax, null);
    }

    /**
     * ActiveSync maximum value for heartbeat interval in seconds. Make sure
     * it&#039;s less than nginx&#039;s
     * zimbraReverseProxyUpstreamPollingTimeout, which is now 3600 seconds.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraActiveSyncHeartbeatIntervalMax new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1780)
    public void setActiveSyncHeartbeatIntervalMax(String zimbraActiveSyncHeartbeatIntervalMax) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncHeartbeatIntervalMax, zimbraActiveSyncHeartbeatIntervalMax);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * ActiveSync maximum value for heartbeat interval in seconds. Make sure
     * it&#039;s less than nginx&#039;s
     * zimbraReverseProxyUpstreamPollingTimeout, which is now 3600 seconds.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraActiveSyncHeartbeatIntervalMax new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1780)
    public Map<String,Object> setActiveSyncHeartbeatIntervalMax(String zimbraActiveSyncHeartbeatIntervalMax, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncHeartbeatIntervalMax, zimbraActiveSyncHeartbeatIntervalMax);
        return attrs;
    }

    /**
     * ActiveSync maximum value for heartbeat interval in seconds. Make sure
     * it&#039;s less than nginx&#039;s
     * zimbraReverseProxyUpstreamPollingTimeout, which is now 3600 seconds.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1780)
    public void unsetActiveSyncHeartbeatIntervalMax() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncHeartbeatIntervalMax, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * ActiveSync maximum value for heartbeat interval in seconds. Make sure
     * it&#039;s less than nginx&#039;s
     * zimbraReverseProxyUpstreamPollingTimeout, which is now 3600 seconds.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1780)
    public Map<String,Object> unsetActiveSyncHeartbeatIntervalMax(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncHeartbeatIntervalMax, "");
        return attrs;
    }

    /**
     * ActiveSync minimum value for heartbeat interval in seconds. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getActiveSyncHeartbeatIntervalMinAsString to access value as a string.
     *
     * @see #getActiveSyncHeartbeatIntervalMinAsString()
     *
     * @return zimbraActiveSyncHeartbeatIntervalMin in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1779)
    public long getActiveSyncHeartbeatIntervalMin() {
        return getTimeInterval(Provisioning.A_zimbraActiveSyncHeartbeatIntervalMin, -1L);
    }

    /**
     * ActiveSync minimum value for heartbeat interval in seconds. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraActiveSyncHeartbeatIntervalMin, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1779)
    public String getActiveSyncHeartbeatIntervalMinAsString() {
        return getAttr(Provisioning.A_zimbraActiveSyncHeartbeatIntervalMin, null);
    }

    /**
     * ActiveSync minimum value for heartbeat interval in seconds. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraActiveSyncHeartbeatIntervalMin new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1779)
    public void setActiveSyncHeartbeatIntervalMin(String zimbraActiveSyncHeartbeatIntervalMin) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncHeartbeatIntervalMin, zimbraActiveSyncHeartbeatIntervalMin);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * ActiveSync minimum value for heartbeat interval in seconds. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraActiveSyncHeartbeatIntervalMin new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1779)
    public Map<String,Object> setActiveSyncHeartbeatIntervalMin(String zimbraActiveSyncHeartbeatIntervalMin, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncHeartbeatIntervalMin, zimbraActiveSyncHeartbeatIntervalMin);
        return attrs;
    }

    /**
     * ActiveSync minimum value for heartbeat interval in seconds. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1779)
    public void unsetActiveSyncHeartbeatIntervalMin() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncHeartbeatIntervalMin, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * ActiveSync minimum value for heartbeat interval in seconds. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1779)
    public Map<String,Object> unsetActiveSyncHeartbeatIntervalMin(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncHeartbeatIntervalMin, "");
        return attrs;
    }

    /**
     * ActiveSync metadata cache expiration time in seconds. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getActiveSyncMetadataCacheExpirationAsString to access value as a string.
     *
     * @see #getActiveSyncMetadataCacheExpirationAsString()
     *
     * @return zimbraActiveSyncMetadataCacheExpiration in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1777)
    public long getActiveSyncMetadataCacheExpiration() {
        return getTimeInterval(Provisioning.A_zimbraActiveSyncMetadataCacheExpiration, -1L);
    }

    /**
     * ActiveSync metadata cache expiration time in seconds. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraActiveSyncMetadataCacheExpiration, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1777)
    public String getActiveSyncMetadataCacheExpirationAsString() {
        return getAttr(Provisioning.A_zimbraActiveSyncMetadataCacheExpiration, null);
    }

    /**
     * ActiveSync metadata cache expiration time in seconds. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraActiveSyncMetadataCacheExpiration new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1777)
    public void setActiveSyncMetadataCacheExpiration(String zimbraActiveSyncMetadataCacheExpiration) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncMetadataCacheExpiration, zimbraActiveSyncMetadataCacheExpiration);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * ActiveSync metadata cache expiration time in seconds. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraActiveSyncMetadataCacheExpiration new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1777)
    public Map<String,Object> setActiveSyncMetadataCacheExpiration(String zimbraActiveSyncMetadataCacheExpiration, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncMetadataCacheExpiration, zimbraActiveSyncMetadataCacheExpiration);
        return attrs;
    }

    /**
     * ActiveSync metadata cache expiration time in seconds. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1777)
    public void unsetActiveSyncMetadataCacheExpiration() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncMetadataCacheExpiration, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * ActiveSync metadata cache expiration time in seconds. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1777)
    public Map<String,Object> unsetActiveSyncMetadataCacheExpiration(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncMetadataCacheExpiration, "");
        return attrs;
    }

    /**
     * ActiveSync metadata cache max size
     *
     * @return zimbraActiveSyncMetadataCacheMaxSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1778)
    public int getActiveSyncMetadataCacheMaxSize() {
        return getIntAttr(Provisioning.A_zimbraActiveSyncMetadataCacheMaxSize, -1);
    }

    /**
     * ActiveSync metadata cache max size
     *
     * @param zimbraActiveSyncMetadataCacheMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1778)
    public void setActiveSyncMetadataCacheMaxSize(int zimbraActiveSyncMetadataCacheMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncMetadataCacheMaxSize, Integer.toString(zimbraActiveSyncMetadataCacheMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * ActiveSync metadata cache max size
     *
     * @param zimbraActiveSyncMetadataCacheMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1778)
    public Map<String,Object> setActiveSyncMetadataCacheMaxSize(int zimbraActiveSyncMetadataCacheMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncMetadataCacheMaxSize, Integer.toString(zimbraActiveSyncMetadataCacheMaxSize));
        return attrs;
    }

    /**
     * ActiveSync metadata cache max size
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1778)
    public void unsetActiveSyncMetadataCacheMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncMetadataCacheMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * ActiveSync metadata cache max size
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1778)
    public Map<String,Object> unsetActiveSyncMetadataCacheMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncMetadataCacheMaxSize, "");
        return attrs;
    }

    /**
     * Flag to enable or disable to allow parallel syncing of folders
     *
     * @return zimbraActiveSyncParallelSyncEnabled, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1765)
    public boolean isActiveSyncParallelSyncEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraActiveSyncParallelSyncEnabled, false);
    }

    /**
     * Flag to enable or disable to allow parallel syncing of folders
     *
     * @param zimbraActiveSyncParallelSyncEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1765)
    public void setActiveSyncParallelSyncEnabled(boolean zimbraActiveSyncParallelSyncEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncParallelSyncEnabled, zimbraActiveSyncParallelSyncEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable or disable to allow parallel syncing of folders
     *
     * @param zimbraActiveSyncParallelSyncEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1765)
    public Map<String,Object> setActiveSyncParallelSyncEnabled(boolean zimbraActiveSyncParallelSyncEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncParallelSyncEnabled, zimbraActiveSyncParallelSyncEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to enable or disable to allow parallel syncing of folders
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1765)
    public void unsetActiveSyncParallelSyncEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncParallelSyncEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable or disable to allow parallel syncing of folders
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1765)
    public Map<String,Object> unsetActiveSyncParallelSyncEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncParallelSyncEnabled, "");
        return attrs;
    }

    /**
     * Maximum results allowed for ActiveSync results.
     *
     * @return zimbraActiveSyncSearchMaxResults, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1766)
    public int getActiveSyncSearchMaxResults() {
        return getIntAttr(Provisioning.A_zimbraActiveSyncSearchMaxResults, -1);
    }

    /**
     * Maximum results allowed for ActiveSync results.
     *
     * @param zimbraActiveSyncSearchMaxResults new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1766)
    public void setActiveSyncSearchMaxResults(int zimbraActiveSyncSearchMaxResults) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncSearchMaxResults, Integer.toString(zimbraActiveSyncSearchMaxResults));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum results allowed for ActiveSync results.
     *
     * @param zimbraActiveSyncSearchMaxResults new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1766)
    public Map<String,Object> setActiveSyncSearchMaxResults(int zimbraActiveSyncSearchMaxResults, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncSearchMaxResults, Integer.toString(zimbraActiveSyncSearchMaxResults));
        return attrs;
    }

    /**
     * Maximum results allowed for ActiveSync results.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1766)
    public void unsetActiveSyncSearchMaxResults() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncSearchMaxResults, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum results allowed for ActiveSync results.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1766)
    public Map<String,Object> unsetActiveSyncSearchMaxResults(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncSearchMaxResults, "");
        return attrs;
    }

    /**
     * ActiveSync SyncState cache heap size. Use suffixes B, K, M, G for
     * bytes, kilobytes, megabytes and gigabytes respectively
     *
     * @return zimbraActiveSyncSyncStateItemCacheHeapSize, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1768)
    public String getActiveSyncSyncStateItemCacheHeapSize() {
        return getAttr(Provisioning.A_zimbraActiveSyncSyncStateItemCacheHeapSize, null);
    }

    /**
     * ActiveSync SyncState cache heap size. Use suffixes B, K, M, G for
     * bytes, kilobytes, megabytes and gigabytes respectively
     *
     * @param zimbraActiveSyncSyncStateItemCacheHeapSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1768)
    public void setActiveSyncSyncStateItemCacheHeapSize(String zimbraActiveSyncSyncStateItemCacheHeapSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncSyncStateItemCacheHeapSize, zimbraActiveSyncSyncStateItemCacheHeapSize);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * ActiveSync SyncState cache heap size. Use suffixes B, K, M, G for
     * bytes, kilobytes, megabytes and gigabytes respectively
     *
     * @param zimbraActiveSyncSyncStateItemCacheHeapSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1768)
    public Map<String,Object> setActiveSyncSyncStateItemCacheHeapSize(String zimbraActiveSyncSyncStateItemCacheHeapSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncSyncStateItemCacheHeapSize, zimbraActiveSyncSyncStateItemCacheHeapSize);
        return attrs;
    }

    /**
     * ActiveSync SyncState cache heap size. Use suffixes B, K, M, G for
     * bytes, kilobytes, megabytes and gigabytes respectively
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1768)
    public void unsetActiveSyncSyncStateItemCacheHeapSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncSyncStateItemCacheHeapSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * ActiveSync SyncState cache heap size. Use suffixes B, K, M, G for
     * bytes, kilobytes, megabytes and gigabytes respectively
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1768)
    public Map<String,Object> unsetActiveSyncSyncStateItemCacheHeapSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncSyncStateItemCacheHeapSize, "");
        return attrs;
    }

    /**
     * Supported ActiveSync versions by zimbra
     *
     * @return zimbraActiveSyncVersions, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1773)
    public String getActiveSyncVersions() {
        return getAttr(Provisioning.A_zimbraActiveSyncVersions, null);
    }

    /**
     * Supported ActiveSync versions by zimbra
     *
     * @param zimbraActiveSyncVersions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1773)
    public void setActiveSyncVersions(String zimbraActiveSyncVersions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncVersions, zimbraActiveSyncVersions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Supported ActiveSync versions by zimbra
     *
     * @param zimbraActiveSyncVersions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1773)
    public Map<String,Object> setActiveSyncVersions(String zimbraActiveSyncVersions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncVersions, zimbraActiveSyncVersions);
        return attrs;
    }

    /**
     * Supported ActiveSync versions by zimbra
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1773)
    public void unsetActiveSyncVersions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncVersions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Supported ActiveSync versions by zimbra
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1773)
    public Map<String,Object> unsetActiveSyncVersions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncVersions, "");
        return attrs;
    }

    /**
     * Max no of elements in acl admin cache credential
     *
     * @return zimbraAdminAclCacheCredentialMaxsize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1689)
    public int getAdminAclCacheCredentialMaxsize() {
        return getIntAttr(Provisioning.A_zimbraAdminAclCacheCredentialMaxsize, -1);
    }

    /**
     * Max no of elements in acl admin cache credential
     *
     * @param zimbraAdminAclCacheCredentialMaxsize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1689)
    public void setAdminAclCacheCredentialMaxsize(int zimbraAdminAclCacheCredentialMaxsize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAclCacheCredentialMaxsize, Integer.toString(zimbraAdminAclCacheCredentialMaxsize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max no of elements in acl admin cache credential
     *
     * @param zimbraAdminAclCacheCredentialMaxsize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1689)
    public Map<String,Object> setAdminAclCacheCredentialMaxsize(int zimbraAdminAclCacheCredentialMaxsize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAclCacheCredentialMaxsize, Integer.toString(zimbraAdminAclCacheCredentialMaxsize));
        return attrs;
    }

    /**
     * Max no of elements in acl admin cache credential
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1689)
    public void unsetAdminAclCacheCredentialMaxsize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAclCacheCredentialMaxsize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max no of elements in acl admin cache credential
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1689)
    public Map<String,Object> unsetAdminAclCacheCredentialMaxsize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAclCacheCredentialMaxsize, "");
        return attrs;
    }

    /**
     * Flag to enable or disable admin acl cache
     *
     * @return zimbraAdminAclCacheEnabled, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1690)
    public boolean isAdminAclCacheEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraAdminAclCacheEnabled, false);
    }

    /**
     * Flag to enable or disable admin acl cache
     *
     * @param zimbraAdminAclCacheEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1690)
    public void setAdminAclCacheEnabled(boolean zimbraAdminAclCacheEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAclCacheEnabled, zimbraAdminAclCacheEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable or disable admin acl cache
     *
     * @param zimbraAdminAclCacheEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1690)
    public Map<String,Object> setAdminAclCacheEnabled(boolean zimbraAdminAclCacheEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAclCacheEnabled, zimbraAdminAclCacheEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to enable or disable admin acl cache
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1690)
    public void unsetAdminAclCacheEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAclCacheEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable or disable admin acl cache
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1690)
    public Map<String,Object> unsetAdminAclCacheEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAclCacheEnabled, "");
        return attrs;
    }

    /**
     * Max age of admin acl target cache in minutes
     *
     * @return zimbraAdminAclCacheTargetMaxAge, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1688)
    public int getAdminAclCacheTargetMaxAge() {
        return getIntAttr(Provisioning.A_zimbraAdminAclCacheTargetMaxAge, -1);
    }

    /**
     * Max age of admin acl target cache in minutes
     *
     * @param zimbraAdminAclCacheTargetMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1688)
    public void setAdminAclCacheTargetMaxAge(int zimbraAdminAclCacheTargetMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAclCacheTargetMaxAge, Integer.toString(zimbraAdminAclCacheTargetMaxAge));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max age of admin acl target cache in minutes
     *
     * @param zimbraAdminAclCacheTargetMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1688)
    public Map<String,Object> setAdminAclCacheTargetMaxAge(int zimbraAdminAclCacheTargetMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAclCacheTargetMaxAge, Integer.toString(zimbraAdminAclCacheTargetMaxAge));
        return attrs;
    }

    /**
     * Max age of admin acl target cache in minutes
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1688)
    public void unsetAdminAclCacheTargetMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAclCacheTargetMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max age of admin acl target cache in minutes
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1688)
    public Map<String,Object> unsetAdminAclCacheTargetMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAclCacheTargetMaxAge, "");
        return attrs;
    }

    /**
     * Max no of elements in admin acl target cache
     *
     * @return zimbraAdminAclCacheTargetMaxsize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1720)
    public int getAdminAclCacheTargetMaxsize() {
        return getIntAttr(Provisioning.A_zimbraAdminAclCacheTargetMaxsize, -1);
    }

    /**
     * Max no of elements in admin acl target cache
     *
     * @param zimbraAdminAclCacheTargetMaxsize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1720)
    public void setAdminAclCacheTargetMaxsize(int zimbraAdminAclCacheTargetMaxsize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAclCacheTargetMaxsize, Integer.toString(zimbraAdminAclCacheTargetMaxsize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max no of elements in admin acl target cache
     *
     * @param zimbraAdminAclCacheTargetMaxsize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1720)
    public Map<String,Object> setAdminAclCacheTargetMaxsize(int zimbraAdminAclCacheTargetMaxsize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAclCacheTargetMaxsize, Integer.toString(zimbraAdminAclCacheTargetMaxsize));
        return attrs;
    }

    /**
     * Max no of elements in admin acl target cache
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1720)
    public void unsetAdminAclCacheTargetMaxsize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAclCacheTargetMaxsize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max no of elements in admin acl target cache
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1720)
    public Map<String,Object> unsetAdminAclCacheTargetMaxsize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAclCacheTargetMaxsize, "");
        return attrs;
    }

    /**
     * interface address on which Admin HTTPS server should listen; if empty,
     * binds to all interfaces
     *
     * @return zimbraAdminBindAddress, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1368)
    public String getAdminBindAddress() {
        return getAttr(Provisioning.A_zimbraAdminBindAddress, null);
    }

    /**
     * interface address on which Admin HTTPS server should listen; if empty,
     * binds to all interfaces
     *
     * @param zimbraAdminBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1368)
    public void setAdminBindAddress(String zimbraAdminBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminBindAddress, zimbraAdminBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which Admin HTTPS server should listen; if empty,
     * binds to all interfaces
     *
     * @param zimbraAdminBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1368)
    public Map<String,Object> setAdminBindAddress(String zimbraAdminBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminBindAddress, zimbraAdminBindAddress);
        return attrs;
    }

    /**
     * interface address on which Admin HTTPS server should listen; if empty,
     * binds to all interfaces
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1368)
    public void unsetAdminBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which Admin HTTPS server should listen; if empty,
     * binds to all interfaces
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1368)
    public Map<String,Object> unsetAdminBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminBindAddress, "");
        return attrs;
    }

    /**
     * Size of the thread pool executor used by ComputeAggregateQuota call
     *
     * @return zimbraAdminComputeAggregateQuotaThreadPoolSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1744)
    public int getAdminComputeAggregateQuotaThreadPoolSize() {
        return getIntAttr(Provisioning.A_zimbraAdminComputeAggregateQuotaThreadPoolSize, -1);
    }

    /**
     * Size of the thread pool executor used by ComputeAggregateQuota call
     *
     * @param zimbraAdminComputeAggregateQuotaThreadPoolSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1744)
    public void setAdminComputeAggregateQuotaThreadPoolSize(int zimbraAdminComputeAggregateQuotaThreadPoolSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminComputeAggregateQuotaThreadPoolSize, Integer.toString(zimbraAdminComputeAggregateQuotaThreadPoolSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Size of the thread pool executor used by ComputeAggregateQuota call
     *
     * @param zimbraAdminComputeAggregateQuotaThreadPoolSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1744)
    public Map<String,Object> setAdminComputeAggregateQuotaThreadPoolSize(int zimbraAdminComputeAggregateQuotaThreadPoolSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminComputeAggregateQuotaThreadPoolSize, Integer.toString(zimbraAdminComputeAggregateQuotaThreadPoolSize));
        return attrs;
    }

    /**
     * Size of the thread pool executor used by ComputeAggregateQuota call
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1744)
    public void unsetAdminComputeAggregateQuotaThreadPoolSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminComputeAggregateQuotaThreadPoolSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Size of the thread pool executor used by ComputeAggregateQuota call
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1744)
    public Map<String,Object> unsetAdminComputeAggregateQuotaThreadPoolSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminComputeAggregateQuotaThreadPoolSize, "");
        return attrs;
    }

    /**
     * number of admin initiated imap import handler threads
     *
     * @return zimbraAdminImapImportNumThreads, or -1 if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1113)
    public int getAdminImapImportNumThreads() {
        return getIntAttr(Provisioning.A_zimbraAdminImapImportNumThreads, -1);
    }

    /**
     * number of admin initiated imap import handler threads
     *
     * @param zimbraAdminImapImportNumThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1113)
    public void setAdminImapImportNumThreads(int zimbraAdminImapImportNumThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminImapImportNumThreads, Integer.toString(zimbraAdminImapImportNumThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of admin initiated imap import handler threads
     *
     * @param zimbraAdminImapImportNumThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1113)
    public Map<String,Object> setAdminImapImportNumThreads(int zimbraAdminImapImportNumThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminImapImportNumThreads, Integer.toString(zimbraAdminImapImportNumThreads));
        return attrs;
    }

    /**
     * number of admin initiated imap import handler threads
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1113)
    public void unsetAdminImapImportNumThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminImapImportNumThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of admin initiated imap import handler threads
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1113)
    public Map<String,Object> unsetAdminImapImportNumThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminImapImportNumThreads, "");
        return attrs;
    }

    /**
     * SSL port for admin UI
     *
     * <p>Use getAdminPortAsString to access value as a string.
     *
     * @see #getAdminPortAsString()
     *
     * @return zimbraAdminPort, or -1 if unset
     */
    @ZAttr(id=155)
    public int getAdminPort() {
        return getIntAttr(Provisioning.A_zimbraAdminPort, -1);
    }

    /**
     * SSL port for admin UI
     *
     * @return zimbraAdminPort, or null if unset
     */
    @ZAttr(id=155)
    public String getAdminPortAsString() {
        return getAttr(Provisioning.A_zimbraAdminPort, null);
    }

    /**
     * SSL port for admin UI
     *
     * @param zimbraAdminPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=155)
    public void setAdminPort(int zimbraAdminPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminPort, Integer.toString(zimbraAdminPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port for admin UI
     *
     * @param zimbraAdminPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=155)
    public Map<String,Object> setAdminPort(int zimbraAdminPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminPort, Integer.toString(zimbraAdminPort));
        return attrs;
    }

    /**
     * SSL port for admin UI
     *
     * @param zimbraAdminPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=155)
    public void setAdminPortAsString(String zimbraAdminPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminPort, zimbraAdminPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port for admin UI
     *
     * @param zimbraAdminPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=155)
    public Map<String,Object> setAdminPortAsString(String zimbraAdminPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminPort, zimbraAdminPort);
        return attrs;
    }

    /**
     * SSL port for admin UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=155)
    public void unsetAdminPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port for admin UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=155)
    public Map<String,Object> unsetAdminPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminPort, "");
        return attrs;
    }

    /**
     * SSL proxy port for admin console UI
     *
     * <p>Use getAdminProxyPortAsString to access value as a string.
     *
     * @see #getAdminProxyPortAsString()
     *
     * @return zimbraAdminProxyPort, or -1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1322)
    public int getAdminProxyPort() {
        return getIntAttr(Provisioning.A_zimbraAdminProxyPort, -1);
    }

    /**
     * SSL proxy port for admin console UI
     *
     * @return zimbraAdminProxyPort, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1322)
    public String getAdminProxyPortAsString() {
        return getAttr(Provisioning.A_zimbraAdminProxyPort, null);
    }

    /**
     * SSL proxy port for admin console UI
     *
     * @param zimbraAdminProxyPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1322)
    public void setAdminProxyPort(int zimbraAdminProxyPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminProxyPort, Integer.toString(zimbraAdminProxyPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL proxy port for admin console UI
     *
     * @param zimbraAdminProxyPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1322)
    public Map<String,Object> setAdminProxyPort(int zimbraAdminProxyPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminProxyPort, Integer.toString(zimbraAdminProxyPort));
        return attrs;
    }

    /**
     * SSL proxy port for admin console UI
     *
     * @param zimbraAdminProxyPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1322)
    public void setAdminProxyPortAsString(String zimbraAdminProxyPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminProxyPort, zimbraAdminProxyPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL proxy port for admin console UI
     *
     * @param zimbraAdminProxyPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1322)
    public Map<String,Object> setAdminProxyPortAsString(String zimbraAdminProxyPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminProxyPort, zimbraAdminProxyPort);
        return attrs;
    }

    /**
     * SSL proxy port for admin console UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1322)
    public void unsetAdminProxyPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminProxyPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL proxy port for admin console UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1322)
    public Map<String,Object> unsetAdminProxyPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminProxyPort, "");
        return attrs;
    }

    /**
     * zimbra admin url scheme
     *
     * @return zimbraAdminServiceScheme, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1728)
    public String getAdminServiceScheme() {
        return getAttr(Provisioning.A_zimbraAdminServiceScheme, null);
    }

    /**
     * zimbra admin url scheme
     *
     * @param zimbraAdminServiceScheme new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1728)
    public void setAdminServiceScheme(String zimbraAdminServiceScheme) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminServiceScheme, zimbraAdminServiceScheme);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * zimbra admin url scheme
     *
     * @param zimbraAdminServiceScheme new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1728)
    public Map<String,Object> setAdminServiceScheme(String zimbraAdminServiceScheme, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminServiceScheme, zimbraAdminServiceScheme);
        return attrs;
    }

    /**
     * zimbra admin url scheme
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1728)
    public void unsetAdminServiceScheme() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminServiceScheme, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * zimbra admin url scheme
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1728)
    public Map<String,Object> unsetAdminServiceScheme(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminServiceScheme, "");
        return attrs;
    }

    /**
     * Maximum number of admin SOAP sessions a single user can have open at
     * once
     *
     * @return zimbraAdminSessionLimit, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1736)
    public int getAdminSessionLimit() {
        return getIntAttr(Provisioning.A_zimbraAdminSessionLimit, -1);
    }

    /**
     * Maximum number of admin SOAP sessions a single user can have open at
     * once
     *
     * @param zimbraAdminSessionLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1736)
    public void setAdminSessionLimit(int zimbraAdminSessionLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSessionLimit, Integer.toString(zimbraAdminSessionLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of admin SOAP sessions a single user can have open at
     * once
     *
     * @param zimbraAdminSessionLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1736)
    public Map<String,Object> setAdminSessionLimit(int zimbraAdminSessionLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSessionLimit, Integer.toString(zimbraAdminSessionLimit));
        return attrs;
    }

    /**
     * Maximum number of admin SOAP sessions a single user can have open at
     * once
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1736)
    public void unsetAdminSessionLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSessionLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of admin SOAP sessions a single user can have open at
     * once
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1736)
    public Map<String,Object> unsetAdminSessionLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSessionLimit, "");
        return attrs;
    }

    /**
     * URL prefix for where the zimbraAdmin app resides on this server
     *
     * @return zimbraAdminURL, or null if unset
     */
    @ZAttr(id=497)
    public String getAdminURL() {
        return getAttr(Provisioning.A_zimbraAdminURL, null);
    }

    /**
     * URL prefix for where the zimbraAdmin app resides on this server
     *
     * @param zimbraAdminURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=497)
    public void setAdminURL(String zimbraAdminURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminURL, zimbraAdminURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL prefix for where the zimbraAdmin app resides on this server
     *
     * @param zimbraAdminURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=497)
    public Map<String,Object> setAdminURL(String zimbraAdminURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminURL, zimbraAdminURL);
        return attrs;
    }

    /**
     * URL prefix for where the zimbraAdmin app resides on this server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=497)
    public void unsetAdminURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL prefix for where the zimbraAdmin app resides on this server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=497)
    public Map<String,Object> unsetAdminURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminURL, "");
        return attrs;
    }

    /**
     * Default timeout in seconds for zimbra admin wait set request. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getAdminWaitsetDefaultRequestTimeoutAsString to access value as a string.
     *
     * @see #getAdminWaitsetDefaultRequestTimeoutAsString()
     *
     * @return zimbraAdminWaitsetDefaultRequestTimeout in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1729)
    public long getAdminWaitsetDefaultRequestTimeout() {
        return getTimeInterval(Provisioning.A_zimbraAdminWaitsetDefaultRequestTimeout, -1L);
    }

    /**
     * Default timeout in seconds for zimbra admin wait set request. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraAdminWaitsetDefaultRequestTimeout, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1729)
    public String getAdminWaitsetDefaultRequestTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraAdminWaitsetDefaultRequestTimeout, null);
    }

    /**
     * Default timeout in seconds for zimbra admin wait set request. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraAdminWaitsetDefaultRequestTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1729)
    public void setAdminWaitsetDefaultRequestTimeout(String zimbraAdminWaitsetDefaultRequestTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminWaitsetDefaultRequestTimeout, zimbraAdminWaitsetDefaultRequestTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Default timeout in seconds for zimbra admin wait set request. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraAdminWaitsetDefaultRequestTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1729)
    public Map<String,Object> setAdminWaitsetDefaultRequestTimeout(String zimbraAdminWaitsetDefaultRequestTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminWaitsetDefaultRequestTimeout, zimbraAdminWaitsetDefaultRequestTimeout);
        return attrs;
    }

    /**
     * Default timeout in seconds for zimbra admin wait set request. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1729)
    public void unsetAdminWaitsetDefaultRequestTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminWaitsetDefaultRequestTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Default timeout in seconds for zimbra admin wait set request. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1729)
    public Map<String,Object> unsetAdminWaitsetDefaultRequestTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminWaitsetDefaultRequestTimeout, "");
        return attrs;
    }

    /**
     * Maximum timeout in seconds for zimbra admin waitset request. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getAdminWaitsetMaxRequestTimeoutAsString to access value as a string.
     *
     * @see #getAdminWaitsetMaxRequestTimeoutAsString()
     *
     * @return zimbraAdminWaitsetMaxRequestTimeout in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1730)
    public long getAdminWaitsetMaxRequestTimeout() {
        return getTimeInterval(Provisioning.A_zimbraAdminWaitsetMaxRequestTimeout, -1L);
    }

    /**
     * Maximum timeout in seconds for zimbra admin waitset request. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraAdminWaitsetMaxRequestTimeout, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1730)
    public String getAdminWaitsetMaxRequestTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraAdminWaitsetMaxRequestTimeout, null);
    }

    /**
     * Maximum timeout in seconds for zimbra admin waitset request. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraAdminWaitsetMaxRequestTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1730)
    public void setAdminWaitsetMaxRequestTimeout(String zimbraAdminWaitsetMaxRequestTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminWaitsetMaxRequestTimeout, zimbraAdminWaitsetMaxRequestTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum timeout in seconds for zimbra admin waitset request. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraAdminWaitsetMaxRequestTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1730)
    public Map<String,Object> setAdminWaitsetMaxRequestTimeout(String zimbraAdminWaitsetMaxRequestTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminWaitsetMaxRequestTimeout, zimbraAdminWaitsetMaxRequestTimeout);
        return attrs;
    }

    /**
     * Maximum timeout in seconds for zimbra admin waitset request. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1730)
    public void unsetAdminWaitsetMaxRequestTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminWaitsetMaxRequestTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum timeout in seconds for zimbra admin waitset request. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1730)
    public Map<String,Object> unsetAdminWaitsetMaxRequestTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminWaitsetMaxRequestTimeout, "");
        return attrs;
    }

    /**
     * Minimum timeout in seconds for zimbra admin waitset request. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getAdminWaitsetMinRequestTimeoutAsString to access value as a string.
     *
     * @see #getAdminWaitsetMinRequestTimeoutAsString()
     *
     * @return zimbraAdminWaitsetMinRequestTimeout in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1731)
    public long getAdminWaitsetMinRequestTimeout() {
        return getTimeInterval(Provisioning.A_zimbraAdminWaitsetMinRequestTimeout, -1L);
    }

    /**
     * Minimum timeout in seconds for zimbra admin waitset request. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraAdminWaitsetMinRequestTimeout, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1731)
    public String getAdminWaitsetMinRequestTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraAdminWaitsetMinRequestTimeout, null);
    }

    /**
     * Minimum timeout in seconds for zimbra admin waitset request. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraAdminWaitsetMinRequestTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1731)
    public void setAdminWaitsetMinRequestTimeout(String zimbraAdminWaitsetMinRequestTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminWaitsetMinRequestTimeout, zimbraAdminWaitsetMinRequestTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum timeout in seconds for zimbra admin waitset request. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraAdminWaitsetMinRequestTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1731)
    public Map<String,Object> setAdminWaitsetMinRequestTimeout(String zimbraAdminWaitsetMinRequestTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminWaitsetMinRequestTimeout, zimbraAdminWaitsetMinRequestTimeout);
        return attrs;
    }

    /**
     * Minimum timeout in seconds for zimbra admin waitset request. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1731)
    public void unsetAdminWaitsetMinRequestTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminWaitsetMinRequestTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum timeout in seconds for zimbra admin waitset request. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1731)
    public Map<String,Object> unsetAdminWaitsetMinRequestTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminWaitsetMinRequestTimeout, "");
        return attrs;
    }

    /**
     * Deprecated since: 9.0.0_BETA1. dspam has been removed from Zimbra and
     * replaced with CRM114. Orig desc: Whether or not Amavis should use
     * DSPAM as an additional score factor for SPAM. Defaults to FALSE
     *
     * @return zimbraAmavisDSPAMEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1465)
    public boolean isAmavisDSPAMEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraAmavisDSPAMEnabled, false);
    }

    /**
     * Deprecated since: 9.0.0_BETA1. dspam has been removed from Zimbra and
     * replaced with CRM114. Orig desc: Whether or not Amavis should use
     * DSPAM as an additional score factor for SPAM. Defaults to FALSE
     *
     * @param zimbraAmavisDSPAMEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1465)
    public void setAmavisDSPAMEnabled(boolean zimbraAmavisDSPAMEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisDSPAMEnabled, zimbraAmavisDSPAMEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 9.0.0_BETA1. dspam has been removed from Zimbra and
     * replaced with CRM114. Orig desc: Whether or not Amavis should use
     * DSPAM as an additional score factor for SPAM. Defaults to FALSE
     *
     * @param zimbraAmavisDSPAMEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1465)
    public Map<String,Object> setAmavisDSPAMEnabled(boolean zimbraAmavisDSPAMEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisDSPAMEnabled, zimbraAmavisDSPAMEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 9.0.0_BETA1. dspam has been removed from Zimbra and
     * replaced with CRM114. Orig desc: Whether or not Amavis should use
     * DSPAM as an additional score factor for SPAM. Defaults to FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1465)
    public void unsetAmavisDSPAMEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisDSPAMEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 9.0.0_BETA1. dspam has been removed from Zimbra and
     * replaced with CRM114. Orig desc: Whether or not Amavis should use
     * DSPAM as an additional score factor for SPAM. Defaults to FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1465)
    public Map<String,Object> unsetAmavisDSPAMEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisDSPAMEnabled, "");
        return attrs;
    }

    /**
     * Whether or not Amavis should verify DKIM keys. Defaults to TRUE
     *
     * @return zimbraAmavisEnableDKIMVerification, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1463)
    public boolean isAmavisEnableDKIMVerification() {
        return getBooleanAttr(Provisioning.A_zimbraAmavisEnableDKIMVerification, false);
    }

    /**
     * Whether or not Amavis should verify DKIM keys. Defaults to TRUE
     *
     * @param zimbraAmavisEnableDKIMVerification new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1463)
    public void setAmavisEnableDKIMVerification(boolean zimbraAmavisEnableDKIMVerification) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisEnableDKIMVerification, zimbraAmavisEnableDKIMVerification ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not Amavis should verify DKIM keys. Defaults to TRUE
     *
     * @param zimbraAmavisEnableDKIMVerification new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1463)
    public Map<String,Object> setAmavisEnableDKIMVerification(boolean zimbraAmavisEnableDKIMVerification, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisEnableDKIMVerification, zimbraAmavisEnableDKIMVerification ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether or not Amavis should verify DKIM keys. Defaults to TRUE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1463)
    public void unsetAmavisEnableDKIMVerification() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisEnableDKIMVerification, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not Amavis should verify DKIM keys. Defaults to TRUE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1463)
    public Map<String,Object> unsetAmavisEnableDKIMVerification(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisEnableDKIMVerification, "");
        return attrs;
    }

    /**
     * Amavis final destination for Spam. Default is to discard it
     *
     * <p>Valid values: [D_BOUNCE, D_DISCARD, D_PASS, D_REJECT]
     *
     * @return zimbraAmavisFinalSpamDestiny, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1460)
    public ZAttrProvisioning.AmavisFinalSpamDestiny getAmavisFinalSpamDestiny() {
        try { String v = getAttr(Provisioning.A_zimbraAmavisFinalSpamDestiny); return v == null ? null : ZAttrProvisioning.AmavisFinalSpamDestiny.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Amavis final destination for Spam. Default is to discard it
     *
     * <p>Valid values: [D_BOUNCE, D_DISCARD, D_PASS, D_REJECT]
     *
     * @return zimbraAmavisFinalSpamDestiny, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1460)
    public String getAmavisFinalSpamDestinyAsString() {
        return getAttr(Provisioning.A_zimbraAmavisFinalSpamDestiny, null);
    }

    /**
     * Amavis final destination for Spam. Default is to discard it
     *
     * <p>Valid values: [D_BOUNCE, D_DISCARD, D_PASS, D_REJECT]
     *
     * @param zimbraAmavisFinalSpamDestiny new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1460)
    public void setAmavisFinalSpamDestiny(ZAttrProvisioning.AmavisFinalSpamDestiny zimbraAmavisFinalSpamDestiny) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisFinalSpamDestiny, zimbraAmavisFinalSpamDestiny.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Amavis final destination for Spam. Default is to discard it
     *
     * <p>Valid values: [D_BOUNCE, D_DISCARD, D_PASS, D_REJECT]
     *
     * @param zimbraAmavisFinalSpamDestiny new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1460)
    public Map<String,Object> setAmavisFinalSpamDestiny(ZAttrProvisioning.AmavisFinalSpamDestiny zimbraAmavisFinalSpamDestiny, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisFinalSpamDestiny, zimbraAmavisFinalSpamDestiny.toString());
        return attrs;
    }

    /**
     * Amavis final destination for Spam. Default is to discard it
     *
     * <p>Valid values: [D_BOUNCE, D_DISCARD, D_PASS, D_REJECT]
     *
     * @param zimbraAmavisFinalSpamDestiny new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1460)
    public void setAmavisFinalSpamDestinyAsString(String zimbraAmavisFinalSpamDestiny) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisFinalSpamDestiny, zimbraAmavisFinalSpamDestiny);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Amavis final destination for Spam. Default is to discard it
     *
     * <p>Valid values: [D_BOUNCE, D_DISCARD, D_PASS, D_REJECT]
     *
     * @param zimbraAmavisFinalSpamDestiny new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1460)
    public Map<String,Object> setAmavisFinalSpamDestinyAsString(String zimbraAmavisFinalSpamDestiny, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisFinalSpamDestiny, zimbraAmavisFinalSpamDestiny);
        return attrs;
    }

    /**
     * Amavis final destination for Spam. Default is to discard it
     *
     * <p>Valid values: [D_BOUNCE, D_DISCARD, D_PASS, D_REJECT]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1460)
    public void unsetAmavisFinalSpamDestiny() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisFinalSpamDestiny, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Amavis final destination for Spam. Default is to discard it
     *
     * <p>Valid values: [D_BOUNCE, D_DISCARD, D_PASS, D_REJECT]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1460)
    public Map<String,Object> unsetAmavisFinalSpamDestiny(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisFinalSpamDestiny, "");
        return attrs;
    }

    /**
     * Loglevel for Amavis. Defaults to 1. Valid range is 0-5
     *
     * @return zimbraAmavisLogLevel, or -1 if unset
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1488)
    public int getAmavisLogLevel() {
        return getIntAttr(Provisioning.A_zimbraAmavisLogLevel, -1);
    }

    /**
     * Loglevel for Amavis. Defaults to 1. Valid range is 0-5
     *
     * @param zimbraAmavisLogLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1488)
    public void setAmavisLogLevel(int zimbraAmavisLogLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisLogLevel, Integer.toString(zimbraAmavisLogLevel));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Loglevel for Amavis. Defaults to 1. Valid range is 0-5
     *
     * @param zimbraAmavisLogLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1488)
    public Map<String,Object> setAmavisLogLevel(int zimbraAmavisLogLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisLogLevel, Integer.toString(zimbraAmavisLogLevel));
        return attrs;
    }

    /**
     * Loglevel for Amavis. Defaults to 1. Valid range is 0-5
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1488)
    public void unsetAmavisLogLevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisLogLevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Loglevel for Amavis. Defaults to 1. Valid range is 0-5
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1488)
    public Map<String,Object> unsetAmavisLogLevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisLogLevel, "");
        return attrs;
    }

    /**
     * Maximum number of Amavis servers to run. Default is 10
     *
     * @return zimbraAmavisMaxServers, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1461)
    public int getAmavisMaxServers() {
        return getIntAttr(Provisioning.A_zimbraAmavisMaxServers, -1);
    }

    /**
     * Maximum number of Amavis servers to run. Default is 10
     *
     * @param zimbraAmavisMaxServers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1461)
    public void setAmavisMaxServers(int zimbraAmavisMaxServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisMaxServers, Integer.toString(zimbraAmavisMaxServers));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of Amavis servers to run. Default is 10
     *
     * @param zimbraAmavisMaxServers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1461)
    public Map<String,Object> setAmavisMaxServers(int zimbraAmavisMaxServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisMaxServers, Integer.toString(zimbraAmavisMaxServers));
        return attrs;
    }

    /**
     * Maximum number of Amavis servers to run. Default is 10
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1461)
    public void unsetAmavisMaxServers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisMaxServers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of Amavis servers to run. Default is 10
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1461)
    public Map<String,Object> unsetAmavisMaxServers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisMaxServers, "");
        return attrs;
    }

    /**
     * Whether or not Amavis should Bypass SpamAsassin for originating email.
     * Defaults to FALSE
     *
     * @return zimbraAmavisOriginatingBypassSA, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1464)
    public boolean isAmavisOriginatingBypassSA() {
        return getBooleanAttr(Provisioning.A_zimbraAmavisOriginatingBypassSA, false);
    }

    /**
     * Whether or not Amavis should Bypass SpamAsassin for originating email.
     * Defaults to FALSE
     *
     * @param zimbraAmavisOriginatingBypassSA new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1464)
    public void setAmavisOriginatingBypassSA(boolean zimbraAmavisOriginatingBypassSA) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisOriginatingBypassSA, zimbraAmavisOriginatingBypassSA ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not Amavis should Bypass SpamAsassin for originating email.
     * Defaults to FALSE
     *
     * @param zimbraAmavisOriginatingBypassSA new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1464)
    public Map<String,Object> setAmavisOriginatingBypassSA(boolean zimbraAmavisOriginatingBypassSA, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisOriginatingBypassSA, zimbraAmavisOriginatingBypassSA ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether or not Amavis should Bypass SpamAsassin for originating email.
     * Defaults to FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1464)
    public void unsetAmavisOriginatingBypassSA() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisOriginatingBypassSA, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not Amavis should Bypass SpamAsassin for originating email.
     * Defaults to FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1464)
    public Map<String,Object> unsetAmavisOriginatingBypassSA(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisOriginatingBypassSA, "");
        return attrs;
    }

    /**
     * Loglevel for SpamAssassin when called via Amavis. Defaults to 0
     * (info). Can be 0 or 1 (info, all)
     *
     * @return zimbraAmavisSALogLevel, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1578)
    public int getAmavisSALogLevel() {
        return getIntAttr(Provisioning.A_zimbraAmavisSALogLevel, -1);
    }

    /**
     * Loglevel for SpamAssassin when called via Amavis. Defaults to 0
     * (info). Can be 0 or 1 (info, all)
     *
     * @param zimbraAmavisSALogLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1578)
    public void setAmavisSALogLevel(int zimbraAmavisSALogLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisSALogLevel, Integer.toString(zimbraAmavisSALogLevel));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Loglevel for SpamAssassin when called via Amavis. Defaults to 0
     * (info). Can be 0 or 1 (info, all)
     *
     * @param zimbraAmavisSALogLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1578)
    public Map<String,Object> setAmavisSALogLevel(int zimbraAmavisSALogLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisSALogLevel, Integer.toString(zimbraAmavisSALogLevel));
        return attrs;
    }

    /**
     * Loglevel for SpamAssassin when called via Amavis. Defaults to 0
     * (info). Can be 0 or 1 (info, all)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1578)
    public void unsetAmavisSALogLevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisSALogLevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Loglevel for SpamAssassin when called via Amavis. Defaults to 0
     * (info). Can be 0 or 1 (info, all)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1578)
    public Map<String,Object> unsetAmavisSALogLevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisSALogLevel, "");
        return attrs;
    }

    /**
     * flag to enable or disable anti spam restarts
     *
     * @return zimbraAntiSpamEnableRestarts, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1691)
    public boolean isAntiSpamEnableRestarts() {
        return getBooleanAttr(Provisioning.A_zimbraAntiSpamEnableRestarts, false);
    }

    /**
     * flag to enable or disable anti spam restarts
     *
     * @param zimbraAntiSpamEnableRestarts new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1691)
    public void setAntiSpamEnableRestarts(boolean zimbraAntiSpamEnableRestarts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntiSpamEnableRestarts, zimbraAntiSpamEnableRestarts ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * flag to enable or disable anti spam restarts
     *
     * @param zimbraAntiSpamEnableRestarts new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1691)
    public Map<String,Object> setAntiSpamEnableRestarts(boolean zimbraAntiSpamEnableRestarts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntiSpamEnableRestarts, zimbraAntiSpamEnableRestarts ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * flag to enable or disable anti spam restarts
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1691)
    public void unsetAntiSpamEnableRestarts() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntiSpamEnableRestarts, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * flag to enable or disable anti spam restarts
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1691)
    public Map<String,Object> unsetAntiSpamEnableRestarts(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntiSpamEnableRestarts, "");
        return attrs;
    }

    /**
     * flag to enable or disable anti spam rule compilations
     *
     * @return zimbraAntiSpamEnableRuleCompilation, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1693)
    public boolean isAntiSpamEnableRuleCompilation() {
        return getBooleanAttr(Provisioning.A_zimbraAntiSpamEnableRuleCompilation, false);
    }

    /**
     * flag to enable or disable anti spam rule compilations
     *
     * @param zimbraAntiSpamEnableRuleCompilation new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1693)
    public void setAntiSpamEnableRuleCompilation(boolean zimbraAntiSpamEnableRuleCompilation) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntiSpamEnableRuleCompilation, zimbraAntiSpamEnableRuleCompilation ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * flag to enable or disable anti spam rule compilations
     *
     * @param zimbraAntiSpamEnableRuleCompilation new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1693)
    public Map<String,Object> setAntiSpamEnableRuleCompilation(boolean zimbraAntiSpamEnableRuleCompilation, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntiSpamEnableRuleCompilation, zimbraAntiSpamEnableRuleCompilation ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * flag to enable or disable anti spam rule compilations
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1693)
    public void unsetAntiSpamEnableRuleCompilation() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntiSpamEnableRuleCompilation, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * flag to enable or disable anti spam rule compilations
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1693)
    public Map<String,Object> unsetAntiSpamEnableRuleCompilation(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntiSpamEnableRuleCompilation, "");
        return attrs;
    }

    /**
     * flag to enable or disable anti spam rule updates
     *
     * @return zimbraAntiSpamEnableRuleUpdates, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1692)
    public boolean isAntiSpamEnableRuleUpdates() {
        return getBooleanAttr(Provisioning.A_zimbraAntiSpamEnableRuleUpdates, false);
    }

    /**
     * flag to enable or disable anti spam rule updates
     *
     * @param zimbraAntiSpamEnableRuleUpdates new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1692)
    public void setAntiSpamEnableRuleUpdates(boolean zimbraAntiSpamEnableRuleUpdates) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntiSpamEnableRuleUpdates, zimbraAntiSpamEnableRuleUpdates ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * flag to enable or disable anti spam rule updates
     *
     * @param zimbraAntiSpamEnableRuleUpdates new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1692)
    public Map<String,Object> setAntiSpamEnableRuleUpdates(boolean zimbraAntiSpamEnableRuleUpdates, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntiSpamEnableRuleUpdates, zimbraAntiSpamEnableRuleUpdates ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * flag to enable or disable anti spam rule updates
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1692)
    public void unsetAntiSpamEnableRuleUpdates() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntiSpamEnableRuleUpdates, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * flag to enable or disable anti spam rule updates
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1692)
    public Map<String,Object> unsetAntiSpamEnableRuleUpdates(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntiSpamEnableRuleUpdates, "");
        return attrs;
    }

    /**
     * delay between each batch for zmspamextract
     *
     * @return zimbraAntispamExtractionBatchDelay, or -1 if unset
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1457)
    public int getAntispamExtractionBatchDelay() {
        return getIntAttr(Provisioning.A_zimbraAntispamExtractionBatchDelay, -1);
    }

    /**
     * delay between each batch for zmspamextract
     *
     * @param zimbraAntispamExtractionBatchDelay new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1457)
    public void setAntispamExtractionBatchDelay(int zimbraAntispamExtractionBatchDelay) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntispamExtractionBatchDelay, Integer.toString(zimbraAntispamExtractionBatchDelay));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * delay between each batch for zmspamextract
     *
     * @param zimbraAntispamExtractionBatchDelay new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1457)
    public Map<String,Object> setAntispamExtractionBatchDelay(int zimbraAntispamExtractionBatchDelay, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntispamExtractionBatchDelay, Integer.toString(zimbraAntispamExtractionBatchDelay));
        return attrs;
    }

    /**
     * delay between each batch for zmspamextract
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1457)
    public void unsetAntispamExtractionBatchDelay() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntispamExtractionBatchDelay, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * delay between each batch for zmspamextract
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1457)
    public Map<String,Object> unsetAntispamExtractionBatchDelay(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntispamExtractionBatchDelay, "");
        return attrs;
    }

    /**
     * batch size for zmspamextract
     *
     * @return zimbraAntispamExtractionBatchSize, or -1 if unset
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1456)
    public int getAntispamExtractionBatchSize() {
        return getIntAttr(Provisioning.A_zimbraAntispamExtractionBatchSize, -1);
    }

    /**
     * batch size for zmspamextract
     *
     * @param zimbraAntispamExtractionBatchSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1456)
    public void setAntispamExtractionBatchSize(int zimbraAntispamExtractionBatchSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntispamExtractionBatchSize, Integer.toString(zimbraAntispamExtractionBatchSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * batch size for zmspamextract
     *
     * @param zimbraAntispamExtractionBatchSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1456)
    public Map<String,Object> setAntispamExtractionBatchSize(int zimbraAntispamExtractionBatchSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntispamExtractionBatchSize, Integer.toString(zimbraAntispamExtractionBatchSize));
        return attrs;
    }

    /**
     * batch size for zmspamextract
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1456)
    public void unsetAntispamExtractionBatchSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntispamExtractionBatchSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * batch size for zmspamextract
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1456)
    public Map<String,Object> unsetAntispamExtractionBatchSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntispamExtractionBatchSize, "");
        return attrs;
    }

    /**
     * Data for class that scans attachments during compose
     *
     * @return zimbraAttachmentsScanURL, or empty array if unset
     */
    @ZAttr(id=239)
    public String[] getAttachmentsScanURL() {
        return getMultiAttr(Provisioning.A_zimbraAttachmentsScanURL);
    }

    /**
     * Data for class that scans attachments during compose
     *
     * @param zimbraAttachmentsScanURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=239)
    public void setAttachmentsScanURL(String[] zimbraAttachmentsScanURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsScanURL, zimbraAttachmentsScanURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Data for class that scans attachments during compose
     *
     * @param zimbraAttachmentsScanURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=239)
    public Map<String,Object> setAttachmentsScanURL(String[] zimbraAttachmentsScanURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsScanURL, zimbraAttachmentsScanURL);
        return attrs;
    }

    /**
     * Data for class that scans attachments during compose
     *
     * @param zimbraAttachmentsScanURL new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=239)
    public void addAttachmentsScanURL(String zimbraAttachmentsScanURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAttachmentsScanURL, zimbraAttachmentsScanURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Data for class that scans attachments during compose
     *
     * @param zimbraAttachmentsScanURL new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=239)
    public Map<String,Object> addAttachmentsScanURL(String zimbraAttachmentsScanURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAttachmentsScanURL, zimbraAttachmentsScanURL);
        return attrs;
    }

    /**
     * Data for class that scans attachments during compose
     *
     * @param zimbraAttachmentsScanURL existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=239)
    public void removeAttachmentsScanURL(String zimbraAttachmentsScanURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAttachmentsScanURL, zimbraAttachmentsScanURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Data for class that scans attachments during compose
     *
     * @param zimbraAttachmentsScanURL existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=239)
    public Map<String,Object> removeAttachmentsScanURL(String zimbraAttachmentsScanURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAttachmentsScanURL, zimbraAttachmentsScanURL);
        return attrs;
    }

    /**
     * Data for class that scans attachments during compose
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=239)
    public void unsetAttachmentsScanURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsScanURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Data for class that scans attachments during compose
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=239)
    public Map<String,Object> unsetAttachmentsScanURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsScanURL, "");
        return attrs;
    }

    /**
     * Queue size for the deregistered auth tokens
     *
     * @return zimbraAuthDeregisteredAuthTokenQueueSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1841)
    public int getAuthDeregisteredAuthTokenQueueSize() {
        return getIntAttr(Provisioning.A_zimbraAuthDeregisteredAuthTokenQueueSize, -1);
    }

    /**
     * Queue size for the deregistered auth tokens
     *
     * @param zimbraAuthDeregisteredAuthTokenQueueSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1841)
    public void setAuthDeregisteredAuthTokenQueueSize(int zimbraAuthDeregisteredAuthTokenQueueSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthDeregisteredAuthTokenQueueSize, Integer.toString(zimbraAuthDeregisteredAuthTokenQueueSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Queue size for the deregistered auth tokens
     *
     * @param zimbraAuthDeregisteredAuthTokenQueueSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1841)
    public Map<String,Object> setAuthDeregisteredAuthTokenQueueSize(int zimbraAuthDeregisteredAuthTokenQueueSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthDeregisteredAuthTokenQueueSize, Integer.toString(zimbraAuthDeregisteredAuthTokenQueueSize));
        return attrs;
    }

    /**
     * Queue size for the deregistered auth tokens
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1841)
    public void unsetAuthDeregisteredAuthTokenQueueSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthDeregisteredAuthTokenQueueSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Queue size for the deregistered auth tokens
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1841)
    public Map<String,Object> unsetAuthDeregisteredAuthTokenQueueSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthDeregisteredAuthTokenQueueSize, "");
        return attrs;
    }

    /**
     * An ordered comma-seperated list of auth providers
     *
     * @return zimbraAuthProvider, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1887)
    public String getAuthProvider() {
        return getAttr(Provisioning.A_zimbraAuthProvider, null);
    }

    /**
     * An ordered comma-seperated list of auth providers
     *
     * @param zimbraAuthProvider new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1887)
    public void setAuthProvider(String zimbraAuthProvider) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthProvider, zimbraAuthProvider);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * An ordered comma-seperated list of auth providers
     *
     * @param zimbraAuthProvider new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1887)
    public Map<String,Object> setAuthProvider(String zimbraAuthProvider, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthProvider, zimbraAuthProvider);
        return attrs;
    }

    /**
     * An ordered comma-seperated list of auth providers
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1887)
    public void unsetAuthProvider() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthProvider, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * An ordered comma-seperated list of auth providers
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1887)
    public Map<String,Object> unsetAuthProvider(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthProvider, "");
        return attrs;
    }

    /**
     * This attribute is used to configure the interval with which servers
     * will send a list of invalidated tokens to each other. When an account
     * logs out of a server, the account&#039;s authtoken is added to a queue
     * of invalidated tokens on the server. Each server will send it&#039;s
     * queue of invalidated tokens to all other servers with frequency
     * configurable by this attribute. See zimbraLogOutFromAllServers for
     * more info on configuring authtoken invalidation on Accounts and
     * Classes of Service. Set to higher value to reduce network chatter. Set
     * to lower value to decrease the window during which a stolen cookie may
     * be reused to access an account.
     *
     * @return zimbraAuthTokenNotificationInterval, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1635)
    public int getAuthTokenNotificationInterval() {
        return getIntAttr(Provisioning.A_zimbraAuthTokenNotificationInterval, -1);
    }

    /**
     * This attribute is used to configure the interval with which servers
     * will send a list of invalidated tokens to each other. When an account
     * logs out of a server, the account&#039;s authtoken is added to a queue
     * of invalidated tokens on the server. Each server will send it&#039;s
     * queue of invalidated tokens to all other servers with frequency
     * configurable by this attribute. See zimbraLogOutFromAllServers for
     * more info on configuring authtoken invalidation on Accounts and
     * Classes of Service. Set to higher value to reduce network chatter. Set
     * to lower value to decrease the window during which a stolen cookie may
     * be reused to access an account.
     *
     * @param zimbraAuthTokenNotificationInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1635)
    public void setAuthTokenNotificationInterval(int zimbraAuthTokenNotificationInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenNotificationInterval, Integer.toString(zimbraAuthTokenNotificationInterval));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used to configure the interval with which servers
     * will send a list of invalidated tokens to each other. When an account
     * logs out of a server, the account&#039;s authtoken is added to a queue
     * of invalidated tokens on the server. Each server will send it&#039;s
     * queue of invalidated tokens to all other servers with frequency
     * configurable by this attribute. See zimbraLogOutFromAllServers for
     * more info on configuring authtoken invalidation on Accounts and
     * Classes of Service. Set to higher value to reduce network chatter. Set
     * to lower value to decrease the window during which a stolen cookie may
     * be reused to access an account.
     *
     * @param zimbraAuthTokenNotificationInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1635)
    public Map<String,Object> setAuthTokenNotificationInterval(int zimbraAuthTokenNotificationInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenNotificationInterval, Integer.toString(zimbraAuthTokenNotificationInterval));
        return attrs;
    }

    /**
     * This attribute is used to configure the interval with which servers
     * will send a list of invalidated tokens to each other. When an account
     * logs out of a server, the account&#039;s authtoken is added to a queue
     * of invalidated tokens on the server. Each server will send it&#039;s
     * queue of invalidated tokens to all other servers with frequency
     * configurable by this attribute. See zimbraLogOutFromAllServers for
     * more info on configuring authtoken invalidation on Accounts and
     * Classes of Service. Set to higher value to reduce network chatter. Set
     * to lower value to decrease the window during which a stolen cookie may
     * be reused to access an account.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1635)
    public void unsetAuthTokenNotificationInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenNotificationInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used to configure the interval with which servers
     * will send a list of invalidated tokens to each other. When an account
     * logs out of a server, the account&#039;s authtoken is added to a queue
     * of invalidated tokens on the server. Each server will send it&#039;s
     * queue of invalidated tokens to all other servers with frequency
     * configurable by this attribute. See zimbraLogOutFromAllServers for
     * more info on configuring authtoken invalidation on Accounts and
     * Classes of Service. Set to higher value to reduce network chatter. Set
     * to lower value to decrease the window during which a stolen cookie may
     * be reused to access an account.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1635)
    public Map<String,Object> unsetAuthTokenNotificationInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenNotificationInterval, "");
        return attrs;
    }

    /**
     * Initial sleep for the auto provision thread in millis
     *
     * @return zimbraAutoProvInitialSleep, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1757)
    public int getAutoProvInitialSleep() {
        return getIntAttr(Provisioning.A_zimbraAutoProvInitialSleep, -1);
    }

    /**
     * Initial sleep for the auto provision thread in millis
     *
     * @param zimbraAutoProvInitialSleep new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1757)
    public void setAutoProvInitialSleep(int zimbraAutoProvInitialSleep) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvInitialSleep, Integer.toString(zimbraAutoProvInitialSleep));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Initial sleep for the auto provision thread in millis
     *
     * @param zimbraAutoProvInitialSleep new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1757)
    public Map<String,Object> setAutoProvInitialSleep(int zimbraAutoProvInitialSleep, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvInitialSleep, Integer.toString(zimbraAutoProvInitialSleep));
        return attrs;
    }

    /**
     * Initial sleep for the auto provision thread in millis
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1757)
    public void unsetAutoProvInitialSleep() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvInitialSleep, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Initial sleep for the auto provision thread in millis
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1757)
    public Map<String,Object> unsetAutoProvInitialSleep(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvInitialSleep, "");
        return attrs;
    }

    /**
     * EAGER mode: required LAZY mode: N/A MANUAL mode: N/A Interval between
     * successive polling and provisioning accounts in EAGER mode. The actual
     * interval may take longer since it can be affected by two other
     * factors: zimbraAutoProvBatchSize and number of domains configured in
     * zimbraAutoProvScheduledDomains. At each interval, the auto provision
     * thread iterates through all domains in zimbraAutoProvScheduledDomains
     * and auto creates up to domain.zimbraAutoProvBatchSize accounts. If
     * that process takes longer than zimbraAutoProvPollingInterval then the
     * next iteration will start immediately instead of waiting for
     * zimbraAutoProvPollingInterval amount of time. If set to 0 when server
     * starts up, the auto provision thread will not start. If changed from a
     * non-0 value to 0 while server is running, the auto provision thread
     * will be shutdown. If changed from 0 to a non-0 value while server is
     * running, the auto provision thread will be started. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getAutoProvPollingIntervalAsString to access value as a string.
     *
     * @see #getAutoProvPollingIntervalAsString()
     *
     * @return zimbraAutoProvPollingInterval in millseconds, or -1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1238)
    public long getAutoProvPollingInterval() {
        return getTimeInterval(Provisioning.A_zimbraAutoProvPollingInterval, -1L);
    }

    /**
     * EAGER mode: required LAZY mode: N/A MANUAL mode: N/A Interval between
     * successive polling and provisioning accounts in EAGER mode. The actual
     * interval may take longer since it can be affected by two other
     * factors: zimbraAutoProvBatchSize and number of domains configured in
     * zimbraAutoProvScheduledDomains. At each interval, the auto provision
     * thread iterates through all domains in zimbraAutoProvScheduledDomains
     * and auto creates up to domain.zimbraAutoProvBatchSize accounts. If
     * that process takes longer than zimbraAutoProvPollingInterval then the
     * next iteration will start immediately instead of waiting for
     * zimbraAutoProvPollingInterval amount of time. If set to 0 when server
     * starts up, the auto provision thread will not start. If changed from a
     * non-0 value to 0 while server is running, the auto provision thread
     * will be shutdown. If changed from 0 to a non-0 value while server is
     * running, the auto provision thread will be started. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraAutoProvPollingInterval, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1238)
    public String getAutoProvPollingIntervalAsString() {
        return getAttr(Provisioning.A_zimbraAutoProvPollingInterval, null);
    }

    /**
     * EAGER mode: required LAZY mode: N/A MANUAL mode: N/A Interval between
     * successive polling and provisioning accounts in EAGER mode. The actual
     * interval may take longer since it can be affected by two other
     * factors: zimbraAutoProvBatchSize and number of domains configured in
     * zimbraAutoProvScheduledDomains. At each interval, the auto provision
     * thread iterates through all domains in zimbraAutoProvScheduledDomains
     * and auto creates up to domain.zimbraAutoProvBatchSize accounts. If
     * that process takes longer than zimbraAutoProvPollingInterval then the
     * next iteration will start immediately instead of waiting for
     * zimbraAutoProvPollingInterval amount of time. If set to 0 when server
     * starts up, the auto provision thread will not start. If changed from a
     * non-0 value to 0 while server is running, the auto provision thread
     * will be shutdown. If changed from 0 to a non-0 value while server is
     * running, the auto provision thread will be started. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraAutoProvPollingInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1238)
    public void setAutoProvPollingInterval(String zimbraAutoProvPollingInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvPollingInterval, zimbraAutoProvPollingInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * EAGER mode: required LAZY mode: N/A MANUAL mode: N/A Interval between
     * successive polling and provisioning accounts in EAGER mode. The actual
     * interval may take longer since it can be affected by two other
     * factors: zimbraAutoProvBatchSize and number of domains configured in
     * zimbraAutoProvScheduledDomains. At each interval, the auto provision
     * thread iterates through all domains in zimbraAutoProvScheduledDomains
     * and auto creates up to domain.zimbraAutoProvBatchSize accounts. If
     * that process takes longer than zimbraAutoProvPollingInterval then the
     * next iteration will start immediately instead of waiting for
     * zimbraAutoProvPollingInterval amount of time. If set to 0 when server
     * starts up, the auto provision thread will not start. If changed from a
     * non-0 value to 0 while server is running, the auto provision thread
     * will be shutdown. If changed from 0 to a non-0 value while server is
     * running, the auto provision thread will be started. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraAutoProvPollingInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1238)
    public Map<String,Object> setAutoProvPollingInterval(String zimbraAutoProvPollingInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvPollingInterval, zimbraAutoProvPollingInterval);
        return attrs;
    }

    /**
     * EAGER mode: required LAZY mode: N/A MANUAL mode: N/A Interval between
     * successive polling and provisioning accounts in EAGER mode. The actual
     * interval may take longer since it can be affected by two other
     * factors: zimbraAutoProvBatchSize and number of domains configured in
     * zimbraAutoProvScheduledDomains. At each interval, the auto provision
     * thread iterates through all domains in zimbraAutoProvScheduledDomains
     * and auto creates up to domain.zimbraAutoProvBatchSize accounts. If
     * that process takes longer than zimbraAutoProvPollingInterval then the
     * next iteration will start immediately instead of waiting for
     * zimbraAutoProvPollingInterval amount of time. If set to 0 when server
     * starts up, the auto provision thread will not start. If changed from a
     * non-0 value to 0 while server is running, the auto provision thread
     * will be shutdown. If changed from 0 to a non-0 value while server is
     * running, the auto provision thread will be started. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1238)
    public void unsetAutoProvPollingInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvPollingInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * EAGER mode: required LAZY mode: N/A MANUAL mode: N/A Interval between
     * successive polling and provisioning accounts in EAGER mode. The actual
     * interval may take longer since it can be affected by two other
     * factors: zimbraAutoProvBatchSize and number of domains configured in
     * zimbraAutoProvScheduledDomains. At each interval, the auto provision
     * thread iterates through all domains in zimbraAutoProvScheduledDomains
     * and auto creates up to domain.zimbraAutoProvBatchSize accounts. If
     * that process takes longer than zimbraAutoProvPollingInterval then the
     * next iteration will start immediately instead of waiting for
     * zimbraAutoProvPollingInterval amount of time. If set to 0 when server
     * starts up, the auto provision thread will not start. If changed from a
     * non-0 value to 0 while server is running, the auto provision thread
     * will be shutdown. If changed from 0 to a non-0 value while server is
     * running, the auto provision thread will be started. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1238)
    public Map<String,Object> unsetAutoProvPollingInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvPollingInterval, "");
        return attrs;
    }

    /**
     * length of each interval in auto-grouped backup
     *
     * @return zimbraBackupAutoGroupedInterval, or null if unset
     */
    @ZAttr(id=513)
    public String getBackupAutoGroupedInterval() {
        return getAttr(Provisioning.A_zimbraBackupAutoGroupedInterval, null);
    }

    /**
     * length of each interval in auto-grouped backup
     *
     * @param zimbraBackupAutoGroupedInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=513)
    public void setBackupAutoGroupedInterval(String zimbraBackupAutoGroupedInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedInterval, zimbraBackupAutoGroupedInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * length of each interval in auto-grouped backup
     *
     * @param zimbraBackupAutoGroupedInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=513)
    public Map<String,Object> setBackupAutoGroupedInterval(String zimbraBackupAutoGroupedInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedInterval, zimbraBackupAutoGroupedInterval);
        return attrs;
    }

    /**
     * length of each interval in auto-grouped backup
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=513)
    public void unsetBackupAutoGroupedInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * length of each interval in auto-grouped backup
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=513)
    public Map<String,Object> unsetBackupAutoGroupedInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedInterval, "");
        return attrs;
    }

    /**
     * number of groups to auto-group backups over
     *
     * @return zimbraBackupAutoGroupedNumGroups, or -1 if unset
     */
    @ZAttr(id=514)
    public int getBackupAutoGroupedNumGroups() {
        return getIntAttr(Provisioning.A_zimbraBackupAutoGroupedNumGroups, -1);
    }

    /**
     * number of groups to auto-group backups over
     *
     * @param zimbraBackupAutoGroupedNumGroups new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=514)
    public void setBackupAutoGroupedNumGroups(int zimbraBackupAutoGroupedNumGroups) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedNumGroups, Integer.toString(zimbraBackupAutoGroupedNumGroups));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of groups to auto-group backups over
     *
     * @param zimbraBackupAutoGroupedNumGroups new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=514)
    public Map<String,Object> setBackupAutoGroupedNumGroups(int zimbraBackupAutoGroupedNumGroups, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedNumGroups, Integer.toString(zimbraBackupAutoGroupedNumGroups));
        return attrs;
    }

    /**
     * number of groups to auto-group backups over
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=514)
    public void unsetBackupAutoGroupedNumGroups() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedNumGroups, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of groups to auto-group backups over
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=514)
    public Map<String,Object> unsetBackupAutoGroupedNumGroups(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedNumGroups, "");
        return attrs;
    }

    /**
     * if true, limit the number of mailboxes in auto-grouped backup to total
     * mailboxes divided by auto-group days
     *
     * @return zimbraBackupAutoGroupedThrottled, or false if unset
     */
    @ZAttr(id=515)
    public boolean isBackupAutoGroupedThrottled() {
        return getBooleanAttr(Provisioning.A_zimbraBackupAutoGroupedThrottled, false);
    }

    /**
     * if true, limit the number of mailboxes in auto-grouped backup to total
     * mailboxes divided by auto-group days
     *
     * @param zimbraBackupAutoGroupedThrottled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=515)
    public void setBackupAutoGroupedThrottled(boolean zimbraBackupAutoGroupedThrottled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedThrottled, zimbraBackupAutoGroupedThrottled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, limit the number of mailboxes in auto-grouped backup to total
     * mailboxes divided by auto-group days
     *
     * @param zimbraBackupAutoGroupedThrottled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=515)
    public Map<String,Object> setBackupAutoGroupedThrottled(boolean zimbraBackupAutoGroupedThrottled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedThrottled, zimbraBackupAutoGroupedThrottled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * if true, limit the number of mailboxes in auto-grouped backup to total
     * mailboxes divided by auto-group days
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=515)
    public void unsetBackupAutoGroupedThrottled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedThrottled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, limit the number of mailboxes in auto-grouped backup to total
     * mailboxes divided by auto-group days
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=515)
    public Map<String,Object> unsetBackupAutoGroupedThrottled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedThrottled, "");
        return attrs;
    }

    /**
     * Minimum percentage or TB/GB/MB/KB/bytes of free space on backup target
     * to allow a full or auto-grouped backup to start; 0 = no minimum is
     * enforced. Examples: 25%, 10GB
     *
     * @return zimbraBackupMinFreeSpace, or null if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1111)
    public String getBackupMinFreeSpace() {
        return getAttr(Provisioning.A_zimbraBackupMinFreeSpace, null);
    }

    /**
     * Minimum percentage or TB/GB/MB/KB/bytes of free space on backup target
     * to allow a full or auto-grouped backup to start; 0 = no minimum is
     * enforced. Examples: 25%, 10GB
     *
     * @param zimbraBackupMinFreeSpace new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1111)
    public void setBackupMinFreeSpace(String zimbraBackupMinFreeSpace) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMinFreeSpace, zimbraBackupMinFreeSpace);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum percentage or TB/GB/MB/KB/bytes of free space on backup target
     * to allow a full or auto-grouped backup to start; 0 = no minimum is
     * enforced. Examples: 25%, 10GB
     *
     * @param zimbraBackupMinFreeSpace new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1111)
    public Map<String,Object> setBackupMinFreeSpace(String zimbraBackupMinFreeSpace, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMinFreeSpace, zimbraBackupMinFreeSpace);
        return attrs;
    }

    /**
     * Minimum percentage or TB/GB/MB/KB/bytes of free space on backup target
     * to allow a full or auto-grouped backup to start; 0 = no minimum is
     * enforced. Examples: 25%, 10GB
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1111)
    public void unsetBackupMinFreeSpace() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMinFreeSpace, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum percentage or TB/GB/MB/KB/bytes of free space on backup target
     * to allow a full or auto-grouped backup to start; 0 = no minimum is
     * enforced. Examples: 25%, 10GB
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1111)
    public Map<String,Object> unsetBackupMinFreeSpace(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMinFreeSpace, "");
        return attrs;
    }

    /**
     * backup mode
     *
     * <p>Valid values: [Standard, Auto-Grouped]
     *
     * @return zimbraBackupMode, or null if unset and/or has invalid value
     */
    @ZAttr(id=512)
    public ZAttrProvisioning.BackupMode getBackupMode() {
        try { String v = getAttr(Provisioning.A_zimbraBackupMode); return v == null ? null : ZAttrProvisioning.BackupMode.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * backup mode
     *
     * <p>Valid values: [Standard, Auto-Grouped]
     *
     * @return zimbraBackupMode, or null if unset
     */
    @ZAttr(id=512)
    public String getBackupModeAsString() {
        return getAttr(Provisioning.A_zimbraBackupMode, null);
    }

    /**
     * backup mode
     *
     * <p>Valid values: [Standard, Auto-Grouped]
     *
     * @param zimbraBackupMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=512)
    public void setBackupMode(ZAttrProvisioning.BackupMode zimbraBackupMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMode, zimbraBackupMode.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * backup mode
     *
     * <p>Valid values: [Standard, Auto-Grouped]
     *
     * @param zimbraBackupMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=512)
    public Map<String,Object> setBackupMode(ZAttrProvisioning.BackupMode zimbraBackupMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMode, zimbraBackupMode.toString());
        return attrs;
    }

    /**
     * backup mode
     *
     * <p>Valid values: [Standard, Auto-Grouped]
     *
     * @param zimbraBackupMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=512)
    public void setBackupModeAsString(String zimbraBackupMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMode, zimbraBackupMode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * backup mode
     *
     * <p>Valid values: [Standard, Auto-Grouped]
     *
     * @param zimbraBackupMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=512)
    public Map<String,Object> setBackupModeAsString(String zimbraBackupMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMode, zimbraBackupMode);
        return attrs;
    }

    /**
     * backup mode
     *
     * <p>Valid values: [Standard, Auto-Grouped]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=512)
    public void unsetBackupMode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * backup mode
     *
     * <p>Valid values: [Standard, Auto-Grouped]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=512)
    public Map<String,Object> unsetBackupMode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMode, "");
        return attrs;
    }

    /**
     * Backup report email recipients
     *
     * @return zimbraBackupReportEmailRecipients, or empty array if unset
     */
    @ZAttr(id=459)
    public String[] getBackupReportEmailRecipients() {
        return getMultiAttr(Provisioning.A_zimbraBackupReportEmailRecipients);
    }

    /**
     * Backup report email recipients
     *
     * @param zimbraBackupReportEmailRecipients new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=459)
    public void setBackupReportEmailRecipients(String[] zimbraBackupReportEmailRecipients) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailRecipients, zimbraBackupReportEmailRecipients);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Backup report email recipients
     *
     * @param zimbraBackupReportEmailRecipients new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=459)
    public Map<String,Object> setBackupReportEmailRecipients(String[] zimbraBackupReportEmailRecipients, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailRecipients, zimbraBackupReportEmailRecipients);
        return attrs;
    }

    /**
     * Backup report email recipients
     *
     * @param zimbraBackupReportEmailRecipients new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=459)
    public void addBackupReportEmailRecipients(String zimbraBackupReportEmailRecipients) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraBackupReportEmailRecipients, zimbraBackupReportEmailRecipients);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Backup report email recipients
     *
     * @param zimbraBackupReportEmailRecipients new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=459)
    public Map<String,Object> addBackupReportEmailRecipients(String zimbraBackupReportEmailRecipients, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraBackupReportEmailRecipients, zimbraBackupReportEmailRecipients);
        return attrs;
    }

    /**
     * Backup report email recipients
     *
     * @param zimbraBackupReportEmailRecipients existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=459)
    public void removeBackupReportEmailRecipients(String zimbraBackupReportEmailRecipients) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraBackupReportEmailRecipients, zimbraBackupReportEmailRecipients);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Backup report email recipients
     *
     * @param zimbraBackupReportEmailRecipients existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=459)
    public Map<String,Object> removeBackupReportEmailRecipients(String zimbraBackupReportEmailRecipients, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraBackupReportEmailRecipients, zimbraBackupReportEmailRecipients);
        return attrs;
    }

    /**
     * Backup report email recipients
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=459)
    public void unsetBackupReportEmailRecipients() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailRecipients, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Backup report email recipients
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=459)
    public Map<String,Object> unsetBackupReportEmailRecipients(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailRecipients, "");
        return attrs;
    }

    /**
     * Backup report email From address
     *
     * @return zimbraBackupReportEmailSender, or null if unset
     */
    @ZAttr(id=460)
    public String getBackupReportEmailSender() {
        return getAttr(Provisioning.A_zimbraBackupReportEmailSender, null);
    }

    /**
     * Backup report email From address
     *
     * @param zimbraBackupReportEmailSender new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=460)
    public void setBackupReportEmailSender(String zimbraBackupReportEmailSender) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailSender, zimbraBackupReportEmailSender);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Backup report email From address
     *
     * @param zimbraBackupReportEmailSender new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=460)
    public Map<String,Object> setBackupReportEmailSender(String zimbraBackupReportEmailSender, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailSender, zimbraBackupReportEmailSender);
        return attrs;
    }

    /**
     * Backup report email From address
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=460)
    public void unsetBackupReportEmailSender() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailSender, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Backup report email From address
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=460)
    public Map<String,Object> unsetBackupReportEmailSender(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailSender, "");
        return attrs;
    }

    /**
     * Backup report email subject prefix
     *
     * @return zimbraBackupReportEmailSubjectPrefix, or null if unset
     */
    @ZAttr(id=461)
    public String getBackupReportEmailSubjectPrefix() {
        return getAttr(Provisioning.A_zimbraBackupReportEmailSubjectPrefix, null);
    }

    /**
     * Backup report email subject prefix
     *
     * @param zimbraBackupReportEmailSubjectPrefix new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=461)
    public void setBackupReportEmailSubjectPrefix(String zimbraBackupReportEmailSubjectPrefix) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailSubjectPrefix, zimbraBackupReportEmailSubjectPrefix);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Backup report email subject prefix
     *
     * @param zimbraBackupReportEmailSubjectPrefix new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=461)
    public Map<String,Object> setBackupReportEmailSubjectPrefix(String zimbraBackupReportEmailSubjectPrefix, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailSubjectPrefix, zimbraBackupReportEmailSubjectPrefix);
        return attrs;
    }

    /**
     * Backup report email subject prefix
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=461)
    public void unsetBackupReportEmailSubjectPrefix() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailSubjectPrefix, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Backup report email subject prefix
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=461)
    public Map<String,Object> unsetBackupReportEmailSubjectPrefix(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailSubjectPrefix, "");
        return attrs;
    }

    /**
     * if true, do not backup blobs (HSM or not) during a full backup
     *
     * @return zimbraBackupSkipBlobs, or false if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1004)
    public boolean isBackupSkipBlobs() {
        return getBooleanAttr(Provisioning.A_zimbraBackupSkipBlobs, false);
    }

    /**
     * if true, do not backup blobs (HSM or not) during a full backup
     *
     * @param zimbraBackupSkipBlobs new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1004)
    public void setBackupSkipBlobs(boolean zimbraBackupSkipBlobs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipBlobs, zimbraBackupSkipBlobs ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, do not backup blobs (HSM or not) during a full backup
     *
     * @param zimbraBackupSkipBlobs new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1004)
    public Map<String,Object> setBackupSkipBlobs(boolean zimbraBackupSkipBlobs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipBlobs, zimbraBackupSkipBlobs ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * if true, do not backup blobs (HSM or not) during a full backup
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1004)
    public void unsetBackupSkipBlobs() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipBlobs, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, do not backup blobs (HSM or not) during a full backup
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1004)
    public Map<String,Object> unsetBackupSkipBlobs(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipBlobs, "");
        return attrs;
    }

    /**
     * if true, do not backup blobs on secondary (HSM) volumes during a full
     * backup
     *
     * @return zimbraBackupSkipHsmBlobs, or false if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1005)
    public boolean isBackupSkipHsmBlobs() {
        return getBooleanAttr(Provisioning.A_zimbraBackupSkipHsmBlobs, false);
    }

    /**
     * if true, do not backup blobs on secondary (HSM) volumes during a full
     * backup
     *
     * @param zimbraBackupSkipHsmBlobs new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1005)
    public void setBackupSkipHsmBlobs(boolean zimbraBackupSkipHsmBlobs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipHsmBlobs, zimbraBackupSkipHsmBlobs ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, do not backup blobs on secondary (HSM) volumes during a full
     * backup
     *
     * @param zimbraBackupSkipHsmBlobs new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1005)
    public Map<String,Object> setBackupSkipHsmBlobs(boolean zimbraBackupSkipHsmBlobs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipHsmBlobs, zimbraBackupSkipHsmBlobs ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * if true, do not backup blobs on secondary (HSM) volumes during a full
     * backup
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1005)
    public void unsetBackupSkipHsmBlobs() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipHsmBlobs, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, do not backup blobs on secondary (HSM) volumes during a full
     * backup
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1005)
    public Map<String,Object> unsetBackupSkipHsmBlobs(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipHsmBlobs, "");
        return attrs;
    }

    /**
     * if true, do not backup search index during a full backup
     *
     * @return zimbraBackupSkipSearchIndex, or false if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1003)
    public boolean isBackupSkipSearchIndex() {
        return getBooleanAttr(Provisioning.A_zimbraBackupSkipSearchIndex, false);
    }

    /**
     * if true, do not backup search index during a full backup
     *
     * @param zimbraBackupSkipSearchIndex new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1003)
    public void setBackupSkipSearchIndex(boolean zimbraBackupSkipSearchIndex) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipSearchIndex, zimbraBackupSkipSearchIndex ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, do not backup search index during a full backup
     *
     * @param zimbraBackupSkipSearchIndex new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1003)
    public Map<String,Object> setBackupSkipSearchIndex(boolean zimbraBackupSkipSearchIndex, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipSearchIndex, zimbraBackupSkipSearchIndex ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * if true, do not backup search index during a full backup
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1003)
    public void unsetBackupSkipSearchIndex() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipSearchIndex, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, do not backup search index during a full backup
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1003)
    public Map<String,Object> unsetBackupSkipSearchIndex(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipSearchIndex, "");
        return attrs;
    }

    /**
     * Default backup target path
     *
     * @return zimbraBackupTarget, or null if unset
     */
    @ZAttr(id=458)
    public String getBackupTarget() {
        return getAttr(Provisioning.A_zimbraBackupTarget, null);
    }

    /**
     * Default backup target path
     *
     * @param zimbraBackupTarget new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=458)
    public void setBackupTarget(String zimbraBackupTarget) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupTarget, zimbraBackupTarget);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Default backup target path
     *
     * @param zimbraBackupTarget new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=458)
    public Map<String,Object> setBackupTarget(String zimbraBackupTarget, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupTarget, zimbraBackupTarget);
        return attrs;
    }

    /**
     * Default backup target path
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=458)
    public void unsetBackupTarget() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupTarget, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Default backup target path
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=458)
    public Map<String,Object> unsetBackupTarget(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupTarget, "");
        return attrs;
    }

    /**
     * Factory class for accessing and logging message behaviors. Must be
     * configured for zimbraFeaturePriorityInboxEnabled to work.
     *
     * @return zimbraBehaviorProviderFactory, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1654)
    public String getBehaviorProviderFactory() {
        return getAttr(Provisioning.A_zimbraBehaviorProviderFactory, null);
    }

    /**
     * Factory class for accessing and logging message behaviors. Must be
     * configured for zimbraFeaturePriorityInboxEnabled to work.
     *
     * @param zimbraBehaviorProviderFactory new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1654)
    public void setBehaviorProviderFactory(String zimbraBehaviorProviderFactory) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBehaviorProviderFactory, zimbraBehaviorProviderFactory);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Factory class for accessing and logging message behaviors. Must be
     * configured for zimbraFeaturePriorityInboxEnabled to work.
     *
     * @param zimbraBehaviorProviderFactory new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1654)
    public Map<String,Object> setBehaviorProviderFactory(String zimbraBehaviorProviderFactory, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBehaviorProviderFactory, zimbraBehaviorProviderFactory);
        return attrs;
    }

    /**
     * Factory class for accessing and logging message behaviors. Must be
     * configured for zimbraFeaturePriorityInboxEnabled to work.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1654)
    public void unsetBehaviorProviderFactory() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBehaviorProviderFactory, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Factory class for accessing and logging message behaviors. Must be
     * configured for zimbraFeaturePriorityInboxEnabled to work.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1654)
    public Map<String,Object> unsetBehaviorProviderFactory(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBehaviorProviderFactory, "");
        return attrs;
    }

    /**
     * Blob store input stream buffer size in kilobytes
     *
     * @return zimbraBlobStoreInputStreamBufferSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1895)
    public int getBlobStoreInputStreamBufferSize() {
        return getIntAttr(Provisioning.A_zimbraBlobStoreInputStreamBufferSize, -1);
    }

    /**
     * Blob store input stream buffer size in kilobytes
     *
     * @param zimbraBlobStoreInputStreamBufferSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1895)
    public void setBlobStoreInputStreamBufferSize(int zimbraBlobStoreInputStreamBufferSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBlobStoreInputStreamBufferSize, Integer.toString(zimbraBlobStoreInputStreamBufferSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Blob store input stream buffer size in kilobytes
     *
     * @param zimbraBlobStoreInputStreamBufferSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1895)
    public Map<String,Object> setBlobStoreInputStreamBufferSize(int zimbraBlobStoreInputStreamBufferSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBlobStoreInputStreamBufferSize, Integer.toString(zimbraBlobStoreInputStreamBufferSize));
        return attrs;
    }

    /**
     * Blob store input stream buffer size in kilobytes
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1895)
    public void unsetBlobStoreInputStreamBufferSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBlobStoreInputStreamBufferSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Blob store input stream buffer size in kilobytes
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1895)
    public Map<String,Object> unsetBlobStoreInputStreamBufferSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBlobStoreInputStreamBufferSize, "");
        return attrs;
    }

    /**
     * Files older than this many minutes are auto-deleted from store
     * incoming directory. Default is 8 hours. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getBlobStoreSweeperMaxAgeAsString to access value as a string.
     *
     * @see #getBlobStoreSweeperMaxAgeAsString()
     *
     * @return zimbraBlobStoreSweeperMaxAge in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1870)
    public long getBlobStoreSweeperMaxAge() {
        return getTimeInterval(Provisioning.A_zimbraBlobStoreSweeperMaxAge, -1L);
    }

    /**
     * Files older than this many minutes are auto-deleted from store
     * incoming directory. Default is 8 hours. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraBlobStoreSweeperMaxAge, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1870)
    public String getBlobStoreSweeperMaxAgeAsString() {
        return getAttr(Provisioning.A_zimbraBlobStoreSweeperMaxAge, null);
    }

    /**
     * Files older than this many minutes are auto-deleted from store
     * incoming directory. Default is 8 hours. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraBlobStoreSweeperMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1870)
    public void setBlobStoreSweeperMaxAge(String zimbraBlobStoreSweeperMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBlobStoreSweeperMaxAge, zimbraBlobStoreSweeperMaxAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Files older than this many minutes are auto-deleted from store
     * incoming directory. Default is 8 hours. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraBlobStoreSweeperMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1870)
    public Map<String,Object> setBlobStoreSweeperMaxAge(String zimbraBlobStoreSweeperMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBlobStoreSweeperMaxAge, zimbraBlobStoreSweeperMaxAge);
        return attrs;
    }

    /**
     * Files older than this many minutes are auto-deleted from store
     * incoming directory. Default is 8 hours. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1870)
    public void unsetBlobStoreSweeperMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBlobStoreSweeperMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Files older than this many minutes are auto-deleted from store
     * incoming directory. Default is 8 hours. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1870)
    public Map<String,Object> unsetBlobStoreSweeperMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBlobStoreSweeperMaxAge, "");
        return attrs;
    }

    /**
     * Minimum TTL in millis for uncompressed file cache used by File blob
     * store. Must be in valid duration format: {digits}{time-unit}. digits:
     * 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d -
     * days, ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getBlobStoreUncompressedCacheMinLifetimeAsString to access value as a string.
     *
     * @see #getBlobStoreUncompressedCacheMinLifetimeAsString()
     *
     * @return zimbraBlobStoreUncompressedCacheMinLifetime in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1890)
    public long getBlobStoreUncompressedCacheMinLifetime() {
        return getTimeInterval(Provisioning.A_zimbraBlobStoreUncompressedCacheMinLifetime, -1L);
    }

    /**
     * Minimum TTL in millis for uncompressed file cache used by File blob
     * store. Must be in valid duration format: {digits}{time-unit}. digits:
     * 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d -
     * days, ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraBlobStoreUncompressedCacheMinLifetime, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1890)
    public String getBlobStoreUncompressedCacheMinLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraBlobStoreUncompressedCacheMinLifetime, null);
    }

    /**
     * Minimum TTL in millis for uncompressed file cache used by File blob
     * store. Must be in valid duration format: {digits}{time-unit}. digits:
     * 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d -
     * days, ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraBlobStoreUncompressedCacheMinLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1890)
    public void setBlobStoreUncompressedCacheMinLifetime(String zimbraBlobStoreUncompressedCacheMinLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBlobStoreUncompressedCacheMinLifetime, zimbraBlobStoreUncompressedCacheMinLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum TTL in millis for uncompressed file cache used by File blob
     * store. Must be in valid duration format: {digits}{time-unit}. digits:
     * 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d -
     * days, ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraBlobStoreUncompressedCacheMinLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1890)
    public Map<String,Object> setBlobStoreUncompressedCacheMinLifetime(String zimbraBlobStoreUncompressedCacheMinLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBlobStoreUncompressedCacheMinLifetime, zimbraBlobStoreUncompressedCacheMinLifetime);
        return attrs;
    }

    /**
     * Minimum TTL in millis for uncompressed file cache used by File blob
     * store. Must be in valid duration format: {digits}{time-unit}. digits:
     * 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d -
     * days, ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1890)
    public void unsetBlobStoreUncompressedCacheMinLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBlobStoreUncompressedCacheMinLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum TTL in millis for uncompressed file cache used by File blob
     * store. Must be in valid duration format: {digits}{time-unit}. digits:
     * 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d -
     * days, ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1890)
    public Map<String,Object> unsetBlobStoreUncompressedCacheMinLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBlobStoreUncompressedCacheMinLifetime, "");
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Access Control module. Defaults to
     * FALSE
     *
     * @return zimbraCBPolicydAccessControlEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1469)
    public boolean isCBPolicydAccessControlEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCBPolicydAccessControlEnabled, false);
    }

    /**
     * Whether or not to enable CBPolicyd Access Control module. Defaults to
     * FALSE
     *
     * @param zimbraCBPolicydAccessControlEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1469)
    public void setCBPolicydAccessControlEnabled(boolean zimbraCBPolicydAccessControlEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAccessControlEnabled, zimbraCBPolicydAccessControlEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Access Control module. Defaults to
     * FALSE
     *
     * @param zimbraCBPolicydAccessControlEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1469)
    public Map<String,Object> setCBPolicydAccessControlEnabled(boolean zimbraCBPolicydAccessControlEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAccessControlEnabled, zimbraCBPolicydAccessControlEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Access Control module. Defaults to
     * FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1469)
    public void unsetCBPolicydAccessControlEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAccessControlEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Access Control module. Defaults to
     * FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1469)
    public Map<String,Object> unsetCBPolicydAccessControlEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAccessControlEnabled, "");
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Accounting module. Defaults to
     * FALSE
     *
     * @return zimbraCBPolicydAccountingEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1470)
    public boolean isCBPolicydAccountingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCBPolicydAccountingEnabled, false);
    }

    /**
     * Whether or not to enable CBPolicyd Accounting module. Defaults to
     * FALSE
     *
     * @param zimbraCBPolicydAccountingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1470)
    public void setCBPolicydAccountingEnabled(boolean zimbraCBPolicydAccountingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAccountingEnabled, zimbraCBPolicydAccountingEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Accounting module. Defaults to
     * FALSE
     *
     * @param zimbraCBPolicydAccountingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1470)
    public Map<String,Object> setCBPolicydAccountingEnabled(boolean zimbraCBPolicydAccountingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAccountingEnabled, zimbraCBPolicydAccountingEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Accounting module. Defaults to
     * FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1470)
    public void unsetCBPolicydAccountingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAccountingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Accounting module. Defaults to
     * FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1470)
    public Map<String,Object> unsetCBPolicydAccountingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAccountingEnabled, "");
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Amavis module. Defaults to FALSE
     *
     * @return zimbraCBPolicydAmavisEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1471)
    public boolean isCBPolicydAmavisEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCBPolicydAmavisEnabled, false);
    }

    /**
     * Whether or not to enable CBPolicyd Amavis module. Defaults to FALSE
     *
     * @param zimbraCBPolicydAmavisEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1471)
    public void setCBPolicydAmavisEnabled(boolean zimbraCBPolicydAmavisEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAmavisEnabled, zimbraCBPolicydAmavisEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Amavis module. Defaults to FALSE
     *
     * @param zimbraCBPolicydAmavisEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1471)
    public Map<String,Object> setCBPolicydAmavisEnabled(boolean zimbraCBPolicydAmavisEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAmavisEnabled, zimbraCBPolicydAmavisEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Amavis module. Defaults to FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1471)
    public void unsetCBPolicydAmavisEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAmavisEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Amavis module. Defaults to FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1471)
    public Map<String,Object> unsetCBPolicydAmavisEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAmavisEnabled, "");
        return attrs;
    }

    /**
     * Port for CBPolicyd to bind to. Defaults to 10031
     *
     * @return zimbraCBPolicydBindPort, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1561)
    public int getCBPolicydBindPort() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydBindPort, -1);
    }

    /**
     * Port for CBPolicyd to bind to. Defaults to 10031
     *
     * @param zimbraCBPolicydBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1561)
    public void setCBPolicydBindPort(int zimbraCBPolicydBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBindPort, Integer.toString(zimbraCBPolicydBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Port for CBPolicyd to bind to. Defaults to 10031
     *
     * @param zimbraCBPolicydBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1561)
    public Map<String,Object> setCBPolicydBindPort(int zimbraCBPolicydBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBindPort, Integer.toString(zimbraCBPolicydBindPort));
        return attrs;
    }

    /**
     * Port for CBPolicyd to bind to. Defaults to 10031
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1561)
    public void unsetCBPolicydBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Port for CBPolicyd to bind to. Defaults to 10031
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1561)
    public Map<String,Object> unsetCBPolicydBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBindPort, "");
        return attrs;
    }

    /**
     * Bypass fail mode. Default is tempfail
     *
     * <p>Valid values: [pass, tempfail]
     *
     * @return zimbraCBPolicydBypassMode, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1485)
    public ZAttrProvisioning.CBPolicydBypassMode getCBPolicydBypassMode() {
        try { String v = getAttr(Provisioning.A_zimbraCBPolicydBypassMode); return v == null ? null : ZAttrProvisioning.CBPolicydBypassMode.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Bypass fail mode. Default is tempfail
     *
     * <p>Valid values: [pass, tempfail]
     *
     * @return zimbraCBPolicydBypassMode, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1485)
    public String getCBPolicydBypassModeAsString() {
        return getAttr(Provisioning.A_zimbraCBPolicydBypassMode, null);
    }

    /**
     * Bypass fail mode. Default is tempfail
     *
     * <p>Valid values: [pass, tempfail]
     *
     * @param zimbraCBPolicydBypassMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1485)
    public void setCBPolicydBypassMode(ZAttrProvisioning.CBPolicydBypassMode zimbraCBPolicydBypassMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassMode, zimbraCBPolicydBypassMode.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Bypass fail mode. Default is tempfail
     *
     * <p>Valid values: [pass, tempfail]
     *
     * @param zimbraCBPolicydBypassMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1485)
    public Map<String,Object> setCBPolicydBypassMode(ZAttrProvisioning.CBPolicydBypassMode zimbraCBPolicydBypassMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassMode, zimbraCBPolicydBypassMode.toString());
        return attrs;
    }

    /**
     * Bypass fail mode. Default is tempfail
     *
     * <p>Valid values: [pass, tempfail]
     *
     * @param zimbraCBPolicydBypassMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1485)
    public void setCBPolicydBypassModeAsString(String zimbraCBPolicydBypassMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassMode, zimbraCBPolicydBypassMode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Bypass fail mode. Default is tempfail
     *
     * <p>Valid values: [pass, tempfail]
     *
     * @param zimbraCBPolicydBypassMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1485)
    public Map<String,Object> setCBPolicydBypassModeAsString(String zimbraCBPolicydBypassMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassMode, zimbraCBPolicydBypassMode);
        return attrs;
    }

    /**
     * Bypass fail mode. Default is tempfail
     *
     * <p>Valid values: [pass, tempfail]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1485)
    public void unsetCBPolicydBypassMode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassMode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Bypass fail mode. Default is tempfail
     *
     * <p>Valid values: [pass, tempfail]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1485)
    public Map<String,Object> unsetCBPolicydBypassMode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassMode, "");
        return attrs;
    }

    /**
     * Bypass timeout. Defaults to 30 seconds
     *
     * @return zimbraCBPolicydBypassTimeout, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1484)
    public int getCBPolicydBypassTimeout() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydBypassTimeout, -1);
    }

    /**
     * Bypass timeout. Defaults to 30 seconds
     *
     * @param zimbraCBPolicydBypassTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1484)
    public void setCBPolicydBypassTimeout(int zimbraCBPolicydBypassTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassTimeout, Integer.toString(zimbraCBPolicydBypassTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Bypass timeout. Defaults to 30 seconds
     *
     * @param zimbraCBPolicydBypassTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1484)
    public Map<String,Object> setCBPolicydBypassTimeout(int zimbraCBPolicydBypassTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassTimeout, Integer.toString(zimbraCBPolicydBypassTimeout));
        return attrs;
    }

    /**
     * Bypass timeout. Defaults to 30 seconds
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1484)
    public void unsetCBPolicydBypassTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Bypass timeout. Defaults to 30 seconds
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1484)
    public Map<String,Object> unsetCBPolicydBypassTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassTimeout, "");
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Check Helo module. Defaults to
     * FALSE
     *
     * @return zimbraCBPolicydCheckHeloEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1472)
    public boolean isCBPolicydCheckHeloEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCBPolicydCheckHeloEnabled, false);
    }

    /**
     * Whether or not to enable CBPolicyd Check Helo module. Defaults to
     * FALSE
     *
     * @param zimbraCBPolicydCheckHeloEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1472)
    public void setCBPolicydCheckHeloEnabled(boolean zimbraCBPolicydCheckHeloEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydCheckHeloEnabled, zimbraCBPolicydCheckHeloEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Check Helo module. Defaults to
     * FALSE
     *
     * @param zimbraCBPolicydCheckHeloEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1472)
    public Map<String,Object> setCBPolicydCheckHeloEnabled(boolean zimbraCBPolicydCheckHeloEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydCheckHeloEnabled, zimbraCBPolicydCheckHeloEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Check Helo module. Defaults to
     * FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1472)
    public void unsetCBPolicydCheckHeloEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydCheckHeloEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Check Helo module. Defaults to
     * FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1472)
    public Map<String,Object> unsetCBPolicydCheckHeloEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydCheckHeloEnabled, "");
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd CheckSPF module. Defaults to FALSE
     *
     * @return zimbraCBPolicydCheckSPFEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1473)
    public boolean isCBPolicydCheckSPFEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCBPolicydCheckSPFEnabled, false);
    }

    /**
     * Whether or not to enable CBPolicyd CheckSPF module. Defaults to FALSE
     *
     * @param zimbraCBPolicydCheckSPFEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1473)
    public void setCBPolicydCheckSPFEnabled(boolean zimbraCBPolicydCheckSPFEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydCheckSPFEnabled, zimbraCBPolicydCheckSPFEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd CheckSPF module. Defaults to FALSE
     *
     * @param zimbraCBPolicydCheckSPFEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1473)
    public Map<String,Object> setCBPolicydCheckSPFEnabled(boolean zimbraCBPolicydCheckSPFEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydCheckSPFEnabled, zimbraCBPolicydCheckSPFEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd CheckSPF module. Defaults to FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1473)
    public void unsetCBPolicydCheckSPFEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydCheckSPFEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd CheckSPF module. Defaults to FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1473)
    public Map<String,Object> unsetCBPolicydCheckSPFEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydCheckSPFEnabled, "");
        return attrs;
    }

    /**
     * Message to give when client is on blacklist. Default is Greylisting in
     * effect, sending server blacklisted
     *
     * @return zimbraCBPolicydGreylistingBlacklistMsg, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1487)
    public String getCBPolicydGreylistingBlacklistMsg() {
        return getAttr(Provisioning.A_zimbraCBPolicydGreylistingBlacklistMsg, null);
    }

    /**
     * Message to give when client is on blacklist. Default is Greylisting in
     * effect, sending server blacklisted
     *
     * @param zimbraCBPolicydGreylistingBlacklistMsg new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1487)
    public void setCBPolicydGreylistingBlacklistMsg(String zimbraCBPolicydGreylistingBlacklistMsg) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingBlacklistMsg, zimbraCBPolicydGreylistingBlacklistMsg);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Message to give when client is on blacklist. Default is Greylisting in
     * effect, sending server blacklisted
     *
     * @param zimbraCBPolicydGreylistingBlacklistMsg new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1487)
    public Map<String,Object> setCBPolicydGreylistingBlacklistMsg(String zimbraCBPolicydGreylistingBlacklistMsg, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingBlacklistMsg, zimbraCBPolicydGreylistingBlacklistMsg);
        return attrs;
    }

    /**
     * Message to give when client is on blacklist. Default is Greylisting in
     * effect, sending server blacklisted
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1487)
    public void unsetCBPolicydGreylistingBlacklistMsg() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingBlacklistMsg, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Message to give when client is on blacklist. Default is Greylisting in
     * effect, sending server blacklisted
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1487)
    public Map<String,Object> unsetCBPolicydGreylistingBlacklistMsg(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingBlacklistMsg, "");
        return attrs;
    }

    /**
     * Message to give when deferring email. Default is Greylisting in
     * effect, please come back later
     *
     * @return zimbraCBPolicydGreylistingDeferMsg, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1486)
    public String getCBPolicydGreylistingDeferMsg() {
        return getAttr(Provisioning.A_zimbraCBPolicydGreylistingDeferMsg, null);
    }

    /**
     * Message to give when deferring email. Default is Greylisting in
     * effect, please come back later
     *
     * @param zimbraCBPolicydGreylistingDeferMsg new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1486)
    public void setCBPolicydGreylistingDeferMsg(String zimbraCBPolicydGreylistingDeferMsg) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingDeferMsg, zimbraCBPolicydGreylistingDeferMsg);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Message to give when deferring email. Default is Greylisting in
     * effect, please come back later
     *
     * @param zimbraCBPolicydGreylistingDeferMsg new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1486)
    public Map<String,Object> setCBPolicydGreylistingDeferMsg(String zimbraCBPolicydGreylistingDeferMsg, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingDeferMsg, zimbraCBPolicydGreylistingDeferMsg);
        return attrs;
    }

    /**
     * Message to give when deferring email. Default is Greylisting in
     * effect, please come back later
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1486)
    public void unsetCBPolicydGreylistingDeferMsg() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingDeferMsg, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Message to give when deferring email. Default is Greylisting in
     * effect, please come back later
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1486)
    public Map<String,Object> unsetCBPolicydGreylistingDeferMsg(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingDeferMsg, "");
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Greylisting module. Defaults to
     * FALSE
     *
     * @return zimbraCBPolicydGreylistingEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1474)
    public boolean isCBPolicydGreylistingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCBPolicydGreylistingEnabled, false);
    }

    /**
     * Whether or not to enable CBPolicyd Greylisting module. Defaults to
     * FALSE
     *
     * @param zimbraCBPolicydGreylistingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1474)
    public void setCBPolicydGreylistingEnabled(boolean zimbraCBPolicydGreylistingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingEnabled, zimbraCBPolicydGreylistingEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Greylisting module. Defaults to
     * FALSE
     *
     * @param zimbraCBPolicydGreylistingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1474)
    public Map<String,Object> setCBPolicydGreylistingEnabled(boolean zimbraCBPolicydGreylistingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingEnabled, zimbraCBPolicydGreylistingEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Greylisting module. Defaults to
     * FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1474)
    public void unsetCBPolicydGreylistingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Greylisting module. Defaults to
     * FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1474)
    public Map<String,Object> unsetCBPolicydGreylistingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingEnabled, "");
        return attrs;
    }

    /**
     * Whether or not to put CBPolicyd Greylisting module in training only
     * mode. Defaults to FALSE
     *
     * @return zimbraCBPolicydGreylistingTrainingEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1475)
    public boolean isCBPolicydGreylistingTrainingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCBPolicydGreylistingTrainingEnabled, false);
    }

    /**
     * Whether or not to put CBPolicyd Greylisting module in training only
     * mode. Defaults to FALSE
     *
     * @param zimbraCBPolicydGreylistingTrainingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1475)
    public void setCBPolicydGreylistingTrainingEnabled(boolean zimbraCBPolicydGreylistingTrainingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingTrainingEnabled, zimbraCBPolicydGreylistingTrainingEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to put CBPolicyd Greylisting module in training only
     * mode. Defaults to FALSE
     *
     * @param zimbraCBPolicydGreylistingTrainingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1475)
    public Map<String,Object> setCBPolicydGreylistingTrainingEnabled(boolean zimbraCBPolicydGreylistingTrainingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingTrainingEnabled, zimbraCBPolicydGreylistingTrainingEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether or not to put CBPolicyd Greylisting module in training only
     * mode. Defaults to FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1475)
    public void unsetCBPolicydGreylistingTrainingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingTrainingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to put CBPolicyd Greylisting module in training only
     * mode. Defaults to FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1475)
    public Map<String,Object> unsetCBPolicydGreylistingTrainingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingTrainingEnabled, "");
        return attrs;
    }

    /**
     * Logging level for CBPolicyd. Defaults to 3. Valid range is 0-4
     *
     * @return zimbraCBPolicydLogLevel, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1562)
    public int getCBPolicydLogLevel() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydLogLevel, -1);
    }

    /**
     * Logging level for CBPolicyd. Defaults to 3. Valid range is 0-4
     *
     * @param zimbraCBPolicydLogLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1562)
    public void setCBPolicydLogLevel(int zimbraCBPolicydLogLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydLogLevel, Integer.toString(zimbraCBPolicydLogLevel));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Logging level for CBPolicyd. Defaults to 3. Valid range is 0-4
     *
     * @param zimbraCBPolicydLogLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1562)
    public Map<String,Object> setCBPolicydLogLevel(int zimbraCBPolicydLogLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydLogLevel, Integer.toString(zimbraCBPolicydLogLevel));
        return attrs;
    }

    /**
     * Logging level for CBPolicyd. Defaults to 3. Valid range is 0-4
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1562)
    public void unsetCBPolicydLogLevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydLogLevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Logging level for CBPolicyd. Defaults to 3. Valid range is 0-4
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1562)
    public Map<String,Object> unsetCBPolicydLogLevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydLogLevel, "");
        return attrs;
    }

    /**
     * Maximum number of requests to process per server. Defaults to 1000
     *
     * @return zimbraCBPolicydMaxRequests, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1481)
    public int getCBPolicydMaxRequests() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydMaxRequests, -1);
    }

    /**
     * Maximum number of requests to process per server. Defaults to 1000
     *
     * @param zimbraCBPolicydMaxRequests new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1481)
    public void setCBPolicydMaxRequests(int zimbraCBPolicydMaxRequests) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxRequests, Integer.toString(zimbraCBPolicydMaxRequests));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of requests to process per server. Defaults to 1000
     *
     * @param zimbraCBPolicydMaxRequests new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1481)
    public Map<String,Object> setCBPolicydMaxRequests(int zimbraCBPolicydMaxRequests, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxRequests, Integer.toString(zimbraCBPolicydMaxRequests));
        return attrs;
    }

    /**
     * Maximum number of requests to process per server. Defaults to 1000
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1481)
    public void unsetCBPolicydMaxRequests() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxRequests, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of requests to process per server. Defaults to 1000
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1481)
    public Map<String,Object> unsetCBPolicydMaxRequests(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxRequests, "");
        return attrs;
    }

    /**
     * Maximum number of servers to allow. Defaults to 25
     *
     * @return zimbraCBPolicydMaxServers, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1480)
    public int getCBPolicydMaxServers() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydMaxServers, -1);
    }

    /**
     * Maximum number of servers to allow. Defaults to 25
     *
     * @param zimbraCBPolicydMaxServers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1480)
    public void setCBPolicydMaxServers(int zimbraCBPolicydMaxServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxServers, Integer.toString(zimbraCBPolicydMaxServers));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of servers to allow. Defaults to 25
     *
     * @param zimbraCBPolicydMaxServers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1480)
    public Map<String,Object> setCBPolicydMaxServers(int zimbraCBPolicydMaxServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxServers, Integer.toString(zimbraCBPolicydMaxServers));
        return attrs;
    }

    /**
     * Maximum number of servers to allow. Defaults to 25
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1480)
    public void unsetCBPolicydMaxServers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxServers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of servers to allow. Defaults to 25
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1480)
    public Map<String,Object> unsetCBPolicydMaxServers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxServers, "");
        return attrs;
    }

    /**
     * Maximum number of spare servers to have on hand that are idle.
     * Defaults to 12
     *
     * @return zimbraCBPolicydMaxSpareServers, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1479)
    public int getCBPolicydMaxSpareServers() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydMaxSpareServers, -1);
    }

    /**
     * Maximum number of spare servers to have on hand that are idle.
     * Defaults to 12
     *
     * @param zimbraCBPolicydMaxSpareServers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1479)
    public void setCBPolicydMaxSpareServers(int zimbraCBPolicydMaxSpareServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxSpareServers, Integer.toString(zimbraCBPolicydMaxSpareServers));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of spare servers to have on hand that are idle.
     * Defaults to 12
     *
     * @param zimbraCBPolicydMaxSpareServers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1479)
    public Map<String,Object> setCBPolicydMaxSpareServers(int zimbraCBPolicydMaxSpareServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxSpareServers, Integer.toString(zimbraCBPolicydMaxSpareServers));
        return attrs;
    }

    /**
     * Maximum number of spare servers to have on hand that are idle.
     * Defaults to 12
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1479)
    public void unsetCBPolicydMaxSpareServers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxSpareServers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of spare servers to have on hand that are idle.
     * Defaults to 12
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1479)
    public Map<String,Object> unsetCBPolicydMaxSpareServers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxSpareServers, "");
        return attrs;
    }

    /**
     * Minimum number of CBPolicyd servers to have running. Defaults to 4
     *
     * @return zimbraCBPolicydMinServers, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1477)
    public int getCBPolicydMinServers() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydMinServers, -1);
    }

    /**
     * Minimum number of CBPolicyd servers to have running. Defaults to 4
     *
     * @param zimbraCBPolicydMinServers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1477)
    public void setCBPolicydMinServers(int zimbraCBPolicydMinServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMinServers, Integer.toString(zimbraCBPolicydMinServers));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum number of CBPolicyd servers to have running. Defaults to 4
     *
     * @param zimbraCBPolicydMinServers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1477)
    public Map<String,Object> setCBPolicydMinServers(int zimbraCBPolicydMinServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMinServers, Integer.toString(zimbraCBPolicydMinServers));
        return attrs;
    }

    /**
     * Minimum number of CBPolicyd servers to have running. Defaults to 4
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1477)
    public void unsetCBPolicydMinServers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMinServers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum number of CBPolicyd servers to have running. Defaults to 4
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1477)
    public Map<String,Object> unsetCBPolicydMinServers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMinServers, "");
        return attrs;
    }

    /**
     * Minimum number of spare servers to have on hand. Defaults to 4
     *
     * @return zimbraCBPolicydMinSpareServers, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1478)
    public int getCBPolicydMinSpareServers() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydMinSpareServers, -1);
    }

    /**
     * Minimum number of spare servers to have on hand. Defaults to 4
     *
     * @param zimbraCBPolicydMinSpareServers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1478)
    public void setCBPolicydMinSpareServers(int zimbraCBPolicydMinSpareServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMinSpareServers, Integer.toString(zimbraCBPolicydMinSpareServers));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum number of spare servers to have on hand. Defaults to 4
     *
     * @param zimbraCBPolicydMinSpareServers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1478)
    public Map<String,Object> setCBPolicydMinSpareServers(int zimbraCBPolicydMinSpareServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMinSpareServers, Integer.toString(zimbraCBPolicydMinSpareServers));
        return attrs;
    }

    /**
     * Minimum number of spare servers to have on hand. Defaults to 4
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1478)
    public void unsetCBPolicydMinSpareServers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMinSpareServers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum number of spare servers to have on hand. Defaults to 4
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1478)
    public Map<String,Object> unsetCBPolicydMinSpareServers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMinSpareServers, "");
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Quotas module. Defaults to TRUE
     *
     * @return zimbraCBPolicydQuotasEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1476)
    public boolean isCBPolicydQuotasEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCBPolicydQuotasEnabled, false);
    }

    /**
     * Whether or not to enable CBPolicyd Quotas module. Defaults to TRUE
     *
     * @param zimbraCBPolicydQuotasEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1476)
    public void setCBPolicydQuotasEnabled(boolean zimbraCBPolicydQuotasEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydQuotasEnabled, zimbraCBPolicydQuotasEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Quotas module. Defaults to TRUE
     *
     * @param zimbraCBPolicydQuotasEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1476)
    public Map<String,Object> setCBPolicydQuotasEnabled(boolean zimbraCBPolicydQuotasEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydQuotasEnabled, zimbraCBPolicydQuotasEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Quotas module. Defaults to TRUE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1476)
    public void unsetCBPolicydQuotasEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydQuotasEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Quotas module. Defaults to TRUE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1476)
    public Map<String,Object> unsetCBPolicydQuotasEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydQuotasEnabled, "");
        return attrs;
    }

    /**
     * Timeout when talking to clients and servers are busy. Defaults to 120
     * seconds
     *
     * @return zimbraCBPolicydTimeoutBusy, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1483)
    public int getCBPolicydTimeoutBusy() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydTimeoutBusy, -1);
    }

    /**
     * Timeout when talking to clients and servers are busy. Defaults to 120
     * seconds
     *
     * @param zimbraCBPolicydTimeoutBusy new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1483)
    public void setCBPolicydTimeoutBusy(int zimbraCBPolicydTimeoutBusy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydTimeoutBusy, Integer.toString(zimbraCBPolicydTimeoutBusy));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout when talking to clients and servers are busy. Defaults to 120
     * seconds
     *
     * @param zimbraCBPolicydTimeoutBusy new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1483)
    public Map<String,Object> setCBPolicydTimeoutBusy(int zimbraCBPolicydTimeoutBusy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydTimeoutBusy, Integer.toString(zimbraCBPolicydTimeoutBusy));
        return attrs;
    }

    /**
     * Timeout when talking to clients and servers are busy. Defaults to 120
     * seconds
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1483)
    public void unsetCBPolicydTimeoutBusy() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydTimeoutBusy, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout when talking to clients and servers are busy. Defaults to 120
     * seconds
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1483)
    public Map<String,Object> unsetCBPolicydTimeoutBusy(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydTimeoutBusy, "");
        return attrs;
    }

    /**
     * Timeout when talking to clients and servers are idle. Defaults to 1020
     * seconds
     *
     * @return zimbraCBPolicydTimeoutIdle, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1482)
    public int getCBPolicydTimeoutIdle() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydTimeoutIdle, -1);
    }

    /**
     * Timeout when talking to clients and servers are idle. Defaults to 1020
     * seconds
     *
     * @param zimbraCBPolicydTimeoutIdle new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1482)
    public void setCBPolicydTimeoutIdle(int zimbraCBPolicydTimeoutIdle) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydTimeoutIdle, Integer.toString(zimbraCBPolicydTimeoutIdle));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout when talking to clients and servers are idle. Defaults to 1020
     * seconds
     *
     * @param zimbraCBPolicydTimeoutIdle new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1482)
    public Map<String,Object> setCBPolicydTimeoutIdle(int zimbraCBPolicydTimeoutIdle, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydTimeoutIdle, Integer.toString(zimbraCBPolicydTimeoutIdle));
        return attrs;
    }

    /**
     * Timeout when talking to clients and servers are idle. Defaults to 1020
     * seconds
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1482)
    public void unsetCBPolicydTimeoutIdle() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydTimeoutIdle, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout when talking to clients and servers are idle. Defaults to 1020
     * seconds
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1482)
    public Map<String,Object> unsetCBPolicydTimeoutIdle(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydTimeoutIdle, "");
        return attrs;
    }

    /**
     * Flag to enable or disable allow calendar invite without method
     *
     * @return zimbraCalendarAllowInviteWithoutMethod, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1703)
    public boolean isCalendarAllowInviteWithoutMethod() {
        return getBooleanAttr(Provisioning.A_zimbraCalendarAllowInviteWithoutMethod, false);
    }

    /**
     * Flag to enable or disable allow calendar invite without method
     *
     * @param zimbraCalendarAllowInviteWithoutMethod new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1703)
    public void setCalendarAllowInviteWithoutMethod(boolean zimbraCalendarAllowInviteWithoutMethod) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarAllowInviteWithoutMethod, zimbraCalendarAllowInviteWithoutMethod ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable or disable allow calendar invite without method
     *
     * @param zimbraCalendarAllowInviteWithoutMethod new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1703)
    public Map<String,Object> setCalendarAllowInviteWithoutMethod(boolean zimbraCalendarAllowInviteWithoutMethod, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarAllowInviteWithoutMethod, zimbraCalendarAllowInviteWithoutMethod ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to enable or disable allow calendar invite without method
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1703)
    public void unsetCalendarAllowInviteWithoutMethod() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarAllowInviteWithoutMethod, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable or disable allow calendar invite without method
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1703)
    public Map<String,Object> unsetCalendarAllowInviteWithoutMethod(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarAllowInviteWithoutMethod, "");
        return attrs;
    }

    /**
     * Activates the hack that converts standalone VEVENT/VTODO components
     * with STATUS:CANCELLED into EXDATEs on the series component. Introduced
     * in bug 36434
     *
     * @return zimbraCalendarAppleICalCompatibleCanceledInstances, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1758)
    public boolean isCalendarAppleICalCompatibleCanceledInstances() {
        return getBooleanAttr(Provisioning.A_zimbraCalendarAppleICalCompatibleCanceledInstances, false);
    }

    /**
     * Activates the hack that converts standalone VEVENT/VTODO components
     * with STATUS:CANCELLED into EXDATEs on the series component. Introduced
     * in bug 36434
     *
     * @param zimbraCalendarAppleICalCompatibleCanceledInstances new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1758)
    public void setCalendarAppleICalCompatibleCanceledInstances(boolean zimbraCalendarAppleICalCompatibleCanceledInstances) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarAppleICalCompatibleCanceledInstances, zimbraCalendarAppleICalCompatibleCanceledInstances ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Activates the hack that converts standalone VEVENT/VTODO components
     * with STATUS:CANCELLED into EXDATEs on the series component. Introduced
     * in bug 36434
     *
     * @param zimbraCalendarAppleICalCompatibleCanceledInstances new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1758)
    public Map<String,Object> setCalendarAppleICalCompatibleCanceledInstances(boolean zimbraCalendarAppleICalCompatibleCanceledInstances, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarAppleICalCompatibleCanceledInstances, zimbraCalendarAppleICalCompatibleCanceledInstances ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Activates the hack that converts standalone VEVENT/VTODO components
     * with STATUS:CANCELLED into EXDATEs on the series component. Introduced
     * in bug 36434
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1758)
    public void unsetCalendarAppleICalCompatibleCanceledInstances() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarAppleICalCompatibleCanceledInstances, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Activates the hack that converts standalone VEVENT/VTODO components
     * with STATUS:CANCELLED into EXDATEs on the series component. Introduced
     * in bug 36434
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1758)
    public Map<String,Object> unsetCalendarAppleICalCompatibleCanceledInstances(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarAppleICalCompatibleCanceledInstances, "");
        return attrs;
    }

    /**
     * Enable calendar cache.
     *
     * @return zimbraCalendarCacheEnabled, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1694)
    public boolean isCalendarCacheEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCalendarCacheEnabled, false);
    }

    /**
     * Enable calendar cache.
     *
     * @param zimbraCalendarCacheEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1694)
    public void setCalendarCacheEnabled(boolean zimbraCalendarCacheEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCacheEnabled, zimbraCalendarCacheEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable calendar cache.
     *
     * @param zimbraCalendarCacheEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1694)
    public Map<String,Object> setCalendarCacheEnabled(boolean zimbraCalendarCacheEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCacheEnabled, zimbraCalendarCacheEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Enable calendar cache.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1694)
    public void unsetCalendarCacheEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCacheEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable calendar cache.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1694)
    public Map<String,Object> unsetCalendarCacheEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCacheEnabled, "");
        return attrs;
    }

    /**
     * Size of memory-cache LRU. Cache this many calendar folder in memory.
     *
     * @return zimbraCalendarCacheLRUSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1695)
    public int getCalendarCacheLRUSize() {
        return getIntAttr(Provisioning.A_zimbraCalendarCacheLRUSize, -1);
    }

    /**
     * Size of memory-cache LRU. Cache this many calendar folder in memory.
     *
     * @param zimbraCalendarCacheLRUSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1695)
    public void setCalendarCacheLRUSize(int zimbraCalendarCacheLRUSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCacheLRUSize, Integer.toString(zimbraCalendarCacheLRUSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Size of memory-cache LRU. Cache this many calendar folder in memory.
     *
     * @param zimbraCalendarCacheLRUSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1695)
    public Map<String,Object> setCalendarCacheLRUSize(int zimbraCalendarCacheLRUSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCacheLRUSize, Integer.toString(zimbraCalendarCacheLRUSize));
        return attrs;
    }

    /**
     * Size of memory-cache LRU. Cache this many calendar folder in memory.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1695)
    public void unsetCalendarCacheLRUSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCacheLRUSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Size of memory-cache LRU. Cache this many calendar folder in memory.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1695)
    public Map<String,Object> unsetCalendarCacheLRUSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCacheLRUSize, "");
        return attrs;
    }

    /**
     * Starting month in cached range. 0 means current month, -1 means last
     * month, etc.
     *
     * @return zimbraCalendarCacheRangeMonthFrom, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1696)
    public int getCalendarCacheRangeMonthFrom() {
        return getIntAttr(Provisioning.A_zimbraCalendarCacheRangeMonthFrom, -1);
    }

    /**
     * Starting month in cached range. 0 means current month, -1 means last
     * month, etc.
     *
     * @param zimbraCalendarCacheRangeMonthFrom new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1696)
    public void setCalendarCacheRangeMonthFrom(int zimbraCalendarCacheRangeMonthFrom) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCacheRangeMonthFrom, Integer.toString(zimbraCalendarCacheRangeMonthFrom));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Starting month in cached range. 0 means current month, -1 means last
     * month, etc.
     *
     * @param zimbraCalendarCacheRangeMonthFrom new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1696)
    public Map<String,Object> setCalendarCacheRangeMonthFrom(int zimbraCalendarCacheRangeMonthFrom, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCacheRangeMonthFrom, Integer.toString(zimbraCalendarCacheRangeMonthFrom));
        return attrs;
    }

    /**
     * Starting month in cached range. 0 means current month, -1 means last
     * month, etc.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1696)
    public void unsetCalendarCacheRangeMonthFrom() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCacheRangeMonthFrom, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Starting month in cached range. 0 means current month, -1 means last
     * month, etc.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1696)
    public Map<String,Object> unsetCalendarCacheRangeMonthFrom(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCacheRangeMonthFrom, "");
        return attrs;
    }

    /**
     * Number of months in cached range
     *
     * @return zimbraCalendarCacheRangeMonths, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1697)
    public int getCalendarCacheRangeMonths() {
        return getIntAttr(Provisioning.A_zimbraCalendarCacheRangeMonths, -1);
    }

    /**
     * Number of months in cached range
     *
     * @param zimbraCalendarCacheRangeMonths new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1697)
    public void setCalendarCacheRangeMonths(int zimbraCalendarCacheRangeMonths) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCacheRangeMonths, Integer.toString(zimbraCalendarCacheRangeMonths));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Number of months in cached range
     *
     * @param zimbraCalendarCacheRangeMonths new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1697)
    public Map<String,Object> setCalendarCacheRangeMonths(int zimbraCalendarCacheRangeMonths, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCacheRangeMonths, Integer.toString(zimbraCalendarCacheRangeMonths));
        return attrs;
    }

    /**
     * Number of months in cached range
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1697)
    public void unsetCalendarCacheRangeMonths() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCacheRangeMonths, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Number of months in cached range
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1697)
    public Map<String,Object> unsetCalendarCacheRangeMonths(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCacheRangeMonths, "");
        return attrs;
    }

    /**
     * Whether to allow password sent to non-secured port from CalDAV
     * clients. If it set to TRUE the server will allow access from CalDAV
     * client to zimbraMailPort. If it set to FALSE the server will return an
     * error if a request is made from CalDAV client to zimbraMailPort.
     *
     * @return zimbraCalendarCalDavClearTextPasswordEnabled, or false if unset
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=820)
    public boolean isCalendarCalDavClearTextPasswordEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCalendarCalDavClearTextPasswordEnabled, false);
    }

    /**
     * Whether to allow password sent to non-secured port from CalDAV
     * clients. If it set to TRUE the server will allow access from CalDAV
     * client to zimbraMailPort. If it set to FALSE the server will return an
     * error if a request is made from CalDAV client to zimbraMailPort.
     *
     * @param zimbraCalendarCalDavClearTextPasswordEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=820)
    public void setCalendarCalDavClearTextPasswordEnabled(boolean zimbraCalendarCalDavClearTextPasswordEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavClearTextPasswordEnabled, zimbraCalendarCalDavClearTextPasswordEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow password sent to non-secured port from CalDAV
     * clients. If it set to TRUE the server will allow access from CalDAV
     * client to zimbraMailPort. If it set to FALSE the server will return an
     * error if a request is made from CalDAV client to zimbraMailPort.
     *
     * @param zimbraCalendarCalDavClearTextPasswordEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=820)
    public Map<String,Object> setCalendarCalDavClearTextPasswordEnabled(boolean zimbraCalendarCalDavClearTextPasswordEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavClearTextPasswordEnabled, zimbraCalendarCalDavClearTextPasswordEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether to allow password sent to non-secured port from CalDAV
     * clients. If it set to TRUE the server will allow access from CalDAV
     * client to zimbraMailPort. If it set to FALSE the server will return an
     * error if a request is made from CalDAV client to zimbraMailPort.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=820)
    public void unsetCalendarCalDavClearTextPasswordEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavClearTextPasswordEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow password sent to non-secured port from CalDAV
     * clients. If it set to TRUE the server will allow access from CalDAV
     * client to zimbraMailPort. If it set to FALSE the server will return an
     * error if a request is made from CalDAV client to zimbraMailPort.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=820)
    public Map<String,Object> unsetCalendarCalDavClearTextPasswordEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavClearTextPasswordEnabled, "");
        return attrs;
    }

    /**
     * Id of calendar folder to advertise as the default calendar to CalDAV
     * client.
     *
     * @return zimbraCalendarCalDavDefaultCalendarId, or -1 if unset
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1078)
    public int getCalendarCalDavDefaultCalendarId() {
        return getIntAttr(Provisioning.A_zimbraCalendarCalDavDefaultCalendarId, -1);
    }

    /**
     * Id of calendar folder to advertise as the default calendar to CalDAV
     * client.
     *
     * @param zimbraCalendarCalDavDefaultCalendarId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1078)
    public void setCalendarCalDavDefaultCalendarId(int zimbraCalendarCalDavDefaultCalendarId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavDefaultCalendarId, Integer.toString(zimbraCalendarCalDavDefaultCalendarId));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Id of calendar folder to advertise as the default calendar to CalDAV
     * client.
     *
     * @param zimbraCalendarCalDavDefaultCalendarId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1078)
    public Map<String,Object> setCalendarCalDavDefaultCalendarId(int zimbraCalendarCalDavDefaultCalendarId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavDefaultCalendarId, Integer.toString(zimbraCalendarCalDavDefaultCalendarId));
        return attrs;
    }

    /**
     * Id of calendar folder to advertise as the default calendar to CalDAV
     * client.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1078)
    public void unsetCalendarCalDavDefaultCalendarId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavDefaultCalendarId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Id of calendar folder to advertise as the default calendar to CalDAV
     * client.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1078)
    public Map<String,Object> unsetCalendarCalDavDefaultCalendarId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavDefaultCalendarId, "");
        return attrs;
    }

    /**
     * Calendar exchange form auth url
     *
     * @return zimbraCalendarExchangeFormAuthURL, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1699)
    public String getCalendarExchangeFormAuthURL() {
        return getAttr(Provisioning.A_zimbraCalendarExchangeFormAuthURL, null);
    }

    /**
     * Calendar exchange form auth url
     *
     * @param zimbraCalendarExchangeFormAuthURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1699)
    public void setCalendarExchangeFormAuthURL(String zimbraCalendarExchangeFormAuthURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarExchangeFormAuthURL, zimbraCalendarExchangeFormAuthURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Calendar exchange form auth url
     *
     * @param zimbraCalendarExchangeFormAuthURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1699)
    public Map<String,Object> setCalendarExchangeFormAuthURL(String zimbraCalendarExchangeFormAuthURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarExchangeFormAuthURL, zimbraCalendarExchangeFormAuthURL);
        return attrs;
    }

    /**
     * Calendar exchange form auth url
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1699)
    public void unsetCalendarExchangeFormAuthURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarExchangeFormAuthURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Calendar exchange form auth url
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1699)
    public Map<String,Object> unsetCalendarExchangeFormAuthURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarExchangeFormAuthURL, "");
        return attrs;
    }

    /**
     * Calendar free busy max days
     *
     * @return zimbraCalendarFreeBusyMaxDays, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1705)
    public int getCalendarFreeBusyMaxDays() {
        return getIntAttr(Provisioning.A_zimbraCalendarFreeBusyMaxDays, -1);
    }

    /**
     * Calendar free busy max days
     *
     * @param zimbraCalendarFreeBusyMaxDays new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1705)
    public void setCalendarFreeBusyMaxDays(int zimbraCalendarFreeBusyMaxDays) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarFreeBusyMaxDays, Integer.toString(zimbraCalendarFreeBusyMaxDays));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Calendar free busy max days
     *
     * @param zimbraCalendarFreeBusyMaxDays new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1705)
    public Map<String,Object> setCalendarFreeBusyMaxDays(int zimbraCalendarFreeBusyMaxDays, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarFreeBusyMaxDays, Integer.toString(zimbraCalendarFreeBusyMaxDays));
        return attrs;
    }

    /**
     * Calendar free busy max days
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1705)
    public void unsetCalendarFreeBusyMaxDays() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarFreeBusyMaxDays, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Calendar free busy max days
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1705)
    public Map<String,Object> unsetCalendarFreeBusyMaxDays(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarFreeBusyMaxDays, "");
        return attrs;
    }

    /**
     * Calendar ics export buffer size in bytes
     *
     * @return zimbraCalendarIcsExportBufferSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1702)
    public int getCalendarIcsExportBufferSize() {
        return getIntAttr(Provisioning.A_zimbraCalendarIcsExportBufferSize, -1);
    }

    /**
     * Calendar ics export buffer size in bytes
     *
     * @param zimbraCalendarIcsExportBufferSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1702)
    public void setCalendarIcsExportBufferSize(int zimbraCalendarIcsExportBufferSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarIcsExportBufferSize, Integer.toString(zimbraCalendarIcsExportBufferSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Calendar ics export buffer size in bytes
     *
     * @param zimbraCalendarIcsExportBufferSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1702)
    public Map<String,Object> setCalendarIcsExportBufferSize(int zimbraCalendarIcsExportBufferSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarIcsExportBufferSize, Integer.toString(zimbraCalendarIcsExportBufferSize));
        return attrs;
    }

    /**
     * Calendar ics export buffer size in bytes
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1702)
    public void unsetCalendarIcsExportBufferSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarIcsExportBufferSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Calendar ics export buffer size in bytes
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1702)
    public Map<String,Object> unsetCalendarIcsExportBufferSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarIcsExportBufferSize, "");
        return attrs;
    }

    /**
     * During ics import use full parser if ics size is less than or equal to
     * this; larger ics files are parsed with callback parser which
     * doesn&#039;t allow forward references to VTIMEZONE TZID
     *
     * @return zimbraCalendarIcsImportFullParseMaxSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1701)
    public int getCalendarIcsImportFullParseMaxSize() {
        return getIntAttr(Provisioning.A_zimbraCalendarIcsImportFullParseMaxSize, -1);
    }

    /**
     * During ics import use full parser if ics size is less than or equal to
     * this; larger ics files are parsed with callback parser which
     * doesn&#039;t allow forward references to VTIMEZONE TZID
     *
     * @param zimbraCalendarIcsImportFullParseMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1701)
    public void setCalendarIcsImportFullParseMaxSize(int zimbraCalendarIcsImportFullParseMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarIcsImportFullParseMaxSize, Integer.toString(zimbraCalendarIcsImportFullParseMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * During ics import use full parser if ics size is less than or equal to
     * this; larger ics files are parsed with callback parser which
     * doesn&#039;t allow forward references to VTIMEZONE TZID
     *
     * @param zimbraCalendarIcsImportFullParseMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1701)
    public Map<String,Object> setCalendarIcsImportFullParseMaxSize(int zimbraCalendarIcsImportFullParseMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarIcsImportFullParseMaxSize, Integer.toString(zimbraCalendarIcsImportFullParseMaxSize));
        return attrs;
    }

    /**
     * During ics import use full parser if ics size is less than or equal to
     * this; larger ics files are parsed with callback parser which
     * doesn&#039;t allow forward references to VTIMEZONE TZID
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1701)
    public void unsetCalendarIcsImportFullParseMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarIcsImportFullParseMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * During ics import use full parser if ics size is less than or equal to
     * this; larger ics files are parsed with callback parser which
     * doesn&#039;t allow forward references to VTIMEZONE TZID
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1701)
    public Map<String,Object> unsetCalendarIcsImportFullParseMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarIcsImportFullParseMaxSize, "");
        return attrs;
    }

    /**
     * Maximum retries for calender item
     *
     * @return zimbraCalendarItemGetMaxRetries, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1700)
    public int getCalendarItemGetMaxRetries() {
        return getIntAttr(Provisioning.A_zimbraCalendarItemGetMaxRetries, -1);
    }

    /**
     * Maximum retries for calender item
     *
     * @param zimbraCalendarItemGetMaxRetries new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1700)
    public void setCalendarItemGetMaxRetries(int zimbraCalendarItemGetMaxRetries) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarItemGetMaxRetries, Integer.toString(zimbraCalendarItemGetMaxRetries));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum retries for calender item
     *
     * @param zimbraCalendarItemGetMaxRetries new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1700)
    public Map<String,Object> setCalendarItemGetMaxRetries(int zimbraCalendarItemGetMaxRetries, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarItemGetMaxRetries, Integer.toString(zimbraCalendarItemGetMaxRetries));
        return attrs;
    }

    /**
     * Maximum retries for calender item
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1700)
    public void unsetCalendarItemGetMaxRetries() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarItemGetMaxRetries, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum retries for calender item
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1700)
    public Map<String,Object> unsetCalendarItemGetMaxRetries(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarItemGetMaxRetries, "");
        return attrs;
    }

    /**
     * Calendar maximum description in metadata in bytes
     *
     * @return zimbraCalendarMaxDescInMetadata, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1704)
    public int getCalendarMaxDescInMetadata() {
        return getIntAttr(Provisioning.A_zimbraCalendarMaxDescInMetadata, -1);
    }

    /**
     * Calendar maximum description in metadata in bytes
     *
     * @param zimbraCalendarMaxDescInMetadata new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1704)
    public void setCalendarMaxDescInMetadata(int zimbraCalendarMaxDescInMetadata) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarMaxDescInMetadata, Integer.toString(zimbraCalendarMaxDescInMetadata));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Calendar maximum description in metadata in bytes
     *
     * @param zimbraCalendarMaxDescInMetadata new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1704)
    public Map<String,Object> setCalendarMaxDescInMetadata(int zimbraCalendarMaxDescInMetadata, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarMaxDescInMetadata, Integer.toString(zimbraCalendarMaxDescInMetadata));
        return attrs;
    }

    /**
     * Calendar maximum description in metadata in bytes
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1704)
    public void unsetCalendarMaxDescInMetadata() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarMaxDescInMetadata, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Calendar maximum description in metadata in bytes
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1704)
    public Map<String,Object> unsetCalendarMaxDescInMetadata(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarMaxDescInMetadata, "");
        return attrs;
    }

    /**
     * Maximum stale items in calendar cache
     *
     * @return zimbraCalendarMaxStaleItems, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1698)
    public int getCalendarMaxStaleItems() {
        return getIntAttr(Provisioning.A_zimbraCalendarMaxStaleItems, -1);
    }

    /**
     * Maximum stale items in calendar cache
     *
     * @param zimbraCalendarMaxStaleItems new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1698)
    public void setCalendarMaxStaleItems(int zimbraCalendarMaxStaleItems) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarMaxStaleItems, Integer.toString(zimbraCalendarMaxStaleItems));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum stale items in calendar cache
     *
     * @param zimbraCalendarMaxStaleItems new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1698)
    public Map<String,Object> setCalendarMaxStaleItems(int zimbraCalendarMaxStaleItems, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarMaxStaleItems, Integer.toString(zimbraCalendarMaxStaleItems));
        return attrs;
    }

    /**
     * Maximum stale items in calendar cache
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1698)
    public void unsetCalendarMaxStaleItems() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarMaxStaleItems, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum stale items in calendar cache
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1698)
    public Map<String,Object> unsetCalendarMaxStaleItems(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarMaxStaleItems, "");
        return attrs;
    }

    /**
     * Maximum number of days a DAILY recurrence rule can span; 0 means
     * unlimited
     *
     * @return zimbraCalendarRecurrenceDailyMaxDays, or -1 if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=661)
    public int getCalendarRecurrenceDailyMaxDays() {
        return getIntAttr(Provisioning.A_zimbraCalendarRecurrenceDailyMaxDays, -1);
    }

    /**
     * Maximum number of days a DAILY recurrence rule can span; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceDailyMaxDays new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=661)
    public void setCalendarRecurrenceDailyMaxDays(int zimbraCalendarRecurrenceDailyMaxDays) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceDailyMaxDays, Integer.toString(zimbraCalendarRecurrenceDailyMaxDays));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of days a DAILY recurrence rule can span; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceDailyMaxDays new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=661)
    public Map<String,Object> setCalendarRecurrenceDailyMaxDays(int zimbraCalendarRecurrenceDailyMaxDays, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceDailyMaxDays, Integer.toString(zimbraCalendarRecurrenceDailyMaxDays));
        return attrs;
    }

    /**
     * Maximum number of days a DAILY recurrence rule can span; 0 means
     * unlimited
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=661)
    public void unsetCalendarRecurrenceDailyMaxDays() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceDailyMaxDays, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of days a DAILY recurrence rule can span; 0 means
     * unlimited
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=661)
    public Map<String,Object> unsetCalendarRecurrenceDailyMaxDays(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceDailyMaxDays, "");
        return attrs;
    }

    /**
     * Maximum number of instances expanded per recurrence rule; 0 means
     * unlimited
     *
     * @return zimbraCalendarRecurrenceMaxInstances, or -1 if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=660)
    public int getCalendarRecurrenceMaxInstances() {
        return getIntAttr(Provisioning.A_zimbraCalendarRecurrenceMaxInstances, -1);
    }

    /**
     * Maximum number of instances expanded per recurrence rule; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceMaxInstances new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=660)
    public void setCalendarRecurrenceMaxInstances(int zimbraCalendarRecurrenceMaxInstances) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceMaxInstances, Integer.toString(zimbraCalendarRecurrenceMaxInstances));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of instances expanded per recurrence rule; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceMaxInstances new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=660)
    public Map<String,Object> setCalendarRecurrenceMaxInstances(int zimbraCalendarRecurrenceMaxInstances, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceMaxInstances, Integer.toString(zimbraCalendarRecurrenceMaxInstances));
        return attrs;
    }

    /**
     * Maximum number of instances expanded per recurrence rule; 0 means
     * unlimited
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=660)
    public void unsetCalendarRecurrenceMaxInstances() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceMaxInstances, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of instances expanded per recurrence rule; 0 means
     * unlimited
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=660)
    public Map<String,Object> unsetCalendarRecurrenceMaxInstances(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceMaxInstances, "");
        return attrs;
    }

    /**
     * Maximum number of months a MONTHLY recurrence rule can span; 0 means
     * unlimited
     *
     * @return zimbraCalendarRecurrenceMonthlyMaxMonths, or -1 if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=663)
    public int getCalendarRecurrenceMonthlyMaxMonths() {
        return getIntAttr(Provisioning.A_zimbraCalendarRecurrenceMonthlyMaxMonths, -1);
    }

    /**
     * Maximum number of months a MONTHLY recurrence rule can span; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceMonthlyMaxMonths new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=663)
    public void setCalendarRecurrenceMonthlyMaxMonths(int zimbraCalendarRecurrenceMonthlyMaxMonths) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceMonthlyMaxMonths, Integer.toString(zimbraCalendarRecurrenceMonthlyMaxMonths));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of months a MONTHLY recurrence rule can span; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceMonthlyMaxMonths new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=663)
    public Map<String,Object> setCalendarRecurrenceMonthlyMaxMonths(int zimbraCalendarRecurrenceMonthlyMaxMonths, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceMonthlyMaxMonths, Integer.toString(zimbraCalendarRecurrenceMonthlyMaxMonths));
        return attrs;
    }

    /**
     * Maximum number of months a MONTHLY recurrence rule can span; 0 means
     * unlimited
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=663)
    public void unsetCalendarRecurrenceMonthlyMaxMonths() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceMonthlyMaxMonths, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of months a MONTHLY recurrence rule can span; 0 means
     * unlimited
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=663)
    public Map<String,Object> unsetCalendarRecurrenceMonthlyMaxMonths(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceMonthlyMaxMonths, "");
        return attrs;
    }

    /**
     * Maximum number of years a recurrence rule can span for frequencies
     * other than DAILY/WEEKLY/MONTHLY/YEARLY; 0 means unlimited
     *
     * @return zimbraCalendarRecurrenceOtherFrequencyMaxYears, or -1 if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=665)
    public int getCalendarRecurrenceOtherFrequencyMaxYears() {
        return getIntAttr(Provisioning.A_zimbraCalendarRecurrenceOtherFrequencyMaxYears, -1);
    }

    /**
     * Maximum number of years a recurrence rule can span for frequencies
     * other than DAILY/WEEKLY/MONTHLY/YEARLY; 0 means unlimited
     *
     * @param zimbraCalendarRecurrenceOtherFrequencyMaxYears new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=665)
    public void setCalendarRecurrenceOtherFrequencyMaxYears(int zimbraCalendarRecurrenceOtherFrequencyMaxYears) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceOtherFrequencyMaxYears, Integer.toString(zimbraCalendarRecurrenceOtherFrequencyMaxYears));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of years a recurrence rule can span for frequencies
     * other than DAILY/WEEKLY/MONTHLY/YEARLY; 0 means unlimited
     *
     * @param zimbraCalendarRecurrenceOtherFrequencyMaxYears new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=665)
    public Map<String,Object> setCalendarRecurrenceOtherFrequencyMaxYears(int zimbraCalendarRecurrenceOtherFrequencyMaxYears, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceOtherFrequencyMaxYears, Integer.toString(zimbraCalendarRecurrenceOtherFrequencyMaxYears));
        return attrs;
    }

    /**
     * Maximum number of years a recurrence rule can span for frequencies
     * other than DAILY/WEEKLY/MONTHLY/YEARLY; 0 means unlimited
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=665)
    public void unsetCalendarRecurrenceOtherFrequencyMaxYears() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceOtherFrequencyMaxYears, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of years a recurrence rule can span for frequencies
     * other than DAILY/WEEKLY/MONTHLY/YEARLY; 0 means unlimited
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=665)
    public Map<String,Object> unsetCalendarRecurrenceOtherFrequencyMaxYears(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceOtherFrequencyMaxYears, "");
        return attrs;
    }

    /**
     * Maximum number of weeks a WEEKLY recurrence rule can span; 0 means
     * unlimited
     *
     * @return zimbraCalendarRecurrenceWeeklyMaxWeeks, or -1 if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=662)
    public int getCalendarRecurrenceWeeklyMaxWeeks() {
        return getIntAttr(Provisioning.A_zimbraCalendarRecurrenceWeeklyMaxWeeks, -1);
    }

    /**
     * Maximum number of weeks a WEEKLY recurrence rule can span; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceWeeklyMaxWeeks new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=662)
    public void setCalendarRecurrenceWeeklyMaxWeeks(int zimbraCalendarRecurrenceWeeklyMaxWeeks) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceWeeklyMaxWeeks, Integer.toString(zimbraCalendarRecurrenceWeeklyMaxWeeks));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of weeks a WEEKLY recurrence rule can span; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceWeeklyMaxWeeks new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=662)
    public Map<String,Object> setCalendarRecurrenceWeeklyMaxWeeks(int zimbraCalendarRecurrenceWeeklyMaxWeeks, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceWeeklyMaxWeeks, Integer.toString(zimbraCalendarRecurrenceWeeklyMaxWeeks));
        return attrs;
    }

    /**
     * Maximum number of weeks a WEEKLY recurrence rule can span; 0 means
     * unlimited
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=662)
    public void unsetCalendarRecurrenceWeeklyMaxWeeks() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceWeeklyMaxWeeks, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of weeks a WEEKLY recurrence rule can span; 0 means
     * unlimited
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=662)
    public Map<String,Object> unsetCalendarRecurrenceWeeklyMaxWeeks(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceWeeklyMaxWeeks, "");
        return attrs;
    }

    /**
     * Maximum number of years a YEARLY recurrence rule can span; 0 means
     * unlimited
     *
     * @return zimbraCalendarRecurrenceYearlyMaxYears, or -1 if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=664)
    public int getCalendarRecurrenceYearlyMaxYears() {
        return getIntAttr(Provisioning.A_zimbraCalendarRecurrenceYearlyMaxYears, -1);
    }

    /**
     * Maximum number of years a YEARLY recurrence rule can span; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceYearlyMaxYears new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=664)
    public void setCalendarRecurrenceYearlyMaxYears(int zimbraCalendarRecurrenceYearlyMaxYears) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceYearlyMaxYears, Integer.toString(zimbraCalendarRecurrenceYearlyMaxYears));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of years a YEARLY recurrence rule can span; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceYearlyMaxYears new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=664)
    public Map<String,Object> setCalendarRecurrenceYearlyMaxYears(int zimbraCalendarRecurrenceYearlyMaxYears, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceYearlyMaxYears, Integer.toString(zimbraCalendarRecurrenceYearlyMaxYears));
        return attrs;
    }

    /**
     * Maximum number of years a YEARLY recurrence rule can span; 0 means
     * unlimited
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=664)
    public void unsetCalendarRecurrenceYearlyMaxYears() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceYearlyMaxYears, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of years a YEARLY recurrence rule can span; 0 means
     * unlimited
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=664)
    public Map<String,Object> unsetCalendarRecurrenceYearlyMaxYears(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceYearlyMaxYears, "");
        return attrs;
    }

    /**
     * Max ldap search size for calendar resource
     *
     * @return zimbraCalendarResourceLdapSearchMaxSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1742)
    public int getCalendarResourceLdapSearchMaxSize() {
        return getIntAttr(Provisioning.A_zimbraCalendarResourceLdapSearchMaxSize, -1);
    }

    /**
     * Max ldap search size for calendar resource
     *
     * @param zimbraCalendarResourceLdapSearchMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1742)
    public void setCalendarResourceLdapSearchMaxSize(int zimbraCalendarResourceLdapSearchMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarResourceLdapSearchMaxSize, Integer.toString(zimbraCalendarResourceLdapSearchMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max ldap search size for calendar resource
     *
     * @param zimbraCalendarResourceLdapSearchMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1742)
    public Map<String,Object> setCalendarResourceLdapSearchMaxSize(int zimbraCalendarResourceLdapSearchMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarResourceLdapSearchMaxSize, Integer.toString(zimbraCalendarResourceLdapSearchMaxSize));
        return attrs;
    }

    /**
     * Max ldap search size for calendar resource
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1742)
    public void unsetCalendarResourceLdapSearchMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarResourceLdapSearchMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max ldap search size for calendar resource
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1742)
    public Map<String,Object> unsetCalendarResourceLdapSearchMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarResourceLdapSearchMaxSize, "");
        return attrs;
    }

    /**
     * Calendar search maximum days
     *
     * @return zimbraCalendarSearchMaxDays, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1706)
    public int getCalendarSearchMaxDays() {
        return getIntAttr(Provisioning.A_zimbraCalendarSearchMaxDays, -1);
    }

    /**
     * Calendar search maximum days
     *
     * @param zimbraCalendarSearchMaxDays new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1706)
    public void setCalendarSearchMaxDays(int zimbraCalendarSearchMaxDays) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarSearchMaxDays, Integer.toString(zimbraCalendarSearchMaxDays));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Calendar search maximum days
     *
     * @param zimbraCalendarSearchMaxDays new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1706)
    public Map<String,Object> setCalendarSearchMaxDays(int zimbraCalendarSearchMaxDays, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarSearchMaxDays, Integer.toString(zimbraCalendarSearchMaxDays));
        return attrs;
    }

    /**
     * Calendar search maximum days
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1706)
    public void unsetCalendarSearchMaxDays() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarSearchMaxDays, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Calendar search maximum days
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1706)
    public Map<String,Object> unsetCalendarSearchMaxDays(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarSearchMaxDays, "");
        return attrs;
    }

    /**
     * IP Address/hostname for ClamAV to bind to for attachment scanning.
     * Default is localhost
     *
     * @return zimbraClamAVBindAddress, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1619)
    public String getClamAVBindAddress() {
        return getAttr(Provisioning.A_zimbraClamAVBindAddress, null);
    }

    /**
     * IP Address/hostname for ClamAV to bind to for attachment scanning.
     * Default is localhost
     *
     * @param zimbraClamAVBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1619)
    public void setClamAVBindAddress(String zimbraClamAVBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVBindAddress, zimbraClamAVBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP Address/hostname for ClamAV to bind to for attachment scanning.
     * Default is localhost
     *
     * @param zimbraClamAVBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1619)
    public Map<String,Object> setClamAVBindAddress(String zimbraClamAVBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVBindAddress, zimbraClamAVBindAddress);
        return attrs;
    }

    /**
     * IP Address/hostname for ClamAV to bind to for attachment scanning.
     * Default is localhost
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1619)
    public void unsetClamAVBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP Address/hostname for ClamAV to bind to for attachment scanning.
     * Default is localhost
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1619)
    public Map<String,Object> unsetClamAVBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVBindAddress, "");
        return attrs;
    }

    /**
     * Port to bind to for attachment scanning. Default is 3310
     *
     * @return zimbraClamAVListenPort, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1620)
    public int getClamAVListenPort() {
        return getIntAttr(Provisioning.A_zimbraClamAVListenPort, -1);
    }

    /**
     * Port to bind to for attachment scanning. Default is 3310
     *
     * @param zimbraClamAVListenPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1620)
    public void setClamAVListenPort(int zimbraClamAVListenPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVListenPort, Integer.toString(zimbraClamAVListenPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Port to bind to for attachment scanning. Default is 3310
     *
     * @param zimbraClamAVListenPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1620)
    public Map<String,Object> setClamAVListenPort(int zimbraClamAVListenPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVListenPort, Integer.toString(zimbraClamAVListenPort));
        return attrs;
    }

    /**
     * Port to bind to for attachment scanning. Default is 3310
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1620)
    public void unsetClamAVListenPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVListenPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Port to bind to for attachment scanning. Default is 3310
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1620)
    public Map<String,Object> unsetClamAVListenPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVListenPort, "");
        return attrs;
    }

    /**
     * Maximum number of ClamAV servers to run. Default is 10
     *
     * @return zimbraClamAVMaxThreads, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1462)
    public int getClamAVMaxThreads() {
        return getIntAttr(Provisioning.A_zimbraClamAVMaxThreads, -1);
    }

    /**
     * Maximum number of ClamAV servers to run. Default is 10
     *
     * @param zimbraClamAVMaxThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1462)
    public void setClamAVMaxThreads(int zimbraClamAVMaxThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVMaxThreads, Integer.toString(zimbraClamAVMaxThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of ClamAV servers to run. Default is 10
     *
     * @param zimbraClamAVMaxThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1462)
    public Map<String,Object> setClamAVMaxThreads(int zimbraClamAVMaxThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVMaxThreads, Integer.toString(zimbraClamAVMaxThreads));
        return attrs;
    }

    /**
     * Maximum number of ClamAV servers to run. Default is 10
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1462)
    public void unsetClamAVMaxThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVMaxThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of ClamAV servers to run. Default is 10
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1462)
    public Map<String,Object> unsetClamAVMaxThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVMaxThreads, "");
        return attrs;
    }

    /**
     * Type of HA cluster software in use; &quot;none&quot; by default,
     * &quot;RedHat&quot; for Red Hat cluster or &quot;Veritas&quot; for
     * Veritas Cluster Server from Symantec
     *
     * <p>Valid values: [RedHat, Veritas, none]
     *
     * @return zimbraClusterType, or null if unset and/or has invalid value
     */
    @ZAttr(id=508)
    public ZAttrProvisioning.ClusterType getClusterType() {
        try { String v = getAttr(Provisioning.A_zimbraClusterType); return v == null ? null : ZAttrProvisioning.ClusterType.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Type of HA cluster software in use; &quot;none&quot; by default,
     * &quot;RedHat&quot; for Red Hat cluster or &quot;Veritas&quot; for
     * Veritas Cluster Server from Symantec
     *
     * <p>Valid values: [RedHat, Veritas, none]
     *
     * @return zimbraClusterType, or null if unset
     */
    @ZAttr(id=508)
    public String getClusterTypeAsString() {
        return getAttr(Provisioning.A_zimbraClusterType, null);
    }

    /**
     * Type of HA cluster software in use; &quot;none&quot; by default,
     * &quot;RedHat&quot; for Red Hat cluster or &quot;Veritas&quot; for
     * Veritas Cluster Server from Symantec
     *
     * <p>Valid values: [RedHat, Veritas, none]
     *
     * @param zimbraClusterType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=508)
    public void setClusterType(ZAttrProvisioning.ClusterType zimbraClusterType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClusterType, zimbraClusterType.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Type of HA cluster software in use; &quot;none&quot; by default,
     * &quot;RedHat&quot; for Red Hat cluster or &quot;Veritas&quot; for
     * Veritas Cluster Server from Symantec
     *
     * <p>Valid values: [RedHat, Veritas, none]
     *
     * @param zimbraClusterType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=508)
    public Map<String,Object> setClusterType(ZAttrProvisioning.ClusterType zimbraClusterType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClusterType, zimbraClusterType.toString());
        return attrs;
    }

    /**
     * Type of HA cluster software in use; &quot;none&quot; by default,
     * &quot;RedHat&quot; for Red Hat cluster or &quot;Veritas&quot; for
     * Veritas Cluster Server from Symantec
     *
     * <p>Valid values: [RedHat, Veritas, none]
     *
     * @param zimbraClusterType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=508)
    public void setClusterTypeAsString(String zimbraClusterType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClusterType, zimbraClusterType);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Type of HA cluster software in use; &quot;none&quot; by default,
     * &quot;RedHat&quot; for Red Hat cluster or &quot;Veritas&quot; for
     * Veritas Cluster Server from Symantec
     *
     * <p>Valid values: [RedHat, Veritas, none]
     *
     * @param zimbraClusterType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=508)
    public Map<String,Object> setClusterTypeAsString(String zimbraClusterType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClusterType, zimbraClusterType);
        return attrs;
    }

    /**
     * Type of HA cluster software in use; &quot;none&quot; by default,
     * &quot;RedHat&quot; for Red Hat cluster or &quot;Veritas&quot; for
     * Veritas Cluster Server from Symantec
     *
     * <p>Valid values: [RedHat, Veritas, none]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=508)
    public void unsetClusterType() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClusterType, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Type of HA cluster software in use; &quot;none&quot; by default,
     * &quot;RedHat&quot; for Red Hat cluster or &quot;Veritas&quot; for
     * Veritas Cluster Server from Symantec
     *
     * <p>Valid values: [RedHat, Veritas, none]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=508)
    public Map<String,Object> unsetClusterType(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClusterType, "");
        return attrs;
    }

    /**
     * Whether to append the server ID (or cluster ID where applicable) to
     * blob store paths. Applies to new and existing blobs; therefore
     * generally should not be changed on existing systems.
     *
     * @return zimbraConfiguredServerIDForBlobDirEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1551)
    public boolean isConfiguredServerIDForBlobDirEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraConfiguredServerIDForBlobDirEnabled, false);
    }

    /**
     * Whether to append the server ID (or cluster ID where applicable) to
     * blob store paths. Applies to new and existing blobs; therefore
     * generally should not be changed on existing systems.
     *
     * @param zimbraConfiguredServerIDForBlobDirEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1551)
    public void setConfiguredServerIDForBlobDirEnabled(boolean zimbraConfiguredServerIDForBlobDirEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConfiguredServerIDForBlobDirEnabled, zimbraConfiguredServerIDForBlobDirEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to append the server ID (or cluster ID where applicable) to
     * blob store paths. Applies to new and existing blobs; therefore
     * generally should not be changed on existing systems.
     *
     * @param zimbraConfiguredServerIDForBlobDirEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1551)
    public Map<String,Object> setConfiguredServerIDForBlobDirEnabled(boolean zimbraConfiguredServerIDForBlobDirEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConfiguredServerIDForBlobDirEnabled, zimbraConfiguredServerIDForBlobDirEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether to append the server ID (or cluster ID where applicable) to
     * blob store paths. Applies to new and existing blobs; therefore
     * generally should not be changed on existing systems.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1551)
    public void unsetConfiguredServerIDForBlobDirEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConfiguredServerIDForBlobDirEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to append the server ID (or cluster ID where applicable) to
     * blob store paths. Applies to new and existing blobs; therefore
     * generally should not be changed on existing systems.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1551)
    public Map<String,Object> unsetConfiguredServerIDForBlobDirEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConfiguredServerIDForBlobDirEnabled, "");
        return attrs;
    }

    /**
     * Interface address on which Consul should listen; if empty, binds to
     * all interfaces
     *
     * @return zimbraConsulBindAddress, or empty array if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1677)
    public String[] getConsulBindAddress() {
        return getMultiAttr(Provisioning.A_zimbraConsulBindAddress);
    }

    /**
     * Interface address on which Consul should listen; if empty, binds to
     * all interfaces
     *
     * @param zimbraConsulBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1677)
    public void setConsulBindAddress(String[] zimbraConsulBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConsulBindAddress, zimbraConsulBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Interface address on which Consul should listen; if empty, binds to
     * all interfaces
     *
     * @param zimbraConsulBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1677)
    public Map<String,Object> setConsulBindAddress(String[] zimbraConsulBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConsulBindAddress, zimbraConsulBindAddress);
        return attrs;
    }

    /**
     * Interface address on which Consul should listen; if empty, binds to
     * all interfaces
     *
     * @param zimbraConsulBindAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1677)
    public void addConsulBindAddress(String zimbraConsulBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraConsulBindAddress, zimbraConsulBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Interface address on which Consul should listen; if empty, binds to
     * all interfaces
     *
     * @param zimbraConsulBindAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1677)
    public Map<String,Object> addConsulBindAddress(String zimbraConsulBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraConsulBindAddress, zimbraConsulBindAddress);
        return attrs;
    }

    /**
     * Interface address on which Consul should listen; if empty, binds to
     * all interfaces
     *
     * @param zimbraConsulBindAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1677)
    public void removeConsulBindAddress(String zimbraConsulBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraConsulBindAddress, zimbraConsulBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Interface address on which Consul should listen; if empty, binds to
     * all interfaces
     *
     * @param zimbraConsulBindAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1677)
    public Map<String,Object> removeConsulBindAddress(String zimbraConsulBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraConsulBindAddress, zimbraConsulBindAddress);
        return attrs;
    }

    /**
     * Interface address on which Consul should listen; if empty, binds to
     * all interfaces
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1677)
    public void unsetConsulBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConsulBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Interface address on which Consul should listen; if empty, binds to
     * all interfaces
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1677)
    public Map<String,Object> unsetConsulBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConsulBindAddress, "");
        return attrs;
    }

    /**
     * HTTP port for Consul service
     *
     * <p>Use getConsulBindPortAsString to access value as a string.
     *
     * @see #getConsulBindPortAsString()
     *
     * @return zimbraConsulBindPort, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1676)
    public int getConsulBindPort() {
        return getIntAttr(Provisioning.A_zimbraConsulBindPort, -1);
    }

    /**
     * HTTP port for Consul service
     *
     * @return zimbraConsulBindPort, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1676)
    public String getConsulBindPortAsString() {
        return getAttr(Provisioning.A_zimbraConsulBindPort, null);
    }

    /**
     * HTTP port for Consul service
     *
     * @param zimbraConsulBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1676)
    public void setConsulBindPort(int zimbraConsulBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConsulBindPort, Integer.toString(zimbraConsulBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTP port for Consul service
     *
     * @param zimbraConsulBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1676)
    public Map<String,Object> setConsulBindPort(int zimbraConsulBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConsulBindPort, Integer.toString(zimbraConsulBindPort));
        return attrs;
    }

    /**
     * HTTP port for Consul service
     *
     * @param zimbraConsulBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1676)
    public void setConsulBindPortAsString(String zimbraConsulBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConsulBindPort, zimbraConsulBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTP port for Consul service
     *
     * @param zimbraConsulBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1676)
    public Map<String,Object> setConsulBindPortAsString(String zimbraConsulBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConsulBindPort, zimbraConsulBindPort);
        return attrs;
    }

    /**
     * HTTP port for Consul service
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1676)
    public void unsetConsulBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConsulBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTP port for Consul service
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1676)
    public Map<String,Object> unsetConsulBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConsulBindPort, "");
        return attrs;
    }

    /**
     * URL for accessing the Consul agent.
     *
     * @return zimbraConsulURL, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1678)
    public String getConsulURL() {
        return getAttr(Provisioning.A_zimbraConsulURL, null);
    }

    /**
     * URL for accessing the Consul agent.
     *
     * @param zimbraConsulURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1678)
    public void setConsulURL(String zimbraConsulURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConsulURL, zimbraConsulURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL for accessing the Consul agent.
     *
     * @param zimbraConsulURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1678)
    public Map<String,Object> setConsulURL(String zimbraConsulURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConsulURL, zimbraConsulURL);
        return attrs;
    }

    /**
     * URL for accessing the Consul agent.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1678)
    public void unsetConsulURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConsulURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL for accessing the Consul agent.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1678)
    public Map<String,Object> unsetConsulURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConsulURL, "");
        return attrs;
    }

    /**
     * Comma separated list of Contact attributes that should be hidden from
     * clients and export of contacts.
     *
     * @return zimbraContactHiddenAttributes, or null if unset
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1086)
    public String getContactHiddenAttributes() {
        return getAttr(Provisioning.A_zimbraContactHiddenAttributes, null);
    }

    /**
     * Comma separated list of Contact attributes that should be hidden from
     * clients and export of contacts.
     *
     * @param zimbraContactHiddenAttributes new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1086)
    public void setContactHiddenAttributes(String zimbraContactHiddenAttributes) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactHiddenAttributes, zimbraContactHiddenAttributes);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Comma separated list of Contact attributes that should be hidden from
     * clients and export of contacts.
     *
     * @param zimbraContactHiddenAttributes new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1086)
    public Map<String,Object> setContactHiddenAttributes(String zimbraContactHiddenAttributes, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactHiddenAttributes, zimbraContactHiddenAttributes);
        return attrs;
    }

    /**
     * Comma separated list of Contact attributes that should be hidden from
     * clients and export of contacts.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1086)
    public void unsetContactHiddenAttributes() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactHiddenAttributes, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Comma separated list of Contact attributes that should be hidden from
     * clients and export of contacts.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1086)
    public Map<String,Object> unsetContactHiddenAttributes(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactHiddenAttributes, "");
        return attrs;
    }

    /**
     * Enable contact ranking table
     *
     * @return zimbraContactRankingEnabled, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1816)
    public boolean isContactRankingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraContactRankingEnabled, false);
    }

    /**
     * Enable contact ranking table
     *
     * @param zimbraContactRankingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1816)
    public void setContactRankingEnabled(boolean zimbraContactRankingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactRankingEnabled, zimbraContactRankingEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable contact ranking table
     *
     * @param zimbraContactRankingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1816)
    public Map<String,Object> setContactRankingEnabled(boolean zimbraContactRankingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactRankingEnabled, zimbraContactRankingEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Enable contact ranking table
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1816)
    public void unsetContactRankingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactRankingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable contact ranking table
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1816)
    public Map<String,Object> unsetContactRankingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactRankingEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.6. Deprecated per bug 40081. Orig desc: How
     * often do we refresh contact ranking table from address book and GAL to
     * get friendly name for the email address. Use 0 to disable the
     * refresh.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getContactRankingTableRefreshIntervalAsString to access value as a string.
     *
     * @see #getContactRankingTableRefreshIntervalAsString()
     *
     * @return zimbraContactRankingTableRefreshInterval in millseconds, or -1 if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1023)
    public long getContactRankingTableRefreshInterval() {
        return getTimeInterval(Provisioning.A_zimbraContactRankingTableRefreshInterval, -1L);
    }

    /**
     * Deprecated since: 6.0.6. Deprecated per bug 40081. Orig desc: How
     * often do we refresh contact ranking table from address book and GAL to
     * get friendly name for the email address. Use 0 to disable the
     * refresh.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraContactRankingTableRefreshInterval, or null if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1023)
    public String getContactRankingTableRefreshIntervalAsString() {
        return getAttr(Provisioning.A_zimbraContactRankingTableRefreshInterval, null);
    }

    /**
     * Deprecated since: 6.0.6. Deprecated per bug 40081. Orig desc: How
     * often do we refresh contact ranking table from address book and GAL to
     * get friendly name for the email address. Use 0 to disable the
     * refresh.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraContactRankingTableRefreshInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1023)
    public void setContactRankingTableRefreshInterval(String zimbraContactRankingTableRefreshInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactRankingTableRefreshInterval, zimbraContactRankingTableRefreshInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.6. Deprecated per bug 40081. Orig desc: How
     * often do we refresh contact ranking table from address book and GAL to
     * get friendly name for the email address. Use 0 to disable the
     * refresh.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraContactRankingTableRefreshInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1023)
    public Map<String,Object> setContactRankingTableRefreshInterval(String zimbraContactRankingTableRefreshInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactRankingTableRefreshInterval, zimbraContactRankingTableRefreshInterval);
        return attrs;
    }

    /**
     * Deprecated since: 6.0.6. Deprecated per bug 40081. Orig desc: How
     * often do we refresh contact ranking table from address book and GAL to
     * get friendly name for the email address. Use 0 to disable the
     * refresh.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1023)
    public void unsetContactRankingTableRefreshInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactRankingTableRefreshInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.6. Deprecated per bug 40081. Orig desc: How
     * often do we refresh contact ranking table from address book and GAL to
     * get friendly name for the email address. Use 0 to disable the
     * refresh.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1023)
    public Map<String,Object> unsetContactRankingTableRefreshInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactRankingTableRefreshInterval, "");
        return attrs;
    }

    /**
     * Flag to enable contact ranking table
     *
     * @return zimbraConversationIgnoreMaillistPrefix, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1792)
    public boolean isConversationIgnoreMaillistPrefix() {
        return getBooleanAttr(Provisioning.A_zimbraConversationIgnoreMaillistPrefix, false);
    }

    /**
     * Flag to enable contact ranking table
     *
     * @param zimbraConversationIgnoreMaillistPrefix new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1792)
    public void setConversationIgnoreMaillistPrefix(boolean zimbraConversationIgnoreMaillistPrefix) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConversationIgnoreMaillistPrefix, zimbraConversationIgnoreMaillistPrefix ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable contact ranking table
     *
     * @param zimbraConversationIgnoreMaillistPrefix new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1792)
    public Map<String,Object> setConversationIgnoreMaillistPrefix(boolean zimbraConversationIgnoreMaillistPrefix, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConversationIgnoreMaillistPrefix, zimbraConversationIgnoreMaillistPrefix ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to enable contact ranking table
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1792)
    public void unsetConversationIgnoreMaillistPrefix() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConversationIgnoreMaillistPrefix, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable contact ranking table
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1792)
    public Map<String,Object> unsetConversationIgnoreMaillistPrefix(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConversationIgnoreMaillistPrefix, "");
        return attrs;
    }

    /**
     * Conversation max age in millis. Deletes rows from open_conversation
     * whose items are older than the given no of days. Default is 31 days..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getConversationMaxAgeAsString to access value as a string.
     *
     * @see #getConversationMaxAgeAsString()
     *
     * @return zimbraConversationMaxAge in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1793)
    public long getConversationMaxAge() {
        return getTimeInterval(Provisioning.A_zimbraConversationMaxAge, -1L);
    }

    /**
     * Conversation max age in millis. Deletes rows from open_conversation
     * whose items are older than the given no of days. Default is 31 days..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraConversationMaxAge, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1793)
    public String getConversationMaxAgeAsString() {
        return getAttr(Provisioning.A_zimbraConversationMaxAge, null);
    }

    /**
     * Conversation max age in millis. Deletes rows from open_conversation
     * whose items are older than the given no of days. Default is 31 days..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraConversationMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1793)
    public void setConversationMaxAge(String zimbraConversationMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConversationMaxAge, zimbraConversationMaxAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Conversation max age in millis. Deletes rows from open_conversation
     * whose items are older than the given no of days. Default is 31 days..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraConversationMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1793)
    public Map<String,Object> setConversationMaxAge(String zimbraConversationMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConversationMaxAge, zimbraConversationMaxAge);
        return attrs;
    }

    /**
     * Conversation max age in millis. Deletes rows from open_conversation
     * whose items are older than the given no of days. Default is 31 days..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1793)
    public void unsetConversationMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConversationMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Conversation max age in millis. Deletes rows from open_conversation
     * whose items are older than the given no of days. Default is 31 days..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1793)
    public Map<String,Object> unsetConversationMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConversationMaxAge, "");
        return attrs;
    }

    /**
     * Timeout in milliseconds before retrying failed convert URLs.
     *
     * @return zimbraConvertPoolTimeout, or -1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2059)
    public int getConvertPoolTimeout() {
        return getIntAttr(Provisioning.A_zimbraConvertPoolTimeout, -1);
    }

    /**
     * Timeout in milliseconds before retrying failed convert URLs.
     *
     * @param zimbraConvertPoolTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2059)
    public void setConvertPoolTimeout(int zimbraConvertPoolTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConvertPoolTimeout, Integer.toString(zimbraConvertPoolTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout in milliseconds before retrying failed convert URLs.
     *
     * @param zimbraConvertPoolTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2059)
    public Map<String,Object> setConvertPoolTimeout(int zimbraConvertPoolTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConvertPoolTimeout, Integer.toString(zimbraConvertPoolTimeout));
        return attrs;
    }

    /**
     * Timeout in milliseconds before retrying failed convert URLs.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2059)
    public void unsetConvertPoolTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConvertPoolTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout in milliseconds before retrying failed convert URLs.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2059)
    public Map<String,Object> unsetConvertPoolTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConvertPoolTimeout, "");
        return attrs;
    }

    /**
     * convertd URL
     *
     * @return zimbraConvertdURL, or empty array if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=776)
    public String[] getConvertdURL() {
        return getMultiAttr(Provisioning.A_zimbraConvertdURL);
    }

    /**
     * convertd URL
     *
     * @param zimbraConvertdURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=776)
    public void setConvertdURL(String[] zimbraConvertdURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConvertdURL, zimbraConvertdURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * convertd URL
     *
     * @param zimbraConvertdURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=776)
    public Map<String,Object> setConvertdURL(String[] zimbraConvertdURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConvertdURL, zimbraConvertdURL);
        return attrs;
    }

    /**
     * convertd URL
     *
     * @param zimbraConvertdURL new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=776)
    public void addConvertdURL(String zimbraConvertdURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraConvertdURL, zimbraConvertdURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * convertd URL
     *
     * @param zimbraConvertdURL new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=776)
    public Map<String,Object> addConvertdURL(String zimbraConvertdURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraConvertdURL, zimbraConvertdURL);
        return attrs;
    }

    /**
     * convertd URL
     *
     * @param zimbraConvertdURL existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=776)
    public void removeConvertdURL(String zimbraConvertdURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraConvertdURL, zimbraConvertdURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * convertd URL
     *
     * @param zimbraConvertdURL existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=776)
    public Map<String,Object> removeConvertdURL(String zimbraConvertdURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraConvertdURL, zimbraConvertdURL);
        return attrs;
    }

    /**
     * convertd URL
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=776)
    public void unsetConvertdURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConvertdURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * convertd URL
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=776)
    public Map<String,Object> unsetConvertdURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConvertdURL, "");
        return attrs;
    }

    /**
     * time object was created
     *
     * <p>Use getCreateTimestampAsString to access value as a string.
     *
     * @see #getCreateTimestampAsString()
     *
     * @return zimbraCreateTimestamp as Date, null if unset or unable to parse
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public Date getCreateTimestamp() {
        return getGeneralizedTimeAttr(Provisioning.A_zimbraCreateTimestamp, null);
    }

    /**
     * time object was created
     *
     * @return zimbraCreateTimestamp, or null if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public String getCreateTimestampAsString() {
        return getAttr(Provisioning.A_zimbraCreateTimestamp, null);
    }

    /**
     * time object was created
     *
     * @param zimbraCreateTimestamp new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public void setCreateTimestamp(Date zimbraCreateTimestamp) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCreateTimestamp, zimbraCreateTimestamp==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraCreateTimestamp));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time object was created
     *
     * @param zimbraCreateTimestamp new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public Map<String,Object> setCreateTimestamp(Date zimbraCreateTimestamp, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCreateTimestamp, zimbraCreateTimestamp==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraCreateTimestamp));
        return attrs;
    }

    /**
     * time object was created
     *
     * @param zimbraCreateTimestamp new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public void setCreateTimestampAsString(String zimbraCreateTimestamp) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCreateTimestamp, zimbraCreateTimestamp);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time object was created
     *
     * @param zimbraCreateTimestamp new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public Map<String,Object> setCreateTimestampAsString(String zimbraCreateTimestamp, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCreateTimestamp, zimbraCreateTimestamp);
        return attrs;
    }

    /**
     * time object was created
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public void unsetCreateTimestamp() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCreateTimestamp, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time object was created
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public Map<String,Object> unsetCreateTimestamp(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCreateTimestamp, "");
        return attrs;
    }

    /**
     * IP Address(es) of the root DNS servers to be used by the DNS cache
     * service
     *
     * @return zimbraDNSMasterIP, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1569)
    public String[] getDNSMasterIP() {
        return getMultiAttr(Provisioning.A_zimbraDNSMasterIP);
    }

    /**
     * IP Address(es) of the root DNS servers to be used by the DNS cache
     * service
     *
     * @param zimbraDNSMasterIP new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1569)
    public void setDNSMasterIP(String[] zimbraDNSMasterIP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSMasterIP, zimbraDNSMasterIP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP Address(es) of the root DNS servers to be used by the DNS cache
     * service
     *
     * @param zimbraDNSMasterIP new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1569)
    public Map<String,Object> setDNSMasterIP(String[] zimbraDNSMasterIP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSMasterIP, zimbraDNSMasterIP);
        return attrs;
    }

    /**
     * IP Address(es) of the root DNS servers to be used by the DNS cache
     * service
     *
     * @param zimbraDNSMasterIP new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1569)
    public void addDNSMasterIP(String zimbraDNSMasterIP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraDNSMasterIP, zimbraDNSMasterIP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP Address(es) of the root DNS servers to be used by the DNS cache
     * service
     *
     * @param zimbraDNSMasterIP new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1569)
    public Map<String,Object> addDNSMasterIP(String zimbraDNSMasterIP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraDNSMasterIP, zimbraDNSMasterIP);
        return attrs;
    }

    /**
     * IP Address(es) of the root DNS servers to be used by the DNS cache
     * service
     *
     * @param zimbraDNSMasterIP existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1569)
    public void removeDNSMasterIP(String zimbraDNSMasterIP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraDNSMasterIP, zimbraDNSMasterIP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP Address(es) of the root DNS servers to be used by the DNS cache
     * service
     *
     * @param zimbraDNSMasterIP existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1569)
    public Map<String,Object> removeDNSMasterIP(String zimbraDNSMasterIP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraDNSMasterIP, zimbraDNSMasterIP);
        return attrs;
    }

    /**
     * IP Address(es) of the root DNS servers to be used by the DNS cache
     * service
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1569)
    public void unsetDNSMasterIP() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSMasterIP, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP Address(es) of the root DNS servers to be used by the DNS cache
     * service
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1569)
    public Map<String,Object> unsetDNSMasterIP(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSMasterIP, "");
        return attrs;
    }

    /**
     * For zimbra dnscache, whether or not to only use TCP when talking to
     * the upstream Master DNS servers. Defaults to no
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraDNSTCPUpstream, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1597)
    public ZAttrProvisioning.DNSTCPUpstream getDNSTCPUpstream() {
        try { String v = getAttr(Provisioning.A_zimbraDNSTCPUpstream); return v == null ? null : ZAttrProvisioning.DNSTCPUpstream.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * For zimbra dnscache, whether or not to only use TCP when talking to
     * the upstream Master DNS servers. Defaults to no
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraDNSTCPUpstream, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1597)
    public String getDNSTCPUpstreamAsString() {
        return getAttr(Provisioning.A_zimbraDNSTCPUpstream, null);
    }

    /**
     * For zimbra dnscache, whether or not to only use TCP when talking to
     * the upstream Master DNS servers. Defaults to no
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraDNSTCPUpstream new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1597)
    public void setDNSTCPUpstream(ZAttrProvisioning.DNSTCPUpstream zimbraDNSTCPUpstream) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSTCPUpstream, zimbraDNSTCPUpstream.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For zimbra dnscache, whether or not to only use TCP when talking to
     * the upstream Master DNS servers. Defaults to no
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraDNSTCPUpstream new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1597)
    public Map<String,Object> setDNSTCPUpstream(ZAttrProvisioning.DNSTCPUpstream zimbraDNSTCPUpstream, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSTCPUpstream, zimbraDNSTCPUpstream.toString());
        return attrs;
    }

    /**
     * For zimbra dnscache, whether or not to only use TCP when talking to
     * the upstream Master DNS servers. Defaults to no
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraDNSTCPUpstream new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1597)
    public void setDNSTCPUpstreamAsString(String zimbraDNSTCPUpstream) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSTCPUpstream, zimbraDNSTCPUpstream);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For zimbra dnscache, whether or not to only use TCP when talking to
     * the upstream Master DNS servers. Defaults to no
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraDNSTCPUpstream new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1597)
    public Map<String,Object> setDNSTCPUpstreamAsString(String zimbraDNSTCPUpstream, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSTCPUpstream, zimbraDNSTCPUpstream);
        return attrs;
    }

    /**
     * For zimbra dnscache, whether or not to only use TCP when talking to
     * the upstream Master DNS servers. Defaults to no
     *
     * <p>Valid values: [no, yes]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1597)
    public void unsetDNSTCPUpstream() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSTCPUpstream, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For zimbra dnscache, whether or not to only use TCP when talking to
     * the upstream Master DNS servers. Defaults to no
     *
     * <p>Valid values: [no, yes]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1597)
    public Map<String,Object> unsetDNSTCPUpstream(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSTCPUpstream, "");
        return attrs;
    }

    /**
     * For zimbra dnscache, whether or not to use TCP. Defaults to yes
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraDNSUseTCP, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1584)
    public ZAttrProvisioning.DNSUseTCP getDNSUseTCP() {
        try { String v = getAttr(Provisioning.A_zimbraDNSUseTCP); return v == null ? null : ZAttrProvisioning.DNSUseTCP.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * For zimbra dnscache, whether or not to use TCP. Defaults to yes
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraDNSUseTCP, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1584)
    public String getDNSUseTCPAsString() {
        return getAttr(Provisioning.A_zimbraDNSUseTCP, null);
    }

    /**
     * For zimbra dnscache, whether or not to use TCP. Defaults to yes
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraDNSUseTCP new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1584)
    public void setDNSUseTCP(ZAttrProvisioning.DNSUseTCP zimbraDNSUseTCP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseTCP, zimbraDNSUseTCP.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For zimbra dnscache, whether or not to use TCP. Defaults to yes
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraDNSUseTCP new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1584)
    public Map<String,Object> setDNSUseTCP(ZAttrProvisioning.DNSUseTCP zimbraDNSUseTCP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseTCP, zimbraDNSUseTCP.toString());
        return attrs;
    }

    /**
     * For zimbra dnscache, whether or not to use TCP. Defaults to yes
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraDNSUseTCP new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1584)
    public void setDNSUseTCPAsString(String zimbraDNSUseTCP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseTCP, zimbraDNSUseTCP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For zimbra dnscache, whether or not to use TCP. Defaults to yes
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraDNSUseTCP new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1584)
    public Map<String,Object> setDNSUseTCPAsString(String zimbraDNSUseTCP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseTCP, zimbraDNSUseTCP);
        return attrs;
    }

    /**
     * For zimbra dnscache, whether or not to use TCP. Defaults to yes
     *
     * <p>Valid values: [no, yes]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1584)
    public void unsetDNSUseTCP() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseTCP, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For zimbra dnscache, whether or not to use TCP. Defaults to yes
     *
     * <p>Valid values: [no, yes]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1584)
    public Map<String,Object> unsetDNSUseTCP(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseTCP, "");
        return attrs;
    }

    /**
     * For zimbra dnscache, whether or not to use UDP. Defaults to yes
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraDNSUseUDP, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1586)
    public ZAttrProvisioning.DNSUseUDP getDNSUseUDP() {
        try { String v = getAttr(Provisioning.A_zimbraDNSUseUDP); return v == null ? null : ZAttrProvisioning.DNSUseUDP.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * For zimbra dnscache, whether or not to use UDP. Defaults to yes
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraDNSUseUDP, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1586)
    public String getDNSUseUDPAsString() {
        return getAttr(Provisioning.A_zimbraDNSUseUDP, null);
    }

    /**
     * For zimbra dnscache, whether or not to use UDP. Defaults to yes
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraDNSUseUDP new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1586)
    public void setDNSUseUDP(ZAttrProvisioning.DNSUseUDP zimbraDNSUseUDP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseUDP, zimbraDNSUseUDP.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For zimbra dnscache, whether or not to use UDP. Defaults to yes
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraDNSUseUDP new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1586)
    public Map<String,Object> setDNSUseUDP(ZAttrProvisioning.DNSUseUDP zimbraDNSUseUDP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseUDP, zimbraDNSUseUDP.toString());
        return attrs;
    }

    /**
     * For zimbra dnscache, whether or not to use UDP. Defaults to yes
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraDNSUseUDP new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1586)
    public void setDNSUseUDPAsString(String zimbraDNSUseUDP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseUDP, zimbraDNSUseUDP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For zimbra dnscache, whether or not to use UDP. Defaults to yes
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraDNSUseUDP new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1586)
    public Map<String,Object> setDNSUseUDPAsString(String zimbraDNSUseUDP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseUDP, zimbraDNSUseUDP);
        return attrs;
    }

    /**
     * For zimbra dnscache, whether or not to use UDP. Defaults to yes
     *
     * <p>Valid values: [no, yes]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1586)
    public void unsetDNSUseUDP() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseUDP, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For zimbra dnscache, whether or not to use UDP. Defaults to yes
     *
     * <p>Valid values: [no, yes]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1586)
    public Map<String,Object> unsetDNSUseUDP(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseUDP, "");
        return attrs;
    }

    /**
     * SQL statements that take longer than this duration to execute will be
     * logged to the sqltrace category in mailbox.log.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getDatabaseSlowSqlThresholdAsString to access value as a string.
     *
     * @see #getDatabaseSlowSqlThresholdAsString()
     *
     * @return zimbraDatabaseSlowSqlThreshold in millseconds, or -1 if unset
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1038)
    public long getDatabaseSlowSqlThreshold() {
        return getTimeInterval(Provisioning.A_zimbraDatabaseSlowSqlThreshold, -1L);
    }

    /**
     * SQL statements that take longer than this duration to execute will be
     * logged to the sqltrace category in mailbox.log.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraDatabaseSlowSqlThreshold, or null if unset
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1038)
    public String getDatabaseSlowSqlThresholdAsString() {
        return getAttr(Provisioning.A_zimbraDatabaseSlowSqlThreshold, null);
    }

    /**
     * SQL statements that take longer than this duration to execute will be
     * logged to the sqltrace category in mailbox.log.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraDatabaseSlowSqlThreshold new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1038)
    public void setDatabaseSlowSqlThreshold(String zimbraDatabaseSlowSqlThreshold) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDatabaseSlowSqlThreshold, zimbraDatabaseSlowSqlThreshold);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SQL statements that take longer than this duration to execute will be
     * logged to the sqltrace category in mailbox.log.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraDatabaseSlowSqlThreshold new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1038)
    public Map<String,Object> setDatabaseSlowSqlThreshold(String zimbraDatabaseSlowSqlThreshold, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDatabaseSlowSqlThreshold, zimbraDatabaseSlowSqlThreshold);
        return attrs;
    }

    /**
     * SQL statements that take longer than this duration to execute will be
     * logged to the sqltrace category in mailbox.log.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1038)
    public void unsetDatabaseSlowSqlThreshold() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDatabaseSlowSqlThreshold, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SQL statements that take longer than this duration to execute will be
     * logged to the sqltrace category in mailbox.log.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1038)
    public Map<String,Object> unsetDatabaseSlowSqlThreshold(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDatabaseSlowSqlThreshold, "");
        return attrs;
    }

    /**
     * Flag to skip checking DL membership when removing appoitment
     * atttendees in ZD. Introduced in bug 68728&quot;
     *
     * @return zimbraDesktopCalendarCheckDLMembership, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1745)
    public boolean isDesktopCalendarCheckDLMembership() {
        return getBooleanAttr(Provisioning.A_zimbraDesktopCalendarCheckDLMembership, false);
    }

    /**
     * Flag to skip checking DL membership when removing appoitment
     * atttendees in ZD. Introduced in bug 68728&quot;
     *
     * @param zimbraDesktopCalendarCheckDLMembership new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1745)
    public void setDesktopCalendarCheckDLMembership(boolean zimbraDesktopCalendarCheckDLMembership) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDesktopCalendarCheckDLMembership, zimbraDesktopCalendarCheckDLMembership ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to skip checking DL membership when removing appoitment
     * atttendees in ZD. Introduced in bug 68728&quot;
     *
     * @param zimbraDesktopCalendarCheckDLMembership new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1745)
    public Map<String,Object> setDesktopCalendarCheckDLMembership(boolean zimbraDesktopCalendarCheckDLMembership, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDesktopCalendarCheckDLMembership, zimbraDesktopCalendarCheckDLMembership ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to skip checking DL membership when removing appoitment
     * atttendees in ZD. Introduced in bug 68728&quot;
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1745)
    public void unsetDesktopCalendarCheckDLMembership() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDesktopCalendarCheckDLMembership, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to skip checking DL membership when removing appoitment
     * atttendees in ZD. Introduced in bug 68728&quot;
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1745)
    public Map<String,Object> unsetDesktopCalendarCheckDLMembership(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDesktopCalendarCheckDLMembership, "");
        return attrs;
    }

    /**
     * EmptyFolderOpTimeout is the time in seconds for which empty folder
     * operation will wait for the current empty folder operation to complete
     *
     * @return zimbraEmptyFolderOpTimeout, or -1 if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1652)
    public int getEmptyFolderOpTimeout() {
        return getIntAttr(Provisioning.A_zimbraEmptyFolderOpTimeout, -1);
    }

    /**
     * EmptyFolderOpTimeout is the time in seconds for which empty folder
     * operation will wait for the current empty folder operation to complete
     *
     * @param zimbraEmptyFolderOpTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1652)
    public void setEmptyFolderOpTimeout(int zimbraEmptyFolderOpTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEmptyFolderOpTimeout, Integer.toString(zimbraEmptyFolderOpTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * EmptyFolderOpTimeout is the time in seconds for which empty folder
     * operation will wait for the current empty folder operation to complete
     *
     * @param zimbraEmptyFolderOpTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1652)
    public Map<String,Object> setEmptyFolderOpTimeout(int zimbraEmptyFolderOpTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEmptyFolderOpTimeout, Integer.toString(zimbraEmptyFolderOpTimeout));
        return attrs;
    }

    /**
     * EmptyFolderOpTimeout is the time in seconds for which empty folder
     * operation will wait for the current empty folder operation to complete
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1652)
    public void unsetEmptyFolderOpTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEmptyFolderOpTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * EmptyFolderOpTimeout is the time in seconds for which empty folder
     * operation will wait for the current empty folder operation to complete
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1652)
    public Map<String,Object> unsetEmptyFolderOpTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEmptyFolderOpTimeout, "");
        return attrs;
    }

    /**
     * Flag to use auto discover service url for the ews
     *
     * @return zimbraEwsAutoDiscoverUseServiceUrl, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1844)
    public boolean isEwsAutoDiscoverUseServiceUrl() {
        return getBooleanAttr(Provisioning.A_zimbraEwsAutoDiscoverUseServiceUrl, false);
    }

    /**
     * Flag to use auto discover service url for the ews
     *
     * @param zimbraEwsAutoDiscoverUseServiceUrl new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1844)
    public void setEwsAutoDiscoverUseServiceUrl(boolean zimbraEwsAutoDiscoverUseServiceUrl) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEwsAutoDiscoverUseServiceUrl, zimbraEwsAutoDiscoverUseServiceUrl ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to use auto discover service url for the ews
     *
     * @param zimbraEwsAutoDiscoverUseServiceUrl new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1844)
    public Map<String,Object> setEwsAutoDiscoverUseServiceUrl(boolean zimbraEwsAutoDiscoverUseServiceUrl, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEwsAutoDiscoverUseServiceUrl, zimbraEwsAutoDiscoverUseServiceUrl ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to use auto discover service url for the ews
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1844)
    public void unsetEwsAutoDiscoverUseServiceUrl() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEwsAutoDiscoverUseServiceUrl, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to use auto discover service url for the ews
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1844)
    public Map<String,Object> unsetEwsAutoDiscoverUseServiceUrl(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEwsAutoDiscoverUseServiceUrl, "");
        return attrs;
    }

    /**
     * File path for ews logs
     *
     * @return zimbraEwsServiceLogFile, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1747)
    public String getEwsServiceLogFile() {
        return getAttr(Provisioning.A_zimbraEwsServiceLogFile, null);
    }

    /**
     * File path for ews logs
     *
     * @param zimbraEwsServiceLogFile new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1747)
    public void setEwsServiceLogFile(String zimbraEwsServiceLogFile) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEwsServiceLogFile, zimbraEwsServiceLogFile);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * File path for ews logs
     *
     * @param zimbraEwsServiceLogFile new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1747)
    public Map<String,Object> setEwsServiceLogFile(String zimbraEwsServiceLogFile, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEwsServiceLogFile, zimbraEwsServiceLogFile);
        return attrs;
    }

    /**
     * File path for ews logs
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1747)
    public void unsetEwsServiceLogFile() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEwsServiceLogFile, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * File path for ews logs
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1747)
    public Map<String,Object> unsetEwsServiceLogFile(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEwsServiceLogFile, "");
        return attrs;
    }

    /**
     * Path specifying the location of ews wsdl
     *
     * @return zimbraEwsWsdlLocation, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1746)
    public String getEwsWsdlLocation() {
        return getAttr(Provisioning.A_zimbraEwsWsdlLocation, null);
    }

    /**
     * Path specifying the location of ews wsdl
     *
     * @param zimbraEwsWsdlLocation new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1746)
    public void setEwsWsdlLocation(String zimbraEwsWsdlLocation) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEwsWsdlLocation, zimbraEwsWsdlLocation);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Path specifying the location of ews wsdl
     *
     * @param zimbraEwsWsdlLocation new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1746)
    public Map<String,Object> setEwsWsdlLocation(String zimbraEwsWsdlLocation, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEwsWsdlLocation, zimbraEwsWsdlLocation);
        return attrs;
    }

    /**
     * Path specifying the location of ews wsdl
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1746)
    public void unsetEwsWsdlLocation() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEwsWsdlLocation, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Path specifying the location of ews wsdl
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1746)
    public Map<String,Object> unsetEwsWsdlLocation(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEwsWsdlLocation, "");
        return attrs;
    }

    /**
     * interface address on which zimbra extension server should listen; if
     * empty, binds to all interfaces
     *
     * @return zimbraExtensionBindAddress, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1369)
    public String getExtensionBindAddress() {
        return getAttr(Provisioning.A_zimbraExtensionBindAddress, null);
    }

    /**
     * interface address on which zimbra extension server should listen; if
     * empty, binds to all interfaces
     *
     * @param zimbraExtensionBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1369)
    public void setExtensionBindAddress(String zimbraExtensionBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExtensionBindAddress, zimbraExtensionBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which zimbra extension server should listen; if
     * empty, binds to all interfaces
     *
     * @param zimbraExtensionBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1369)
    public Map<String,Object> setExtensionBindAddress(String zimbraExtensionBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExtensionBindAddress, zimbraExtensionBindAddress);
        return attrs;
    }

    /**
     * interface address on which zimbra extension server should listen; if
     * empty, binds to all interfaces
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1369)
    public void unsetExtensionBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExtensionBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which zimbra extension server should listen; if
     * empty, binds to all interfaces
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1369)
    public Map<String,Object> unsetExtensionBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExtensionBindAddress, "");
        return attrs;
    }

    /**
     * HTTPs port on which zimbra extension server should listen
     *
     * <p>Use getExtensionBindPortAsString to access value as a string.
     *
     * @see #getExtensionBindPortAsString()
     *
     * @return zimbraExtensionBindPort, or -1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1980)
    public int getExtensionBindPort() {
        return getIntAttr(Provisioning.A_zimbraExtensionBindPort, -1);
    }

    /**
     * HTTPs port on which zimbra extension server should listen
     *
     * @return zimbraExtensionBindPort, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1980)
    public String getExtensionBindPortAsString() {
        return getAttr(Provisioning.A_zimbraExtensionBindPort, null);
    }

    /**
     * HTTPs port on which zimbra extension server should listen
     *
     * @param zimbraExtensionBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1980)
    public void setExtensionBindPort(int zimbraExtensionBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExtensionBindPort, Integer.toString(zimbraExtensionBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTPs port on which zimbra extension server should listen
     *
     * @param zimbraExtensionBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1980)
    public Map<String,Object> setExtensionBindPort(int zimbraExtensionBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExtensionBindPort, Integer.toString(zimbraExtensionBindPort));
        return attrs;
    }

    /**
     * HTTPs port on which zimbra extension server should listen
     *
     * @param zimbraExtensionBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1980)
    public void setExtensionBindPortAsString(String zimbraExtensionBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExtensionBindPort, zimbraExtensionBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTPs port on which zimbra extension server should listen
     *
     * @param zimbraExtensionBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1980)
    public Map<String,Object> setExtensionBindPortAsString(String zimbraExtensionBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExtensionBindPort, zimbraExtensionBindPort);
        return attrs;
    }

    /**
     * HTTPs port on which zimbra extension server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1980)
    public void unsetExtensionBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExtensionBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTPs port on which zimbra extension server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1980)
    public Map<String,Object> unsetExtensionBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExtensionBindPort, "");
        return attrs;
    }

    /**
     * Interval between successive executions of the task that: - disables an
     * external virtual account when all its accessible shares have been
     * revoked or expired. - deletes an external virtual account after
     * zimbraExternalAccountLifetimeAfterDisabled of being disabled. . Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getExternalAccountStatusCheckIntervalAsString to access value as a string.
     *
     * @see #getExternalAccountStatusCheckIntervalAsString()
     *
     * @return zimbraExternalAccountStatusCheckInterval in millseconds, or -1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1370)
    public long getExternalAccountStatusCheckInterval() {
        return getTimeInterval(Provisioning.A_zimbraExternalAccountStatusCheckInterval, -1L);
    }

    /**
     * Interval between successive executions of the task that: - disables an
     * external virtual account when all its accessible shares have been
     * revoked or expired. - deletes an external virtual account after
     * zimbraExternalAccountLifetimeAfterDisabled of being disabled. . Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraExternalAccountStatusCheckInterval, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1370)
    public String getExternalAccountStatusCheckIntervalAsString() {
        return getAttr(Provisioning.A_zimbraExternalAccountStatusCheckInterval, null);
    }

    /**
     * Interval between successive executions of the task that: - disables an
     * external virtual account when all its accessible shares have been
     * revoked or expired. - deletes an external virtual account after
     * zimbraExternalAccountLifetimeAfterDisabled of being disabled. . Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraExternalAccountStatusCheckInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1370)
    public void setExternalAccountStatusCheckInterval(String zimbraExternalAccountStatusCheckInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountStatusCheckInterval, zimbraExternalAccountStatusCheckInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Interval between successive executions of the task that: - disables an
     * external virtual account when all its accessible shares have been
     * revoked or expired. - deletes an external virtual account after
     * zimbraExternalAccountLifetimeAfterDisabled of being disabled. . Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraExternalAccountStatusCheckInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1370)
    public Map<String,Object> setExternalAccountStatusCheckInterval(String zimbraExternalAccountStatusCheckInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountStatusCheckInterval, zimbraExternalAccountStatusCheckInterval);
        return attrs;
    }

    /**
     * Interval between successive executions of the task that: - disables an
     * external virtual account when all its accessible shares have been
     * revoked or expired. - deletes an external virtual account after
     * zimbraExternalAccountLifetimeAfterDisabled of being disabled. . Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1370)
    public void unsetExternalAccountStatusCheckInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountStatusCheckInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Interval between successive executions of the task that: - disables an
     * external virtual account when all its accessible shares have been
     * revoked or expired. - deletes an external virtual account after
     * zimbraExternalAccountLifetimeAfterDisabled of being disabled. . Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1370)
    public Map<String,Object> unsetExternalAccountStatusCheckInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountStatusCheckInterval, "");
        return attrs;
    }

    /**
     * Maximum size in bytes for file uploads
     *
     * @return zimbraFileUploadMaxSize, or -1 if unset
     */
    @ZAttr(id=227)
    public long getFileUploadMaxSize() {
        return getLongAttr(Provisioning.A_zimbraFileUploadMaxSize, -1L);
    }

    /**
     * Maximum size in bytes for file uploads
     *
     * @param zimbraFileUploadMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=227)
    public void setFileUploadMaxSize(long zimbraFileUploadMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileUploadMaxSize, Long.toString(zimbraFileUploadMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum size in bytes for file uploads
     *
     * @param zimbraFileUploadMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=227)
    public Map<String,Object> setFileUploadMaxSize(long zimbraFileUploadMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileUploadMaxSize, Long.toString(zimbraFileUploadMaxSize));
        return attrs;
    }

    /**
     * Maximum size in bytes for file uploads
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=227)
    public void unsetFileUploadMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileUploadMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum size in bytes for file uploads
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=227)
    public Map<String,Object> unsetFileUploadMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileUploadMaxSize, "");
        return attrs;
    }

    /**
     * Flag for not populating envelope sender when message is redirected by
     * mail filters. See bug 56566
     *
     * @return zimbraFilterNullEnvelopeSenderForDSNRedirect, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1796)
    public boolean isFilterNullEnvelopeSenderForDSNRedirect() {
        return getBooleanAttr(Provisioning.A_zimbraFilterNullEnvelopeSenderForDSNRedirect, false);
    }

    /**
     * Flag for not populating envelope sender when message is redirected by
     * mail filters. See bug 56566
     *
     * @param zimbraFilterNullEnvelopeSenderForDSNRedirect new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1796)
    public void setFilterNullEnvelopeSenderForDSNRedirect(boolean zimbraFilterNullEnvelopeSenderForDSNRedirect) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilterNullEnvelopeSenderForDSNRedirect, zimbraFilterNullEnvelopeSenderForDSNRedirect ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag for not populating envelope sender when message is redirected by
     * mail filters. See bug 56566
     *
     * @param zimbraFilterNullEnvelopeSenderForDSNRedirect new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1796)
    public Map<String,Object> setFilterNullEnvelopeSenderForDSNRedirect(boolean zimbraFilterNullEnvelopeSenderForDSNRedirect, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilterNullEnvelopeSenderForDSNRedirect, zimbraFilterNullEnvelopeSenderForDSNRedirect ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag for not populating envelope sender when message is redirected by
     * mail filters. See bug 56566
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1796)
    public void unsetFilterNullEnvelopeSenderForDSNRedirect() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilterNullEnvelopeSenderForDSNRedirect, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag for not populating envelope sender when message is redirected by
     * mail filters. See bug 56566
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1796)
    public Map<String,Object> unsetFilterNullEnvelopeSenderForDSNRedirect(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilterNullEnvelopeSenderForDSNRedirect, "");
        return attrs;
    }

    /**
     * Flag to disable the listing of interval when you have no data about
     * account&#039;s free busy interval. One example is user doesn&#039;t
     * have the acl to fetch free busy intervals of this account
     *
     * @return zimbraFreeBusyDisableNoDataStatus, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1797)
    public boolean isFreeBusyDisableNoDataStatus() {
        return getBooleanAttr(Provisioning.A_zimbraFreeBusyDisableNoDataStatus, false);
    }

    /**
     * Flag to disable the listing of interval when you have no data about
     * account&#039;s free busy interval. One example is user doesn&#039;t
     * have the acl to fetch free busy intervals of this account
     *
     * @param zimbraFreeBusyDisableNoDataStatus new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1797)
    public void setFreeBusyDisableNoDataStatus(boolean zimbraFreeBusyDisableNoDataStatus) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreeBusyDisableNoDataStatus, zimbraFreeBusyDisableNoDataStatus ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to disable the listing of interval when you have no data about
     * account&#039;s free busy interval. One example is user doesn&#039;t
     * have the acl to fetch free busy intervals of this account
     *
     * @param zimbraFreeBusyDisableNoDataStatus new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1797)
    public Map<String,Object> setFreeBusyDisableNoDataStatus(boolean zimbraFreeBusyDisableNoDataStatus, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreeBusyDisableNoDataStatus, zimbraFreeBusyDisableNoDataStatus ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to disable the listing of interval when you have no data about
     * account&#039;s free busy interval. One example is user doesn&#039;t
     * have the acl to fetch free busy intervals of this account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1797)
    public void unsetFreeBusyDisableNoDataStatus() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreeBusyDisableNoDataStatus, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to disable the listing of interval when you have no data about
     * account&#039;s free busy interval. One example is user doesn&#039;t
     * have the acl to fetch free busy intervals of this account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1797)
    public Map<String,Object> unsetFreeBusyDisableNoDataStatus(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreeBusyDisableNoDataStatus, "");
        return attrs;
    }

    /**
     * The interval to wait when the server encounters problems while
     * propagating Zimbra users free/busy information to external provider
     * such as Exchange. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getFreebusyPropagationRetryIntervalAsString to access value as a string.
     *
     * @see #getFreebusyPropagationRetryIntervalAsString()
     *
     * @return zimbraFreebusyPropagationRetryInterval in millseconds, or -1 if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1026)
    public long getFreebusyPropagationRetryInterval() {
        return getTimeInterval(Provisioning.A_zimbraFreebusyPropagationRetryInterval, -1L);
    }

    /**
     * The interval to wait when the server encounters problems while
     * propagating Zimbra users free/busy information to external provider
     * such as Exchange. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraFreebusyPropagationRetryInterval, or null if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1026)
    public String getFreebusyPropagationRetryIntervalAsString() {
        return getAttr(Provisioning.A_zimbraFreebusyPropagationRetryInterval, null);
    }

    /**
     * The interval to wait when the server encounters problems while
     * propagating Zimbra users free/busy information to external provider
     * such as Exchange. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraFreebusyPropagationRetryInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1026)
    public void setFreebusyPropagationRetryInterval(String zimbraFreebusyPropagationRetryInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyPropagationRetryInterval, zimbraFreebusyPropagationRetryInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The interval to wait when the server encounters problems while
     * propagating Zimbra users free/busy information to external provider
     * such as Exchange. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraFreebusyPropagationRetryInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1026)
    public Map<String,Object> setFreebusyPropagationRetryInterval(String zimbraFreebusyPropagationRetryInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyPropagationRetryInterval, zimbraFreebusyPropagationRetryInterval);
        return attrs;
    }

    /**
     * The interval to wait when the server encounters problems while
     * propagating Zimbra users free/busy information to external provider
     * such as Exchange. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1026)
    public void unsetFreebusyPropagationRetryInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyPropagationRetryInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The interval to wait when the server encounters problems while
     * propagating Zimbra users free/busy information to external provider
     * such as Exchange. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1026)
    public Map<String,Object> unsetFreebusyPropagationRetryInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyPropagationRetryInterval, "");
        return attrs;
    }

    /**
     * Maximum age in minutes of GAL group email addresses in cache.
     * Applicable for a domain only when LDAP domain attribute
     * zimbraGalGroupIndicatorEnabled in TRUE.Default is 7 days
     *
     * @return zimbraGalGroupCacheMaxAge, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1748)
    public int getGalGroupCacheMaxAge() {
        return getIntAttr(Provisioning.A_zimbraGalGroupCacheMaxAge, -1);
    }

    /**
     * Maximum age in minutes of GAL group email addresses in cache.
     * Applicable for a domain only when LDAP domain attribute
     * zimbraGalGroupIndicatorEnabled in TRUE.Default is 7 days
     *
     * @param zimbraGalGroupCacheMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1748)
    public void setGalGroupCacheMaxAge(int zimbraGalGroupCacheMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalGroupCacheMaxAge, Integer.toString(zimbraGalGroupCacheMaxAge));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age in minutes of GAL group email addresses in cache.
     * Applicable for a domain only when LDAP domain attribute
     * zimbraGalGroupIndicatorEnabled in TRUE.Default is 7 days
     *
     * @param zimbraGalGroupCacheMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1748)
    public Map<String,Object> setGalGroupCacheMaxAge(int zimbraGalGroupCacheMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalGroupCacheMaxAge, Integer.toString(zimbraGalGroupCacheMaxAge));
        return attrs;
    }

    /**
     * Maximum age in minutes of GAL group email addresses in cache.
     * Applicable for a domain only when LDAP domain attribute
     * zimbraGalGroupIndicatorEnabled in TRUE.Default is 7 days
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1748)
    public void unsetGalGroupCacheMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalGroupCacheMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age in minutes of GAL group email addresses in cache.
     * Applicable for a domain only when LDAP domain attribute
     * zimbraGalGroupIndicatorEnabled in TRUE.Default is 7 days
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1748)
    public Map<String,Object> unsetGalGroupCacheMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalGroupCacheMaxAge, "");
        return attrs;
    }

    /**
     * Maximum number of domains that can be put into the GAL group cache.
     * Applicable for a domain only when LDAP domain attribute
     * zimbraGalGroupIndicatorEnabled in TRUE.
     *
     * @return zimbraGalGroupCacheMaxSizeDomains, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1749)
    public int getGalGroupCacheMaxSizeDomains() {
        return getIntAttr(Provisioning.A_zimbraGalGroupCacheMaxSizeDomains, -1);
    }

    /**
     * Maximum number of domains that can be put into the GAL group cache.
     * Applicable for a domain only when LDAP domain attribute
     * zimbraGalGroupIndicatorEnabled in TRUE.
     *
     * @param zimbraGalGroupCacheMaxSizeDomains new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1749)
    public void setGalGroupCacheMaxSizeDomains(int zimbraGalGroupCacheMaxSizeDomains) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalGroupCacheMaxSizeDomains, Integer.toString(zimbraGalGroupCacheMaxSizeDomains));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of domains that can be put into the GAL group cache.
     * Applicable for a domain only when LDAP domain attribute
     * zimbraGalGroupIndicatorEnabled in TRUE.
     *
     * @param zimbraGalGroupCacheMaxSizeDomains new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1749)
    public Map<String,Object> setGalGroupCacheMaxSizeDomains(int zimbraGalGroupCacheMaxSizeDomains, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalGroupCacheMaxSizeDomains, Integer.toString(zimbraGalGroupCacheMaxSizeDomains));
        return attrs;
    }

    /**
     * Maximum number of domains that can be put into the GAL group cache.
     * Applicable for a domain only when LDAP domain attribute
     * zimbraGalGroupIndicatorEnabled in TRUE.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1749)
    public void unsetGalGroupCacheMaxSizeDomains() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalGroupCacheMaxSizeDomains, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of domains that can be put into the GAL group cache.
     * Applicable for a domain only when LDAP domain attribute
     * zimbraGalGroupIndicatorEnabled in TRUE.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1749)
    public Map<String,Object> unsetGalGroupCacheMaxSizeDomains(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalGroupCacheMaxSizeDomains, "");
        return attrs;
    }

    /**
     * Maximum number of GAL group email addresses cached per domain.
     * Applicable for a domain only when LDAP domain attribute
     * zimbraGalGroupIndicatorEnabled in TRUE.
     *
     * @return zimbraGalGroupCacheMaxSizePerDomain, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1750)
    public int getGalGroupCacheMaxSizePerDomain() {
        return getIntAttr(Provisioning.A_zimbraGalGroupCacheMaxSizePerDomain, -1);
    }

    /**
     * Maximum number of GAL group email addresses cached per domain.
     * Applicable for a domain only when LDAP domain attribute
     * zimbraGalGroupIndicatorEnabled in TRUE.
     *
     * @param zimbraGalGroupCacheMaxSizePerDomain new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1750)
    public void setGalGroupCacheMaxSizePerDomain(int zimbraGalGroupCacheMaxSizePerDomain) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalGroupCacheMaxSizePerDomain, Integer.toString(zimbraGalGroupCacheMaxSizePerDomain));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of GAL group email addresses cached per domain.
     * Applicable for a domain only when LDAP domain attribute
     * zimbraGalGroupIndicatorEnabled in TRUE.
     *
     * @param zimbraGalGroupCacheMaxSizePerDomain new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1750)
    public Map<String,Object> setGalGroupCacheMaxSizePerDomain(int zimbraGalGroupCacheMaxSizePerDomain, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalGroupCacheMaxSizePerDomain, Integer.toString(zimbraGalGroupCacheMaxSizePerDomain));
        return attrs;
    }

    /**
     * Maximum number of GAL group email addresses cached per domain.
     * Applicable for a domain only when LDAP domain attribute
     * zimbraGalGroupIndicatorEnabled in TRUE.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1750)
    public void unsetGalGroupCacheMaxSizePerDomain() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalGroupCacheMaxSizePerDomain, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of GAL group email addresses cached per domain.
     * Applicable for a domain only when LDAP domain attribute
     * zimbraGalGroupIndicatorEnabled in TRUE.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1750)
    public Map<String,Object> unsetGalGroupCacheMaxSizePerDomain(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalGroupCacheMaxSizePerDomain, "");
        return attrs;
    }

    /**
     * Flag to disable the gal sync timeout
     *
     * @return zimbraGalSyncConnectionDisableTimeout, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1845)
    public boolean isGalSyncConnectionDisableTimeout() {
        return getBooleanAttr(Provisioning.A_zimbraGalSyncConnectionDisableTimeout, false);
    }

    /**
     * Flag to disable the gal sync timeout
     *
     * @param zimbraGalSyncConnectionDisableTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1845)
    public void setGalSyncConnectionDisableTimeout(boolean zimbraGalSyncConnectionDisableTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncConnectionDisableTimeout, zimbraGalSyncConnectionDisableTimeout ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to disable the gal sync timeout
     *
     * @param zimbraGalSyncConnectionDisableTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1845)
    public Map<String,Object> setGalSyncConnectionDisableTimeout(boolean zimbraGalSyncConnectionDisableTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncConnectionDisableTimeout, zimbraGalSyncConnectionDisableTimeout ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to disable the gal sync timeout
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1845)
    public void unsetGalSyncConnectionDisableTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncConnectionDisableTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to disable the gal sync timeout
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1845)
    public Map<String,Object> unsetGalSyncConnectionDisableTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncConnectionDisableTimeout, "");
        return attrs;
    }

    /**
     * Sets the maximum galsync mailbox contact item cache.Set value to at
     * least the number of contact items in the galsync mailbox.
     *
     * @return zimbraGalSyncMailboxMailItemCache, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1852)
    public int getGalSyncMailboxMailItemCache() {
        return getIntAttr(Provisioning.A_zimbraGalSyncMailboxMailItemCache, -1);
    }

    /**
     * Sets the maximum galsync mailbox contact item cache.Set value to at
     * least the number of contact items in the galsync mailbox.
     *
     * @param zimbraGalSyncMailboxMailItemCache new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1852)
    public void setGalSyncMailboxMailItemCache(int zimbraGalSyncMailboxMailItemCache) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncMailboxMailItemCache, Integer.toString(zimbraGalSyncMailboxMailItemCache));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sets the maximum galsync mailbox contact item cache.Set value to at
     * least the number of contact items in the galsync mailbox.
     *
     * @param zimbraGalSyncMailboxMailItemCache new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1852)
    public Map<String,Object> setGalSyncMailboxMailItemCache(int zimbraGalSyncMailboxMailItemCache, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncMailboxMailItemCache, Integer.toString(zimbraGalSyncMailboxMailItemCache));
        return attrs;
    }

    /**
     * Sets the maximum galsync mailbox contact item cache.Set value to at
     * least the number of contact items in the galsync mailbox.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1852)
    public void unsetGalSyncMailboxMailItemCache() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncMailboxMailItemCache, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sets the maximum galsync mailbox contact item cache.Set value to at
     * least the number of contact items in the galsync mailbox.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1852)
    public Map<String,Object> unsetGalSyncMailboxMailItemCache(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncMailboxMailItemCache, "");
        return attrs;
    }

    /**
     * Maximum number of items to move during a single HSM operation. If the
     * limit is exceeded, the HSM operation is repeated until all qualifying
     * items are moved.
     *
     * @return zimbraHsmBatchSize, or -1 if unset
     *
     * @since ZCS 7.2.1
     */
    @ZAttr(id=1316)
    public int getHsmBatchSize() {
        return getIntAttr(Provisioning.A_zimbraHsmBatchSize, -1);
    }

    /**
     * Maximum number of items to move during a single HSM operation. If the
     * limit is exceeded, the HSM operation is repeated until all qualifying
     * items are moved.
     *
     * @param zimbraHsmBatchSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.1
     */
    @ZAttr(id=1316)
    public void setHsmBatchSize(int zimbraHsmBatchSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmBatchSize, Integer.toString(zimbraHsmBatchSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of items to move during a single HSM operation. If the
     * limit is exceeded, the HSM operation is repeated until all qualifying
     * items are moved.
     *
     * @param zimbraHsmBatchSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.1
     */
    @ZAttr(id=1316)
    public Map<String,Object> setHsmBatchSize(int zimbraHsmBatchSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmBatchSize, Integer.toString(zimbraHsmBatchSize));
        return attrs;
    }

    /**
     * Maximum number of items to move during a single HSM operation. If the
     * limit is exceeded, the HSM operation is repeated until all qualifying
     * items are moved.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.1
     */
    @ZAttr(id=1316)
    public void unsetHsmBatchSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmBatchSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of items to move during a single HSM operation. If the
     * limit is exceeded, the HSM operation is repeated until all qualifying
     * items are moved.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.1
     */
    @ZAttr(id=1316)
    public Map<String,Object> unsetHsmBatchSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmBatchSize, "");
        return attrs;
    }

    /**
     * Keep only the tip revision in the main volume, and move all the old
     * revisions to the secondary volume. For document type mail items only,
     * works independently of zimbraHsmPolicy.
     *
     * @return zimbraHsmMovePreviousRevisions, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1393)
    public boolean isHsmMovePreviousRevisions() {
        return getBooleanAttr(Provisioning.A_zimbraHsmMovePreviousRevisions, false);
    }

    /**
     * Keep only the tip revision in the main volume, and move all the old
     * revisions to the secondary volume. For document type mail items only,
     * works independently of zimbraHsmPolicy.
     *
     * @param zimbraHsmMovePreviousRevisions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1393)
    public void setHsmMovePreviousRevisions(boolean zimbraHsmMovePreviousRevisions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmMovePreviousRevisions, zimbraHsmMovePreviousRevisions ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Keep only the tip revision in the main volume, and move all the old
     * revisions to the secondary volume. For document type mail items only,
     * works independently of zimbraHsmPolicy.
     *
     * @param zimbraHsmMovePreviousRevisions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1393)
    public Map<String,Object> setHsmMovePreviousRevisions(boolean zimbraHsmMovePreviousRevisions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmMovePreviousRevisions, zimbraHsmMovePreviousRevisions ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Keep only the tip revision in the main volume, and move all the old
     * revisions to the secondary volume. For document type mail items only,
     * works independently of zimbraHsmPolicy.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1393)
    public void unsetHsmMovePreviousRevisions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmMovePreviousRevisions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Keep only the tip revision in the main volume, and move all the old
     * revisions to the secondary volume. For document type mail items only,
     * works independently of zimbraHsmPolicy.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1393)
    public Map<String,Object> unsetHsmMovePreviousRevisions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmMovePreviousRevisions, "");
        return attrs;
    }

    /**
     * The policy that determines which mail items get moved to secondary
     * storage during HSM. Each value specifies a comma-separated list of
     * item types and the search query used to select items to move. See the
     * spec for &lt;SearchRequest&gt; for the complete list of item types and
     * query.txt for the search query spec.
     *
     * @return zimbraHsmPolicy, or empty array if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1024)
    public String[] getHsmPolicy() {
        return getMultiAttr(Provisioning.A_zimbraHsmPolicy);
    }

    /**
     * The policy that determines which mail items get moved to secondary
     * storage during HSM. Each value specifies a comma-separated list of
     * item types and the search query used to select items to move. See the
     * spec for &lt;SearchRequest&gt; for the complete list of item types and
     * query.txt for the search query spec.
     *
     * @param zimbraHsmPolicy new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1024)
    public void setHsmPolicy(String[] zimbraHsmPolicy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmPolicy, zimbraHsmPolicy);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The policy that determines which mail items get moved to secondary
     * storage during HSM. Each value specifies a comma-separated list of
     * item types and the search query used to select items to move. See the
     * spec for &lt;SearchRequest&gt; for the complete list of item types and
     * query.txt for the search query spec.
     *
     * @param zimbraHsmPolicy new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1024)
    public Map<String,Object> setHsmPolicy(String[] zimbraHsmPolicy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmPolicy, zimbraHsmPolicy);
        return attrs;
    }

    /**
     * The policy that determines which mail items get moved to secondary
     * storage during HSM. Each value specifies a comma-separated list of
     * item types and the search query used to select items to move. See the
     * spec for &lt;SearchRequest&gt; for the complete list of item types and
     * query.txt for the search query spec.
     *
     * @param zimbraHsmPolicy new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1024)
    public void addHsmPolicy(String zimbraHsmPolicy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraHsmPolicy, zimbraHsmPolicy);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The policy that determines which mail items get moved to secondary
     * storage during HSM. Each value specifies a comma-separated list of
     * item types and the search query used to select items to move. See the
     * spec for &lt;SearchRequest&gt; for the complete list of item types and
     * query.txt for the search query spec.
     *
     * @param zimbraHsmPolicy new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1024)
    public Map<String,Object> addHsmPolicy(String zimbraHsmPolicy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraHsmPolicy, zimbraHsmPolicy);
        return attrs;
    }

    /**
     * The policy that determines which mail items get moved to secondary
     * storage during HSM. Each value specifies a comma-separated list of
     * item types and the search query used to select items to move. See the
     * spec for &lt;SearchRequest&gt; for the complete list of item types and
     * query.txt for the search query spec.
     *
     * @param zimbraHsmPolicy existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1024)
    public void removeHsmPolicy(String zimbraHsmPolicy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraHsmPolicy, zimbraHsmPolicy);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The policy that determines which mail items get moved to secondary
     * storage during HSM. Each value specifies a comma-separated list of
     * item types and the search query used to select items to move. See the
     * spec for &lt;SearchRequest&gt; for the complete list of item types and
     * query.txt for the search query spec.
     *
     * @param zimbraHsmPolicy existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1024)
    public Map<String,Object> removeHsmPolicy(String zimbraHsmPolicy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraHsmPolicy, zimbraHsmPolicy);
        return attrs;
    }

    /**
     * The policy that determines which mail items get moved to secondary
     * storage during HSM. Each value specifies a comma-separated list of
     * item types and the search query used to select items to move. See the
     * spec for &lt;SearchRequest&gt; for the complete list of item types and
     * query.txt for the search query spec.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1024)
    public void unsetHsmPolicy() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmPolicy, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The policy that determines which mail items get moved to secondary
     * storage during HSM. Each value specifies a comma-separated list of
     * item types and the search query used to select items to move. See the
     * spec for &lt;SearchRequest&gt; for the complete list of item types and
     * query.txt for the search query spec.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1024)
    public Map<String,Object> unsetHsmPolicy(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmPolicy, "");
        return attrs;
    }

    /**
     * Whether or not to enable HTTP compression. Defaults to true.
     *
     * @return zimbraHttpCompressionEnabled, or false if unset
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1467)
    public boolean isHttpCompressionEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraHttpCompressionEnabled, false);
    }

    /**
     * Whether or not to enable HTTP compression. Defaults to true.
     *
     * @param zimbraHttpCompressionEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1467)
    public void setHttpCompressionEnabled(boolean zimbraHttpCompressionEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpCompressionEnabled, zimbraHttpCompressionEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable HTTP compression. Defaults to true.
     *
     * @param zimbraHttpCompressionEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1467)
    public Map<String,Object> setHttpCompressionEnabled(boolean zimbraHttpCompressionEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpCompressionEnabled, zimbraHttpCompressionEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether or not to enable HTTP compression. Defaults to true.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1467)
    public void unsetHttpCompressionEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpCompressionEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable HTTP compression. Defaults to true.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1467)
    public Map<String,Object> unsetHttpCompressionEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpCompressionEnabled, "");
        return attrs;
    }

    /**
     * Maximum Idle time in milli seconds for a connection. This is applied
     * when waiting for a new request to be received on a connection; when
     * reading the headers and content of a request; when writing the headers
     * and content of a response.
     *
     * @return zimbraHttpConnectorMaxIdleTimeMillis, or -1 if unset
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1428)
    public int getHttpConnectorMaxIdleTimeMillis() {
        return getIntAttr(Provisioning.A_zimbraHttpConnectorMaxIdleTimeMillis, -1);
    }

    /**
     * Maximum Idle time in milli seconds for a connection. This is applied
     * when waiting for a new request to be received on a connection; when
     * reading the headers and content of a request; when writing the headers
     * and content of a response.
     *
     * @param zimbraHttpConnectorMaxIdleTimeMillis new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1428)
    public void setHttpConnectorMaxIdleTimeMillis(int zimbraHttpConnectorMaxIdleTimeMillis) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpConnectorMaxIdleTimeMillis, Integer.toString(zimbraHttpConnectorMaxIdleTimeMillis));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum Idle time in milli seconds for a connection. This is applied
     * when waiting for a new request to be received on a connection; when
     * reading the headers and content of a request; when writing the headers
     * and content of a response.
     *
     * @param zimbraHttpConnectorMaxIdleTimeMillis new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1428)
    public Map<String,Object> setHttpConnectorMaxIdleTimeMillis(int zimbraHttpConnectorMaxIdleTimeMillis, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpConnectorMaxIdleTimeMillis, Integer.toString(zimbraHttpConnectorMaxIdleTimeMillis));
        return attrs;
    }

    /**
     * Maximum Idle time in milli seconds for a connection. This is applied
     * when waiting for a new request to be received on a connection; when
     * reading the headers and content of a request; when writing the headers
     * and content of a response.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1428)
    public void unsetHttpConnectorMaxIdleTimeMillis() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpConnectorMaxIdleTimeMillis, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum Idle time in milli seconds for a connection. This is applied
     * when waiting for a new request to be received on a connection; when
     * reading the headers and content of a request; when writing the headers
     * and content of a response.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1428)
    public Map<String,Object> unsetHttpConnectorMaxIdleTimeMillis(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpConnectorMaxIdleTimeMillis, "");
        return attrs;
    }

    /**
     * Rules for governing the allocation of threads to various web contexts
     * for the current thread pool. Sample value: /zimbra:min=10;max=40% or
     * /zimbraAdmin:min=5
     *
     * @return zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1593)
    public String[] getHttpContextPathBasedThreadPoolBalancingFilterRules() {
        return getMultiAttr(Provisioning.A_zimbraHttpContextPathBasedThreadPoolBalancingFilterRules);
    }

    /**
     * Rules for governing the allocation of threads to various web contexts
     * for the current thread pool. Sample value: /zimbra:min=10;max=40% or
     * /zimbraAdmin:min=5
     *
     * @param zimbraHttpContextPathBasedThreadPoolBalancingFilterRules new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1593)
    public void setHttpContextPathBasedThreadPoolBalancingFilterRules(String[] zimbraHttpContextPathBasedThreadPoolBalancingFilterRules) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, zimbraHttpContextPathBasedThreadPoolBalancingFilterRules);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Rules for governing the allocation of threads to various web contexts
     * for the current thread pool. Sample value: /zimbra:min=10;max=40% or
     * /zimbraAdmin:min=5
     *
     * @param zimbraHttpContextPathBasedThreadPoolBalancingFilterRules new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1593)
    public Map<String,Object> setHttpContextPathBasedThreadPoolBalancingFilterRules(String[] zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, zimbraHttpContextPathBasedThreadPoolBalancingFilterRules);
        return attrs;
    }

    /**
     * Rules for governing the allocation of threads to various web contexts
     * for the current thread pool. Sample value: /zimbra:min=10;max=40% or
     * /zimbraAdmin:min=5
     *
     * @param zimbraHttpContextPathBasedThreadPoolBalancingFilterRules new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1593)
    public void addHttpContextPathBasedThreadPoolBalancingFilterRules(String zimbraHttpContextPathBasedThreadPoolBalancingFilterRules) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, zimbraHttpContextPathBasedThreadPoolBalancingFilterRules);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Rules for governing the allocation of threads to various web contexts
     * for the current thread pool. Sample value: /zimbra:min=10;max=40% or
     * /zimbraAdmin:min=5
     *
     * @param zimbraHttpContextPathBasedThreadPoolBalancingFilterRules new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1593)
    public Map<String,Object> addHttpContextPathBasedThreadPoolBalancingFilterRules(String zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, zimbraHttpContextPathBasedThreadPoolBalancingFilterRules);
        return attrs;
    }

    /**
     * Rules for governing the allocation of threads to various web contexts
     * for the current thread pool. Sample value: /zimbra:min=10;max=40% or
     * /zimbraAdmin:min=5
     *
     * @param zimbraHttpContextPathBasedThreadPoolBalancingFilterRules existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1593)
    public void removeHttpContextPathBasedThreadPoolBalancingFilterRules(String zimbraHttpContextPathBasedThreadPoolBalancingFilterRules) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, zimbraHttpContextPathBasedThreadPoolBalancingFilterRules);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Rules for governing the allocation of threads to various web contexts
     * for the current thread pool. Sample value: /zimbra:min=10;max=40% or
     * /zimbraAdmin:min=5
     *
     * @param zimbraHttpContextPathBasedThreadPoolBalancingFilterRules existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1593)
    public Map<String,Object> removeHttpContextPathBasedThreadPoolBalancingFilterRules(String zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, zimbraHttpContextPathBasedThreadPoolBalancingFilterRules);
        return attrs;
    }

    /**
     * Rules for governing the allocation of threads to various web contexts
     * for the current thread pool. Sample value: /zimbra:min=10;max=40% or
     * /zimbraAdmin:min=5
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1593)
    public void unsetHttpContextPathBasedThreadPoolBalancingFilterRules() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Rules for governing the allocation of threads to various web contexts
     * for the current thread pool. Sample value: /zimbra:min=10;max=40% or
     * /zimbraAdmin:min=5
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1593)
    public Map<String,Object> unsetHttpContextPathBasedThreadPoolBalancingFilterRules(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, "");
        return attrs;
    }

    /**
     * Whether to enable http debug handler on a server
     *
     * @return zimbraHttpDebugHandlerEnabled, or false if unset
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1043)
    public boolean isHttpDebugHandlerEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraHttpDebugHandlerEnabled, false);
    }

    /**
     * Whether to enable http debug handler on a server
     *
     * @param zimbraHttpDebugHandlerEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1043)
    public void setHttpDebugHandlerEnabled(boolean zimbraHttpDebugHandlerEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDebugHandlerEnabled, zimbraHttpDebugHandlerEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable http debug handler on a server
     *
     * @param zimbraHttpDebugHandlerEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1043)
    public Map<String,Object> setHttpDebugHandlerEnabled(boolean zimbraHttpDebugHandlerEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDebugHandlerEnabled, zimbraHttpDebugHandlerEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether to enable http debug handler on a server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1043)
    public void unsetHttpDebugHandlerEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDebugHandlerEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable http debug handler on a server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1043)
    public Map<String,Object> unsetHttpDebugHandlerEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDebugHandlerEnabled, "");
        return attrs;
    }

    /**
     * Delay imposed on all requests over the rate limit, before they are
     * considered at all. -1 = Reject request, 0 = No delay, any other value
     * = Delay in ms
     *
     * @return zimbraHttpDosFilterDelayMillis, or -1 if unset
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1430)
    public int getHttpDosFilterDelayMillis() {
        return getIntAttr(Provisioning.A_zimbraHttpDosFilterDelayMillis, -1);
    }

    /**
     * Delay imposed on all requests over the rate limit, before they are
     * considered at all. -1 = Reject request, 0 = No delay, any other value
     * = Delay in ms
     *
     * @param zimbraHttpDosFilterDelayMillis new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1430)
    public void setHttpDosFilterDelayMillis(int zimbraHttpDosFilterDelayMillis) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDosFilterDelayMillis, Integer.toString(zimbraHttpDosFilterDelayMillis));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Delay imposed on all requests over the rate limit, before they are
     * considered at all. -1 = Reject request, 0 = No delay, any other value
     * = Delay in ms
     *
     * @param zimbraHttpDosFilterDelayMillis new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1430)
    public Map<String,Object> setHttpDosFilterDelayMillis(int zimbraHttpDosFilterDelayMillis, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDosFilterDelayMillis, Integer.toString(zimbraHttpDosFilterDelayMillis));
        return attrs;
    }

    /**
     * Delay imposed on all requests over the rate limit, before they are
     * considered at all. -1 = Reject request, 0 = No delay, any other value
     * = Delay in ms
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1430)
    public void unsetHttpDosFilterDelayMillis() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDosFilterDelayMillis, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Delay imposed on all requests over the rate limit, before they are
     * considered at all. -1 = Reject request, 0 = No delay, any other value
     * = Delay in ms
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1430)
    public Map<String,Object> unsetHttpDosFilterDelayMillis(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDosFilterDelayMillis, "");
        return attrs;
    }

    /**
     * Maximum number of requests from a connection per second. Requests in
     * excess of this are throttled.
     *
     * @return zimbraHttpDosFilterMaxRequestsPerSec, or -1 if unset
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1431)
    public int getHttpDosFilterMaxRequestsPerSec() {
        return getIntAttr(Provisioning.A_zimbraHttpDosFilterMaxRequestsPerSec, -1);
    }

    /**
     * Maximum number of requests from a connection per second. Requests in
     * excess of this are throttled.
     *
     * @param zimbraHttpDosFilterMaxRequestsPerSec new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1431)
    public void setHttpDosFilterMaxRequestsPerSec(int zimbraHttpDosFilterMaxRequestsPerSec) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDosFilterMaxRequestsPerSec, Integer.toString(zimbraHttpDosFilterMaxRequestsPerSec));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of requests from a connection per second. Requests in
     * excess of this are throttled.
     *
     * @param zimbraHttpDosFilterMaxRequestsPerSec new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1431)
    public Map<String,Object> setHttpDosFilterMaxRequestsPerSec(int zimbraHttpDosFilterMaxRequestsPerSec, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDosFilterMaxRequestsPerSec, Integer.toString(zimbraHttpDosFilterMaxRequestsPerSec));
        return attrs;
    }

    /**
     * Maximum number of requests from a connection per second. Requests in
     * excess of this are throttled.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1431)
    public void unsetHttpDosFilterMaxRequestsPerSec() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDosFilterMaxRequestsPerSec, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of requests from a connection per second. Requests in
     * excess of this are throttled.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1431)
    public Map<String,Object> unsetHttpDosFilterMaxRequestsPerSec(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDosFilterMaxRequestsPerSec, "");
        return attrs;
    }

    /**
     * The maximum allowed size in bytes for a HTTP header field cache in
     * Jetty
     *
     * @return zimbraHttpHeaderCacheSize, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1582)
    public int getHttpHeaderCacheSize() {
        return getIntAttr(Provisioning.A_zimbraHttpHeaderCacheSize, -1);
    }

    /**
     * The maximum allowed size in bytes for a HTTP header field cache in
     * Jetty
     *
     * @param zimbraHttpHeaderCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1582)
    public void setHttpHeaderCacheSize(int zimbraHttpHeaderCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpHeaderCacheSize, Integer.toString(zimbraHttpHeaderCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum allowed size in bytes for a HTTP header field cache in
     * Jetty
     *
     * @param zimbraHttpHeaderCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1582)
    public Map<String,Object> setHttpHeaderCacheSize(int zimbraHttpHeaderCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpHeaderCacheSize, Integer.toString(zimbraHttpHeaderCacheSize));
        return attrs;
    }

    /**
     * The maximum allowed size in bytes for a HTTP header field cache in
     * Jetty
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1582)
    public void unsetHttpHeaderCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpHeaderCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum allowed size in bytes for a HTTP header field cache in
     * Jetty
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1582)
    public Map<String,Object> unsetHttpHeaderCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpHeaderCacheSize, "");
        return attrs;
    }

    /**
     * The maximum allowed size in bytes for a HTTP form content in Jetty.
     * Can be set to 0 to block all web form submission
     *
     * @return zimbraHttpMaxFormContentSize, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1612)
    public int getHttpMaxFormContentSize() {
        return getIntAttr(Provisioning.A_zimbraHttpMaxFormContentSize, -1);
    }

    /**
     * The maximum allowed size in bytes for a HTTP form content in Jetty.
     * Can be set to 0 to block all web form submission
     *
     * @param zimbraHttpMaxFormContentSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1612)
    public void setHttpMaxFormContentSize(int zimbraHttpMaxFormContentSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpMaxFormContentSize, Integer.toString(zimbraHttpMaxFormContentSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum allowed size in bytes for a HTTP form content in Jetty.
     * Can be set to 0 to block all web form submission
     *
     * @param zimbraHttpMaxFormContentSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1612)
    public Map<String,Object> setHttpMaxFormContentSize(int zimbraHttpMaxFormContentSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpMaxFormContentSize, Integer.toString(zimbraHttpMaxFormContentSize));
        return attrs;
    }

    /**
     * The maximum allowed size in bytes for a HTTP form content in Jetty.
     * Can be set to 0 to block all web form submission
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1612)
    public void unsetHttpMaxFormContentSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpMaxFormContentSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum allowed size in bytes for a HTTP form content in Jetty.
     * Can be set to 0 to block all web form submission
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1612)
    public Map<String,Object> unsetHttpMaxFormContentSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpMaxFormContentSize, "");
        return attrs;
    }

    /**
     * number of http handler threads
     *
     * @return zimbraHttpNumThreads, or -1 if unset
     */
    @ZAttr(id=518)
    public int getHttpNumThreads() {
        return getIntAttr(Provisioning.A_zimbraHttpNumThreads, -1);
    }

    /**
     * number of http handler threads
     *
     * @param zimbraHttpNumThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=518)
    public void setHttpNumThreads(int zimbraHttpNumThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpNumThreads, Integer.toString(zimbraHttpNumThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of http handler threads
     *
     * @param zimbraHttpNumThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=518)
    public Map<String,Object> setHttpNumThreads(int zimbraHttpNumThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpNumThreads, Integer.toString(zimbraHttpNumThreads));
        return attrs;
    }

    /**
     * number of http handler threads
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=518)
    public void unsetHttpNumThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpNumThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of http handler threads
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=518)
    public Map<String,Object> unsetHttpNumThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpNumThreads, "");
        return attrs;
    }

    /**
     * The size in bytes of the output buffer used to aggregate HTTP output
     * in Jetty
     *
     * @return zimbraHttpOutputBufferSize, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1579)
    public int getHttpOutputBufferSize() {
        return getIntAttr(Provisioning.A_zimbraHttpOutputBufferSize, -1);
    }

    /**
     * The size in bytes of the output buffer used to aggregate HTTP output
     * in Jetty
     *
     * @param zimbraHttpOutputBufferSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1579)
    public void setHttpOutputBufferSize(int zimbraHttpOutputBufferSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpOutputBufferSize, Integer.toString(zimbraHttpOutputBufferSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The size in bytes of the output buffer used to aggregate HTTP output
     * in Jetty
     *
     * @param zimbraHttpOutputBufferSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1579)
    public Map<String,Object> setHttpOutputBufferSize(int zimbraHttpOutputBufferSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpOutputBufferSize, Integer.toString(zimbraHttpOutputBufferSize));
        return attrs;
    }

    /**
     * The size in bytes of the output buffer used to aggregate HTTP output
     * in Jetty
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1579)
    public void unsetHttpOutputBufferSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpOutputBufferSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The size in bytes of the output buffer used to aggregate HTTP output
     * in Jetty
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1579)
    public Map<String,Object> unsetHttpOutputBufferSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpOutputBufferSize, "");
        return attrs;
    }

    /**
     * external socks proxy URL to connect to when making outgoing
     * connections (eg.Zimlet proxy, RSS/ATOM feeds, etc)
     *
     * @return zimbraHttpProxyURL, or empty array if unset
     */
    @ZAttr(id=388)
    public String[] getHttpProxyURL() {
        return getMultiAttr(Provisioning.A_zimbraHttpProxyURL);
    }

    /**
     * external socks proxy URL to connect to when making outgoing
     * connections (eg.Zimlet proxy, RSS/ATOM feeds, etc)
     *
     * @param zimbraHttpProxyURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=388)
    public void setHttpProxyURL(String[] zimbraHttpProxyURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpProxyURL, zimbraHttpProxyURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external socks proxy URL to connect to when making outgoing
     * connections (eg.Zimlet proxy, RSS/ATOM feeds, etc)
     *
     * @param zimbraHttpProxyURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=388)
    public Map<String,Object> setHttpProxyURL(String[] zimbraHttpProxyURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpProxyURL, zimbraHttpProxyURL);
        return attrs;
    }

    /**
     * external socks proxy URL to connect to when making outgoing
     * connections (eg.Zimlet proxy, RSS/ATOM feeds, etc)
     *
     * @param zimbraHttpProxyURL new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=388)
    public void addHttpProxyURL(String zimbraHttpProxyURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraHttpProxyURL, zimbraHttpProxyURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external socks proxy URL to connect to when making outgoing
     * connections (eg.Zimlet proxy, RSS/ATOM feeds, etc)
     *
     * @param zimbraHttpProxyURL new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=388)
    public Map<String,Object> addHttpProxyURL(String zimbraHttpProxyURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraHttpProxyURL, zimbraHttpProxyURL);
        return attrs;
    }

    /**
     * external socks proxy URL to connect to when making outgoing
     * connections (eg.Zimlet proxy, RSS/ATOM feeds, etc)
     *
     * @param zimbraHttpProxyURL existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=388)
    public void removeHttpProxyURL(String zimbraHttpProxyURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraHttpProxyURL, zimbraHttpProxyURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external socks proxy URL to connect to when making outgoing
     * connections (eg.Zimlet proxy, RSS/ATOM feeds, etc)
     *
     * @param zimbraHttpProxyURL existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=388)
    public Map<String,Object> removeHttpProxyURL(String zimbraHttpProxyURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraHttpProxyURL, zimbraHttpProxyURL);
        return attrs;
    }

    /**
     * external socks proxy URL to connect to when making outgoing
     * connections (eg.Zimlet proxy, RSS/ATOM feeds, etc)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=388)
    public void unsetHttpProxyURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpProxyURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external socks proxy URL to connect to when making outgoing
     * connections (eg.Zimlet proxy, RSS/ATOM feeds, etc)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=388)
    public Map<String,Object> unsetHttpProxyURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpProxyURL, "");
        return attrs;
    }

    /**
     * The maximum allowed size in bytes for a HTTP response header in Jetty
     *
     * @return zimbraHttpResponseHeaderSize, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1581)
    public int getHttpResponseHeaderSize() {
        return getIntAttr(Provisioning.A_zimbraHttpResponseHeaderSize, -1);
    }

    /**
     * The maximum allowed size in bytes for a HTTP response header in Jetty
     *
     * @param zimbraHttpResponseHeaderSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1581)
    public void setHttpResponseHeaderSize(int zimbraHttpResponseHeaderSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpResponseHeaderSize, Integer.toString(zimbraHttpResponseHeaderSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum allowed size in bytes for a HTTP response header in Jetty
     *
     * @param zimbraHttpResponseHeaderSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1581)
    public Map<String,Object> setHttpResponseHeaderSize(int zimbraHttpResponseHeaderSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpResponseHeaderSize, Integer.toString(zimbraHttpResponseHeaderSize));
        return attrs;
    }

    /**
     * The maximum allowed size in bytes for a HTTP response header in Jetty
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1581)
    public void unsetHttpResponseHeaderSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpResponseHeaderSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum allowed size in bytes for a HTTP response header in Jetty
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1581)
    public Map<String,Object> unsetHttpResponseHeaderSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpResponseHeaderSize, "");
        return attrs;
    }

    /**
     * Deprecated since: 5.0. not applicable for jetty. Orig desc: number of
     * https handler threads
     *
     * @return zimbraHttpSSLNumThreads, or -1 if unset
     */
    @ZAttr(id=519)
    public int getHttpSSLNumThreads() {
        return getIntAttr(Provisioning.A_zimbraHttpSSLNumThreads, -1);
    }

    /**
     * Deprecated since: 5.0. not applicable for jetty. Orig desc: number of
     * https handler threads
     *
     * @param zimbraHttpSSLNumThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=519)
    public void setHttpSSLNumThreads(int zimbraHttpSSLNumThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpSSLNumThreads, Integer.toString(zimbraHttpSSLNumThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. not applicable for jetty. Orig desc: number of
     * https handler threads
     *
     * @param zimbraHttpSSLNumThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=519)
    public Map<String,Object> setHttpSSLNumThreads(int zimbraHttpSSLNumThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpSSLNumThreads, Integer.toString(zimbraHttpSSLNumThreads));
        return attrs;
    }

    /**
     * Deprecated since: 5.0. not applicable for jetty. Orig desc: number of
     * https handler threads
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=519)
    public void unsetHttpSSLNumThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpSSLNumThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. not applicable for jetty. Orig desc: number of
     * https handler threads
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=519)
    public Map<String,Object> unsetHttpSSLNumThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpSSLNumThreads, "");
        return attrs;
    }

    /**
     * The maximum thread idle time in milli seconds. Threads that are idle
     * for longer than this period may be stopped.
     *
     * @return zimbraHttpThreadPoolMaxIdleTimeMillis, or -1 if unset
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1429)
    public int getHttpThreadPoolMaxIdleTimeMillis() {
        return getIntAttr(Provisioning.A_zimbraHttpThreadPoolMaxIdleTimeMillis, -1);
    }

    /**
     * The maximum thread idle time in milli seconds. Threads that are idle
     * for longer than this period may be stopped.
     *
     * @param zimbraHttpThreadPoolMaxIdleTimeMillis new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1429)
    public void setHttpThreadPoolMaxIdleTimeMillis(int zimbraHttpThreadPoolMaxIdleTimeMillis) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpThreadPoolMaxIdleTimeMillis, Integer.toString(zimbraHttpThreadPoolMaxIdleTimeMillis));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum thread idle time in milli seconds. Threads that are idle
     * for longer than this period may be stopped.
     *
     * @param zimbraHttpThreadPoolMaxIdleTimeMillis new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1429)
    public Map<String,Object> setHttpThreadPoolMaxIdleTimeMillis(int zimbraHttpThreadPoolMaxIdleTimeMillis, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpThreadPoolMaxIdleTimeMillis, Integer.toString(zimbraHttpThreadPoolMaxIdleTimeMillis));
        return attrs;
    }

    /**
     * The maximum thread idle time in milli seconds. Threads that are idle
     * for longer than this period may be stopped.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1429)
    public void unsetHttpThreadPoolMaxIdleTimeMillis() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpThreadPoolMaxIdleTimeMillis, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum thread idle time in milli seconds. Threads that are idle
     * for longer than this period may be stopped.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1429)
    public Map<String,Object> unsetHttpThreadPoolMaxIdleTimeMillis(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpThreadPoolMaxIdleTimeMillis, "");
        return attrs;
    }

    /**
     * IP addresses to ignore when applying Jetty DosFilter.
     *
     * @return zimbraHttpThrottleSafeIPs, or empty array if unset
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1427)
    public String[] getHttpThrottleSafeIPs() {
        return getMultiAttr(Provisioning.A_zimbraHttpThrottleSafeIPs);
    }

    /**
     * IP addresses to ignore when applying Jetty DosFilter.
     *
     * @param zimbraHttpThrottleSafeIPs new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1427)
    public void setHttpThrottleSafeIPs(String[] zimbraHttpThrottleSafeIPs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpThrottleSafeIPs, zimbraHttpThrottleSafeIPs);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP addresses to ignore when applying Jetty DosFilter.
     *
     * @param zimbraHttpThrottleSafeIPs new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1427)
    public Map<String,Object> setHttpThrottleSafeIPs(String[] zimbraHttpThrottleSafeIPs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpThrottleSafeIPs, zimbraHttpThrottleSafeIPs);
        return attrs;
    }

    /**
     * IP addresses to ignore when applying Jetty DosFilter.
     *
     * @param zimbraHttpThrottleSafeIPs new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1427)
    public void addHttpThrottleSafeIPs(String zimbraHttpThrottleSafeIPs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraHttpThrottleSafeIPs, zimbraHttpThrottleSafeIPs);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP addresses to ignore when applying Jetty DosFilter.
     *
     * @param zimbraHttpThrottleSafeIPs new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1427)
    public Map<String,Object> addHttpThrottleSafeIPs(String zimbraHttpThrottleSafeIPs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraHttpThrottleSafeIPs, zimbraHttpThrottleSafeIPs);
        return attrs;
    }

    /**
     * IP addresses to ignore when applying Jetty DosFilter.
     *
     * @param zimbraHttpThrottleSafeIPs existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1427)
    public void removeHttpThrottleSafeIPs(String zimbraHttpThrottleSafeIPs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraHttpThrottleSafeIPs, zimbraHttpThrottleSafeIPs);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP addresses to ignore when applying Jetty DosFilter.
     *
     * @param zimbraHttpThrottleSafeIPs existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1427)
    public Map<String,Object> removeHttpThrottleSafeIPs(String zimbraHttpThrottleSafeIPs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraHttpThrottleSafeIPs, zimbraHttpThrottleSafeIPs);
        return attrs;
    }

    /**
     * IP addresses to ignore when applying Jetty DosFilter.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1427)
    public void unsetHttpThrottleSafeIPs() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpThrottleSafeIPs, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP addresses to ignore when applying Jetty DosFilter.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1427)
    public Map<String,Object> unsetHttpThrottleSafeIPs(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpThrottleSafeIPs, "");
        return attrs;
    }

    /**
     * interface address on which IM server should listen; if empty, binds to
     * all interfaces
     *
     * @return zimbraIMBindAddress, or empty array if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=567)
    public String[] getIMBindAddress() {
        return getMultiAttr(Provisioning.A_zimbraIMBindAddress);
    }

    /**
     * interface address on which IM server should listen; if empty, binds to
     * all interfaces
     *
     * @param zimbraIMBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=567)
    public void setIMBindAddress(String[] zimbraIMBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIMBindAddress, zimbraIMBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which IM server should listen; if empty, binds to
     * all interfaces
     *
     * @param zimbraIMBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=567)
    public Map<String,Object> setIMBindAddress(String[] zimbraIMBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIMBindAddress, zimbraIMBindAddress);
        return attrs;
    }

    /**
     * interface address on which IM server should listen; if empty, binds to
     * all interfaces
     *
     * @param zimbraIMBindAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=567)
    public void addIMBindAddress(String zimbraIMBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraIMBindAddress, zimbraIMBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which IM server should listen; if empty, binds to
     * all interfaces
     *
     * @param zimbraIMBindAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=567)
    public Map<String,Object> addIMBindAddress(String zimbraIMBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraIMBindAddress, zimbraIMBindAddress);
        return attrs;
    }

    /**
     * interface address on which IM server should listen; if empty, binds to
     * all interfaces
     *
     * @param zimbraIMBindAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=567)
    public void removeIMBindAddress(String zimbraIMBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraIMBindAddress, zimbraIMBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which IM server should listen; if empty, binds to
     * all interfaces
     *
     * @param zimbraIMBindAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=567)
    public Map<String,Object> removeIMBindAddress(String zimbraIMBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraIMBindAddress, zimbraIMBindAddress);
        return attrs;
    }

    /**
     * interface address on which IM server should listen; if empty, binds to
     * all interfaces
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=567)
    public void unsetIMBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIMBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which IM server should listen; if empty, binds to
     * all interfaces
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=567)
    public Map<String,Object> unsetIMBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIMBindAddress, "");
        return attrs;
    }

    /**
     * supported IP mode
     *
     * <p>Valid values: [ipv4, ipv6, both]
     *
     * @return zimbraIPMode, or null if unset and/or has invalid value
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1171)
    public ZAttrProvisioning.IPMode getIPMode() {
        try { String v = getAttr(Provisioning.A_zimbraIPMode); return v == null ? null : ZAttrProvisioning.IPMode.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * supported IP mode
     *
     * <p>Valid values: [ipv4, ipv6, both]
     *
     * @return zimbraIPMode, or null if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1171)
    public String getIPModeAsString() {
        return getAttr(Provisioning.A_zimbraIPMode, null);
    }

    /**
     * supported IP mode
     *
     * <p>Valid values: [ipv4, ipv6, both]
     *
     * @param zimbraIPMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1171)
    public void setIPMode(ZAttrProvisioning.IPMode zimbraIPMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIPMode, zimbraIPMode.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * supported IP mode
     *
     * <p>Valid values: [ipv4, ipv6, both]
     *
     * @param zimbraIPMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1171)
    public Map<String,Object> setIPMode(ZAttrProvisioning.IPMode zimbraIPMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIPMode, zimbraIPMode.toString());
        return attrs;
    }

    /**
     * supported IP mode
     *
     * <p>Valid values: [ipv4, ipv6, both]
     *
     * @param zimbraIPMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1171)
    public void setIPModeAsString(String zimbraIPMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIPMode, zimbraIPMode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * supported IP mode
     *
     * <p>Valid values: [ipv4, ipv6, both]
     *
     * @param zimbraIPMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1171)
    public Map<String,Object> setIPModeAsString(String zimbraIPMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIPMode, zimbraIPMode);
        return attrs;
    }

    /**
     * supported IP mode
     *
     * <p>Valid values: [ipv4, ipv6, both]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1171)
    public void unsetIPMode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIPMode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * supported IP mode
     *
     * <p>Valid values: [ipv4, ipv6, both]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1171)
    public Map<String,Object> unsetIPMode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIPMode, "");
        return attrs;
    }

    /**
     * Zimbra Systems Unique ID
     *
     * @return zimbraId, or null if unset
     */
    @ZAttr(id=1)
    public String getId() {
        return getAttr(Provisioning.A_zimbraId, null);
    }

    /**
     * Zimbra Systems Unique ID
     *
     * @param zimbraId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=1)
    public void setId(String zimbraId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraId, zimbraId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra Systems Unique ID
     *
     * @param zimbraId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=1)
    public Map<String,Object> setId(String zimbraId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraId, zimbraId);
        return attrs;
    }

    /**
     * Zimbra Systems Unique ID
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=1)
    public void unsetId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra Systems Unique ID
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=1)
    public Map<String,Object> unsetId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraId, "");
        return attrs;
    }

    /**
     * Imap authenticated max idle time in seconds
     *
     * @return zimbraImapAuthenticatedMaxIdleTime, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1714)
    public int getImapAuthenticatedMaxIdleTime() {
        return getIntAttr(Provisioning.A_zimbraImapAuthenticatedMaxIdleTime, -1);
    }

    /**
     * Imap authenticated max idle time in seconds
     *
     * @param zimbraImapAuthenticatedMaxIdleTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1714)
    public void setImapAuthenticatedMaxIdleTime(int zimbraImapAuthenticatedMaxIdleTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapAuthenticatedMaxIdleTime, Integer.toString(zimbraImapAuthenticatedMaxIdleTime));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Imap authenticated max idle time in seconds
     *
     * @param zimbraImapAuthenticatedMaxIdleTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1714)
    public Map<String,Object> setImapAuthenticatedMaxIdleTime(int zimbraImapAuthenticatedMaxIdleTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapAuthenticatedMaxIdleTime, Integer.toString(zimbraImapAuthenticatedMaxIdleTime));
        return attrs;
    }

    /**
     * Imap authenticated max idle time in seconds
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1714)
    public void unsetImapAuthenticatedMaxIdleTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapAuthenticatedMaxIdleTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Imap authenticated max idle time in seconds
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1714)
    public Map<String,Object> unsetImapAuthenticatedMaxIdleTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapAuthenticatedMaxIdleTime, "");
        return attrs;
    }

    /**
     * interface address on which IMAP server should listen; if empty, binds
     * to all interfaces
     *
     * @return zimbraImapBindAddress, or empty array if unset
     */
    @ZAttr(id=179)
    public String[] getImapBindAddress() {
        return getMultiAttr(Provisioning.A_zimbraImapBindAddress);
    }

    /**
     * interface address on which IMAP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraImapBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=179)
    public void setImapBindAddress(String[] zimbraImapBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindAddress, zimbraImapBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which IMAP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraImapBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=179)
    public Map<String,Object> setImapBindAddress(String[] zimbraImapBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindAddress, zimbraImapBindAddress);
        return attrs;
    }

    /**
     * interface address on which IMAP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraImapBindAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=179)
    public void addImapBindAddress(String zimbraImapBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraImapBindAddress, zimbraImapBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which IMAP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraImapBindAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=179)
    public Map<String,Object> addImapBindAddress(String zimbraImapBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraImapBindAddress, zimbraImapBindAddress);
        return attrs;
    }

    /**
     * interface address on which IMAP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraImapBindAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=179)
    public void removeImapBindAddress(String zimbraImapBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraImapBindAddress, zimbraImapBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which IMAP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraImapBindAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=179)
    public Map<String,Object> removeImapBindAddress(String zimbraImapBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraImapBindAddress, zimbraImapBindAddress);
        return attrs;
    }

    /**
     * interface address on which IMAP server should listen; if empty, binds
     * to all interfaces
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=179)
    public void unsetImapBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which IMAP server should listen; if empty, binds
     * to all interfaces
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=179)
    public Map<String,Object> unsetImapBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindAddress, "");
        return attrs;
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @return zimbraImapBindOnStartup, or false if unset
     */
    @ZAttr(id=268)
    public boolean isImapBindOnStartup() {
        return getBooleanAttr(Provisioning.A_zimbraImapBindOnStartup, false);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param zimbraImapBindOnStartup new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=268)
    public void setImapBindOnStartup(boolean zimbraImapBindOnStartup) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindOnStartup, zimbraImapBindOnStartup ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param zimbraImapBindOnStartup new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=268)
    public Map<String,Object> setImapBindOnStartup(boolean zimbraImapBindOnStartup, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindOnStartup, zimbraImapBindOnStartup ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=268)
    public void unsetImapBindOnStartup() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindOnStartup, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=268)
    public Map<String,Object> unsetImapBindOnStartup(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindOnStartup, "");
        return attrs;
    }

    /**
     * port number on which IMAP server should listen
     *
     * <p>Use getImapBindPortAsString to access value as a string.
     *
     * @see #getImapBindPortAsString()
     *
     * @return zimbraImapBindPort, or -1 if unset
     */
    @ZAttr(id=180)
    public int getImapBindPort() {
        return getIntAttr(Provisioning.A_zimbraImapBindPort, -1);
    }

    /**
     * port number on which IMAP server should listen
     *
     * @return zimbraImapBindPort, or null if unset
     */
    @ZAttr(id=180)
    public String getImapBindPortAsString() {
        return getAttr(Provisioning.A_zimbraImapBindPort, null);
    }

    /**
     * port number on which IMAP server should listen
     *
     * @param zimbraImapBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=180)
    public void setImapBindPort(int zimbraImapBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindPort, Integer.toString(zimbraImapBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAP server should listen
     *
     * @param zimbraImapBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=180)
    public Map<String,Object> setImapBindPort(int zimbraImapBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindPort, Integer.toString(zimbraImapBindPort));
        return attrs;
    }

    /**
     * port number on which IMAP server should listen
     *
     * @param zimbraImapBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=180)
    public void setImapBindPortAsString(String zimbraImapBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindPort, zimbraImapBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAP server should listen
     *
     * @param zimbraImapBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=180)
    public Map<String,Object> setImapBindPortAsString(String zimbraImapBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindPort, zimbraImapBindPort);
        return attrs;
    }

    /**
     * port number on which IMAP server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=180)
    public void unsetImapBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAP server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=180)
    public Map<String,Object> unsetImapBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindPort, "");
        return attrs;
    }

    /**
     * whether or not to allow cleartext logins over a non SSL/TLS connection
     *
     * @return zimbraImapCleartextLoginEnabled, or false if unset
     */
    @ZAttr(id=185)
    public boolean isImapCleartextLoginEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraImapCleartextLoginEnabled, false);
    }

    /**
     * whether or not to allow cleartext logins over a non SSL/TLS connection
     *
     * @param zimbraImapCleartextLoginEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=185)
    public void setImapCleartextLoginEnabled(boolean zimbraImapCleartextLoginEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapCleartextLoginEnabled, zimbraImapCleartextLoginEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to allow cleartext logins over a non SSL/TLS connection
     *
     * @param zimbraImapCleartextLoginEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=185)
    public Map<String,Object> setImapCleartextLoginEnabled(boolean zimbraImapCleartextLoginEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapCleartextLoginEnabled, zimbraImapCleartextLoginEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * whether or not to allow cleartext logins over a non SSL/TLS connection
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=185)
    public void unsetImapCleartextLoginEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapCleartextLoginEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to allow cleartext logins over a non SSL/TLS connection
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=185)
    public Map<String,Object> unsetImapCleartextLoginEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapCleartextLoginEnabled, "");
        return attrs;
    }

    /**
     * disabled IMAP capabilities. Capabilities are listed on the CAPABILITY
     * line, also known in RFCs as extensions
     *
     * @return zimbraImapDisabledCapability, or empty array if unset
     */
    @ZAttr(id=443)
    public String[] getImapDisabledCapability() {
        return getMultiAttr(Provisioning.A_zimbraImapDisabledCapability);
    }

    /**
     * disabled IMAP capabilities. Capabilities are listed on the CAPABILITY
     * line, also known in RFCs as extensions
     *
     * @param zimbraImapDisabledCapability new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=443)
    public void setImapDisabledCapability(String[] zimbraImapDisabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapDisabledCapability, zimbraImapDisabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * disabled IMAP capabilities. Capabilities are listed on the CAPABILITY
     * line, also known in RFCs as extensions
     *
     * @param zimbraImapDisabledCapability new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=443)
    public Map<String,Object> setImapDisabledCapability(String[] zimbraImapDisabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapDisabledCapability, zimbraImapDisabledCapability);
        return attrs;
    }

    /**
     * disabled IMAP capabilities. Capabilities are listed on the CAPABILITY
     * line, also known in RFCs as extensions
     *
     * @param zimbraImapDisabledCapability new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=443)
    public void addImapDisabledCapability(String zimbraImapDisabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraImapDisabledCapability, zimbraImapDisabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * disabled IMAP capabilities. Capabilities are listed on the CAPABILITY
     * line, also known in RFCs as extensions
     *
     * @param zimbraImapDisabledCapability new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=443)
    public Map<String,Object> addImapDisabledCapability(String zimbraImapDisabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraImapDisabledCapability, zimbraImapDisabledCapability);
        return attrs;
    }

    /**
     * disabled IMAP capabilities. Capabilities are listed on the CAPABILITY
     * line, also known in RFCs as extensions
     *
     * @param zimbraImapDisabledCapability existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=443)
    public void removeImapDisabledCapability(String zimbraImapDisabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraImapDisabledCapability, zimbraImapDisabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * disabled IMAP capabilities. Capabilities are listed on the CAPABILITY
     * line, also known in RFCs as extensions
     *
     * @param zimbraImapDisabledCapability existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=443)
    public Map<String,Object> removeImapDisabledCapability(String zimbraImapDisabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraImapDisabledCapability, zimbraImapDisabledCapability);
        return attrs;
    }

    /**
     * disabled IMAP capabilities. Capabilities are listed on the CAPABILITY
     * line, also known in RFCs as extensions
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=443)
    public void unsetImapDisabledCapability() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapDisabledCapability, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * disabled IMAP capabilities. Capabilities are listed on the CAPABILITY
     * line, also known in RFCs as extensions
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=443)
    public Map<String,Object> unsetImapDisabledCapability(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapDisabledCapability, "");
        return attrs;
    }

    /**
     * whether to display IMAP Mail folders only
     *
     * @return zimbraImapDisplayMailFoldersOnly, or false if unset
     *
     * @since ZCS 8.7.0,9.0
     */
    @ZAttr(id=1909)
    public boolean isImapDisplayMailFoldersOnly() {
        return getBooleanAttr(Provisioning.A_zimbraImapDisplayMailFoldersOnly, false);
    }

    /**
     * whether to display IMAP Mail folders only
     *
     * @param zimbraImapDisplayMailFoldersOnly new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0
     */
    @ZAttr(id=1909)
    public void setImapDisplayMailFoldersOnly(boolean zimbraImapDisplayMailFoldersOnly) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapDisplayMailFoldersOnly, zimbraImapDisplayMailFoldersOnly ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to display IMAP Mail folders only
     *
     * @param zimbraImapDisplayMailFoldersOnly new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0
     */
    @ZAttr(id=1909)
    public Map<String,Object> setImapDisplayMailFoldersOnly(boolean zimbraImapDisplayMailFoldersOnly, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapDisplayMailFoldersOnly, zimbraImapDisplayMailFoldersOnly ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * whether to display IMAP Mail folders only
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0
     */
    @ZAttr(id=1909)
    public void unsetImapDisplayMailFoldersOnly() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapDisplayMailFoldersOnly, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to display IMAP Mail folders only
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0
     */
    @ZAttr(id=1909)
    public Map<String,Object> unsetImapDisplayMailFoldersOnly(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapDisplayMailFoldersOnly, "");
        return attrs;
    }

    /**
     * Enable debug for IMAP
     *
     * @return zimbraImapEnableDebug, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1755)
    public boolean isImapEnableDebug() {
        return getBooleanAttr(Provisioning.A_zimbraImapEnableDebug, false);
    }

    /**
     * Enable debug for IMAP
     *
     * @param zimbraImapEnableDebug new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1755)
    public void setImapEnableDebug(boolean zimbraImapEnableDebug) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapEnableDebug, zimbraImapEnableDebug ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable debug for IMAP
     *
     * @param zimbraImapEnableDebug new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1755)
    public Map<String,Object> setImapEnableDebug(boolean zimbraImapEnableDebug, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapEnableDebug, zimbraImapEnableDebug ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Enable debug for IMAP
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1755)
    public void unsetImapEnableDebug() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapEnableDebug, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable debug for IMAP
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1755)
    public Map<String,Object> unsetImapEnableDebug(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapEnableDebug, "");
        return attrs;
    }

    /**
     * Enable STARTTLS for Imap
     *
     * @return zimbraImapEnableStartTls, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1756)
    public boolean isImapEnableStartTls() {
        return getBooleanAttr(Provisioning.A_zimbraImapEnableStartTls, false);
    }

    /**
     * Enable STARTTLS for Imap
     *
     * @param zimbraImapEnableStartTls new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1756)
    public void setImapEnableStartTls(boolean zimbraImapEnableStartTls) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapEnableStartTls, zimbraImapEnableStartTls ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable STARTTLS for Imap
     *
     * @param zimbraImapEnableStartTls new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1756)
    public Map<String,Object> setImapEnableStartTls(boolean zimbraImapEnableStartTls, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapEnableStartTls, zimbraImapEnableStartTls ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Enable STARTTLS for Imap
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1756)
    public void unsetImapEnableStartTls() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapEnableStartTls, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable STARTTLS for Imap
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1756)
    public Map<String,Object> unsetImapEnableStartTls(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapEnableStartTls, "");
        return attrs;
    }

    /**
     * Ehcache: the maximum disk size of inactive IMAP cache in Bytes before
     * eviction.By default this value is 10GB.This is a rough limit,Due to
     * internals of ehcache actual size on disk will often exceed this limit
     * by a modest margin.
     *
     * @return zimbraImapInactiveSessionCacheMaxDiskSize, or -1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2013)
    public long getImapInactiveSessionCacheMaxDiskSize() {
        return getLongAttr(Provisioning.A_zimbraImapInactiveSessionCacheMaxDiskSize, -1L);
    }

    /**
     * Ehcache: the maximum disk size of inactive IMAP cache in Bytes before
     * eviction.By default this value is 10GB.This is a rough limit,Due to
     * internals of ehcache actual size on disk will often exceed this limit
     * by a modest margin.
     *
     * @param zimbraImapInactiveSessionCacheMaxDiskSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2013)
    public void setImapInactiveSessionCacheMaxDiskSize(long zimbraImapInactiveSessionCacheMaxDiskSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionCacheMaxDiskSize, Long.toString(zimbraImapInactiveSessionCacheMaxDiskSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Ehcache: the maximum disk size of inactive IMAP cache in Bytes before
     * eviction.By default this value is 10GB.This is a rough limit,Due to
     * internals of ehcache actual size on disk will often exceed this limit
     * by a modest margin.
     *
     * @param zimbraImapInactiveSessionCacheMaxDiskSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2013)
    public Map<String,Object> setImapInactiveSessionCacheMaxDiskSize(long zimbraImapInactiveSessionCacheMaxDiskSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionCacheMaxDiskSize, Long.toString(zimbraImapInactiveSessionCacheMaxDiskSize));
        return attrs;
    }

    /**
     * Ehcache: the maximum disk size of inactive IMAP cache in Bytes before
     * eviction.By default this value is 10GB.This is a rough limit,Due to
     * internals of ehcache actual size on disk will often exceed this limit
     * by a modest margin.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2013)
    public void unsetImapInactiveSessionCacheMaxDiskSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionCacheMaxDiskSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Ehcache: the maximum disk size of inactive IMAP cache in Bytes before
     * eviction.By default this value is 10GB.This is a rough limit,Due to
     * internals of ehcache actual size on disk will often exceed this limit
     * by a modest margin.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2013)
    public Map<String,Object> unsetImapInactiveSessionCacheMaxDiskSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionCacheMaxDiskSize, "");
        return attrs;
    }

    /**
     * Ehcache: the maximum number of inactive IMAP cache entries on disk
     * before eviction.
     *
     * @return zimbraImapInactiveSessionCacheSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1708)
    public int getImapInactiveSessionCacheSize() {
        return getIntAttr(Provisioning.A_zimbraImapInactiveSessionCacheSize, -1);
    }

    /**
     * Ehcache: the maximum number of inactive IMAP cache entries on disk
     * before eviction.
     *
     * @param zimbraImapInactiveSessionCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1708)
    public void setImapInactiveSessionCacheSize(int zimbraImapInactiveSessionCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionCacheSize, Integer.toString(zimbraImapInactiveSessionCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Ehcache: the maximum number of inactive IMAP cache entries on disk
     * before eviction.
     *
     * @param zimbraImapInactiveSessionCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1708)
    public Map<String,Object> setImapInactiveSessionCacheSize(int zimbraImapInactiveSessionCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionCacheSize, Integer.toString(zimbraImapInactiveSessionCacheSize));
        return attrs;
    }

    /**
     * Ehcache: the maximum number of inactive IMAP cache entries on disk
     * before eviction.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1708)
    public void unsetImapInactiveSessionCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Ehcache: the maximum number of inactive IMAP cache entries on disk
     * before eviction.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1708)
    public Map<String,Object> unsetImapInactiveSessionCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionCacheSize, "");
        return attrs;
    }

    /**
     * Maximum number of concurrent IMAP connections allowed. New connections
     * exceeding this limit are rejected.
     *
     * @return zimbraImapMaxConnections, or -1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1156)
    public int getImapMaxConnections() {
        return getIntAttr(Provisioning.A_zimbraImapMaxConnections, -1);
    }

    /**
     * Maximum number of concurrent IMAP connections allowed. New connections
     * exceeding this limit are rejected.
     *
     * @param zimbraImapMaxConnections new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1156)
    public void setImapMaxConnections(int zimbraImapMaxConnections) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxConnections, Integer.toString(zimbraImapMaxConnections));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of concurrent IMAP connections allowed. New connections
     * exceeding this limit are rejected.
     *
     * @param zimbraImapMaxConnections new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1156)
    public Map<String,Object> setImapMaxConnections(int zimbraImapMaxConnections, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxConnections, Integer.toString(zimbraImapMaxConnections));
        return attrs;
    }

    /**
     * Maximum number of concurrent IMAP connections allowed. New connections
     * exceeding this limit are rejected.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1156)
    public void unsetImapMaxConnections() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxConnections, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of concurrent IMAP connections allowed. New connections
     * exceeding this limit are rejected.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1156)
    public Map<String,Object> unsetImapMaxConnections(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxConnections, "");
        return attrs;
    }

    /**
     * If greater than 0, drop the imap connection if
     * zimbraImapMaxConsecutiveError value is reached.
     *
     * @return zimbraImapMaxConsecutiveError, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1707)
    public int getImapMaxConsecutiveError() {
        return getIntAttr(Provisioning.A_zimbraImapMaxConsecutiveError, -1);
    }

    /**
     * If greater than 0, drop the imap connection if
     * zimbraImapMaxConsecutiveError value is reached.
     *
     * @param zimbraImapMaxConsecutiveError new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1707)
    public void setImapMaxConsecutiveError(int zimbraImapMaxConsecutiveError) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxConsecutiveError, Integer.toString(zimbraImapMaxConsecutiveError));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If greater than 0, drop the imap connection if
     * zimbraImapMaxConsecutiveError value is reached.
     *
     * @param zimbraImapMaxConsecutiveError new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1707)
    public Map<String,Object> setImapMaxConsecutiveError(int zimbraImapMaxConsecutiveError, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxConsecutiveError, Integer.toString(zimbraImapMaxConsecutiveError));
        return attrs;
    }

    /**
     * If greater than 0, drop the imap connection if
     * zimbraImapMaxConsecutiveError value is reached.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1707)
    public void unsetImapMaxConsecutiveError() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxConsecutiveError, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If greater than 0, drop the imap connection if
     * zimbraImapMaxConsecutiveError value is reached.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1707)
    public Map<String,Object> unsetImapMaxConsecutiveError(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxConsecutiveError, "");
        return attrs;
    }

    /**
     * Imap max idle time in seconds
     *
     * @return zimbraImapMaxIdleTime, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1713)
    public int getImapMaxIdleTime() {
        return getIntAttr(Provisioning.A_zimbraImapMaxIdleTime, -1);
    }

    /**
     * Imap max idle time in seconds
     *
     * @param zimbraImapMaxIdleTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1713)
    public void setImapMaxIdleTime(int zimbraImapMaxIdleTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxIdleTime, Integer.toString(zimbraImapMaxIdleTime));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Imap max idle time in seconds
     *
     * @param zimbraImapMaxIdleTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1713)
    public Map<String,Object> setImapMaxIdleTime(int zimbraImapMaxIdleTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxIdleTime, Integer.toString(zimbraImapMaxIdleTime));
        return attrs;
    }

    /**
     * Imap max idle time in seconds
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1713)
    public void unsetImapMaxIdleTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxIdleTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Imap max idle time in seconds
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1713)
    public Map<String,Object> unsetImapMaxIdleTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxIdleTime, "");
        return attrs;
    }

    /**
     * maximum size of IMAP request in bytes excluding literal data
     *
     * @return zimbraImapMaxRequestSize, or -1 if unset
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1085)
    public int getImapMaxRequestSize() {
        return getIntAttr(Provisioning.A_zimbraImapMaxRequestSize, -1);
    }

    /**
     * maximum size of IMAP request in bytes excluding literal data
     *
     * @param zimbraImapMaxRequestSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1085)
    public void setImapMaxRequestSize(int zimbraImapMaxRequestSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxRequestSize, Integer.toString(zimbraImapMaxRequestSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum size of IMAP request in bytes excluding literal data
     *
     * @param zimbraImapMaxRequestSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1085)
    public Map<String,Object> setImapMaxRequestSize(int zimbraImapMaxRequestSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxRequestSize, Integer.toString(zimbraImapMaxRequestSize));
        return attrs;
    }

    /**
     * maximum size of IMAP request in bytes excluding literal data
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1085)
    public void unsetImapMaxRequestSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxRequestSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum size of IMAP request in bytes excluding literal data
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1085)
    public Map<String,Object> unsetImapMaxRequestSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxRequestSize, "");
        return attrs;
    }

    /**
     * Maximum image size in bytes to resize
     *
     * @return zimbraImapNioEnabled, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1802)
    public boolean isImapNioEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraImapNioEnabled, false);
    }

    /**
     * Maximum image size in bytes to resize
     *
     * @param zimbraImapNioEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1802)
    public void setImapNioEnabled(boolean zimbraImapNioEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapNioEnabled, zimbraImapNioEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum image size in bytes to resize
     *
     * @param zimbraImapNioEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1802)
    public Map<String,Object> setImapNioEnabled(boolean zimbraImapNioEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapNioEnabled, zimbraImapNioEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Maximum image size in bytes to resize
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1802)
    public void unsetImapNioEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapNioEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum image size in bytes to resize
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1802)
    public Map<String,Object> unsetImapNioEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapNioEnabled, "");
        return attrs;
    }

    /**
     * number of handler threads
     *
     * @return zimbraImapNumThreads, or -1 if unset
     */
    @ZAttr(id=181)
    public int getImapNumThreads() {
        return getIntAttr(Provisioning.A_zimbraImapNumThreads, -1);
    }

    /**
     * number of handler threads
     *
     * @param zimbraImapNumThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=181)
    public void setImapNumThreads(int zimbraImapNumThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapNumThreads, Integer.toString(zimbraImapNumThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of handler threads
     *
     * @param zimbraImapNumThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=181)
    public Map<String,Object> setImapNumThreads(int zimbraImapNumThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapNumThreads, Integer.toString(zimbraImapNumThreads));
        return attrs;
    }

    /**
     * number of handler threads
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=181)
    public void unsetImapNumThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapNumThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of handler threads
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=181)
    public Map<String,Object> unsetImapNumThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapNumThreads, "");
        return attrs;
    }

    /**
     * port number on which IMAP proxy server should listen
     *
     * <p>Use getImapProxyBindPortAsString to access value as a string.
     *
     * @see #getImapProxyBindPortAsString()
     *
     * @return zimbraImapProxyBindPort, or -1 if unset
     */
    @ZAttr(id=348)
    public int getImapProxyBindPort() {
        return getIntAttr(Provisioning.A_zimbraImapProxyBindPort, -1);
    }

    /**
     * port number on which IMAP proxy server should listen
     *
     * @return zimbraImapProxyBindPort, or null if unset
     */
    @ZAttr(id=348)
    public String getImapProxyBindPortAsString() {
        return getAttr(Provisioning.A_zimbraImapProxyBindPort, null);
    }

    /**
     * port number on which IMAP proxy server should listen
     *
     * @param zimbraImapProxyBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=348)
    public void setImapProxyBindPort(int zimbraImapProxyBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapProxyBindPort, Integer.toString(zimbraImapProxyBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAP proxy server should listen
     *
     * @param zimbraImapProxyBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=348)
    public Map<String,Object> setImapProxyBindPort(int zimbraImapProxyBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapProxyBindPort, Integer.toString(zimbraImapProxyBindPort));
        return attrs;
    }

    /**
     * port number on which IMAP proxy server should listen
     *
     * @param zimbraImapProxyBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=348)
    public void setImapProxyBindPortAsString(String zimbraImapProxyBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapProxyBindPort, zimbraImapProxyBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAP proxy server should listen
     *
     * @param zimbraImapProxyBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=348)
    public Map<String,Object> setImapProxyBindPortAsString(String zimbraImapProxyBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapProxyBindPort, zimbraImapProxyBindPort);
        return attrs;
    }

    /**
     * port number on which IMAP proxy server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=348)
    public void unsetImapProxyBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapProxyBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAP proxy server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=348)
    public Map<String,Object> unsetImapProxyBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapProxyBindPort, "");
        return attrs;
    }

    /**
     * Flag to enable or disable to reuse imap data source connection
     *
     * @return zimbraImapReuseDataSourceConnections, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1719)
    public boolean isImapReuseDataSourceConnections() {
        return getBooleanAttr(Provisioning.A_zimbraImapReuseDataSourceConnections, false);
    }

    /**
     * Flag to enable or disable to reuse imap data source connection
     *
     * @param zimbraImapReuseDataSourceConnections new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1719)
    public void setImapReuseDataSourceConnections(boolean zimbraImapReuseDataSourceConnections) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapReuseDataSourceConnections, zimbraImapReuseDataSourceConnections ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable or disable to reuse imap data source connection
     *
     * @param zimbraImapReuseDataSourceConnections new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1719)
    public Map<String,Object> setImapReuseDataSourceConnections(boolean zimbraImapReuseDataSourceConnections, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapReuseDataSourceConnections, zimbraImapReuseDataSourceConnections ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to enable or disable to reuse imap data source connection
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1719)
    public void unsetImapReuseDataSourceConnections() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapReuseDataSourceConnections, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable or disable to reuse imap data source connection
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1719)
    public Map<String,Object> unsetImapReuseDataSourceConnections(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapReuseDataSourceConnections, "");
        return attrs;
    }

    /**
     * interface address on which IMAP server should listen; if empty, binds
     * to all interfaces
     *
     * @return zimbraImapSSLBindAddress, or empty array if unset
     */
    @ZAttr(id=182)
    public String[] getImapSSLBindAddress() {
        return getMultiAttr(Provisioning.A_zimbraImapSSLBindAddress);
    }

    /**
     * interface address on which IMAP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraImapSSLBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=182)
    public void setImapSSLBindAddress(String[] zimbraImapSSLBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindAddress, zimbraImapSSLBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which IMAP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraImapSSLBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=182)
    public Map<String,Object> setImapSSLBindAddress(String[] zimbraImapSSLBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindAddress, zimbraImapSSLBindAddress);
        return attrs;
    }

    /**
     * interface address on which IMAP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraImapSSLBindAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=182)
    public void addImapSSLBindAddress(String zimbraImapSSLBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraImapSSLBindAddress, zimbraImapSSLBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which IMAP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraImapSSLBindAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=182)
    public Map<String,Object> addImapSSLBindAddress(String zimbraImapSSLBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraImapSSLBindAddress, zimbraImapSSLBindAddress);
        return attrs;
    }

    /**
     * interface address on which IMAP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraImapSSLBindAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=182)
    public void removeImapSSLBindAddress(String zimbraImapSSLBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraImapSSLBindAddress, zimbraImapSSLBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which IMAP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraImapSSLBindAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=182)
    public Map<String,Object> removeImapSSLBindAddress(String zimbraImapSSLBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraImapSSLBindAddress, zimbraImapSSLBindAddress);
        return attrs;
    }

    /**
     * interface address on which IMAP server should listen; if empty, binds
     * to all interfaces
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=182)
    public void unsetImapSSLBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which IMAP server should listen; if empty, binds
     * to all interfaces
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=182)
    public Map<String,Object> unsetImapSSLBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindAddress, "");
        return attrs;
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @return zimbraImapSSLBindOnStartup, or false if unset
     */
    @ZAttr(id=269)
    public boolean isImapSSLBindOnStartup() {
        return getBooleanAttr(Provisioning.A_zimbraImapSSLBindOnStartup, false);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param zimbraImapSSLBindOnStartup new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=269)
    public void setImapSSLBindOnStartup(boolean zimbraImapSSLBindOnStartup) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindOnStartup, zimbraImapSSLBindOnStartup ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param zimbraImapSSLBindOnStartup new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=269)
    public Map<String,Object> setImapSSLBindOnStartup(boolean zimbraImapSSLBindOnStartup, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindOnStartup, zimbraImapSSLBindOnStartup ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=269)
    public void unsetImapSSLBindOnStartup() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindOnStartup, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=269)
    public Map<String,Object> unsetImapSSLBindOnStartup(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindOnStartup, "");
        return attrs;
    }

    /**
     * port number on which IMAP SSL server should listen on
     *
     * <p>Use getImapSSLBindPortAsString to access value as a string.
     *
     * @see #getImapSSLBindPortAsString()
     *
     * @return zimbraImapSSLBindPort, or -1 if unset
     */
    @ZAttr(id=183)
    public int getImapSSLBindPort() {
        return getIntAttr(Provisioning.A_zimbraImapSSLBindPort, -1);
    }

    /**
     * port number on which IMAP SSL server should listen on
     *
     * @return zimbraImapSSLBindPort, or null if unset
     */
    @ZAttr(id=183)
    public String getImapSSLBindPortAsString() {
        return getAttr(Provisioning.A_zimbraImapSSLBindPort, null);
    }

    /**
     * port number on which IMAP SSL server should listen on
     *
     * @param zimbraImapSSLBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=183)
    public void setImapSSLBindPort(int zimbraImapSSLBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindPort, Integer.toString(zimbraImapSSLBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAP SSL server should listen on
     *
     * @param zimbraImapSSLBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=183)
    public Map<String,Object> setImapSSLBindPort(int zimbraImapSSLBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindPort, Integer.toString(zimbraImapSSLBindPort));
        return attrs;
    }

    /**
     * port number on which IMAP SSL server should listen on
     *
     * @param zimbraImapSSLBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=183)
    public void setImapSSLBindPortAsString(String zimbraImapSSLBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindPort, zimbraImapSSLBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAP SSL server should listen on
     *
     * @param zimbraImapSSLBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=183)
    public Map<String,Object> setImapSSLBindPortAsString(String zimbraImapSSLBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindPort, zimbraImapSSLBindPort);
        return attrs;
    }

    /**
     * port number on which IMAP SSL server should listen on
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=183)
    public void unsetImapSSLBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAP SSL server should listen on
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=183)
    public Map<String,Object> unsetImapSSLBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindPort, "");
        return attrs;
    }

    /**
     * disabled IMAP SSL capabilities. Capabilities are listed on the
     * CAPABILITY line, also known in RFCs as extensions
     *
     * @return zimbraImapSSLDisabledCapability, or empty array if unset
     */
    @ZAttr(id=444)
    public String[] getImapSSLDisabledCapability() {
        return getMultiAttr(Provisioning.A_zimbraImapSSLDisabledCapability);
    }

    /**
     * disabled IMAP SSL capabilities. Capabilities are listed on the
     * CAPABILITY line, also known in RFCs as extensions
     *
     * @param zimbraImapSSLDisabledCapability new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=444)
    public void setImapSSLDisabledCapability(String[] zimbraImapSSLDisabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLDisabledCapability, zimbraImapSSLDisabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * disabled IMAP SSL capabilities. Capabilities are listed on the
     * CAPABILITY line, also known in RFCs as extensions
     *
     * @param zimbraImapSSLDisabledCapability new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=444)
    public Map<String,Object> setImapSSLDisabledCapability(String[] zimbraImapSSLDisabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLDisabledCapability, zimbraImapSSLDisabledCapability);
        return attrs;
    }

    /**
     * disabled IMAP SSL capabilities. Capabilities are listed on the
     * CAPABILITY line, also known in RFCs as extensions
     *
     * @param zimbraImapSSLDisabledCapability new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=444)
    public void addImapSSLDisabledCapability(String zimbraImapSSLDisabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraImapSSLDisabledCapability, zimbraImapSSLDisabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * disabled IMAP SSL capabilities. Capabilities are listed on the
     * CAPABILITY line, also known in RFCs as extensions
     *
     * @param zimbraImapSSLDisabledCapability new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=444)
    public Map<String,Object> addImapSSLDisabledCapability(String zimbraImapSSLDisabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraImapSSLDisabledCapability, zimbraImapSSLDisabledCapability);
        return attrs;
    }

    /**
     * disabled IMAP SSL capabilities. Capabilities are listed on the
     * CAPABILITY line, also known in RFCs as extensions
     *
     * @param zimbraImapSSLDisabledCapability existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=444)
    public void removeImapSSLDisabledCapability(String zimbraImapSSLDisabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraImapSSLDisabledCapability, zimbraImapSSLDisabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * disabled IMAP SSL capabilities. Capabilities are listed on the
     * CAPABILITY line, also known in RFCs as extensions
     *
     * @param zimbraImapSSLDisabledCapability existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=444)
    public Map<String,Object> removeImapSSLDisabledCapability(String zimbraImapSSLDisabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraImapSSLDisabledCapability, zimbraImapSSLDisabledCapability);
        return attrs;
    }

    /**
     * disabled IMAP SSL capabilities. Capabilities are listed on the
     * CAPABILITY line, also known in RFCs as extensions
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=444)
    public void unsetImapSSLDisabledCapability() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLDisabledCapability, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * disabled IMAP SSL capabilities. Capabilities are listed on the
     * CAPABILITY line, also known in RFCs as extensions
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=444)
    public Map<String,Object> unsetImapSSLDisabledCapability(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLDisabledCapability, "");
        return attrs;
    }

    /**
     * port number on which IMAPS proxy server should listen
     *
     * <p>Use getImapSSLProxyBindPortAsString to access value as a string.
     *
     * @see #getImapSSLProxyBindPortAsString()
     *
     * @return zimbraImapSSLProxyBindPort, or -1 if unset
     */
    @ZAttr(id=349)
    public int getImapSSLProxyBindPort() {
        return getIntAttr(Provisioning.A_zimbraImapSSLProxyBindPort, -1);
    }

    /**
     * port number on which IMAPS proxy server should listen
     *
     * @return zimbraImapSSLProxyBindPort, or null if unset
     */
    @ZAttr(id=349)
    public String getImapSSLProxyBindPortAsString() {
        return getAttr(Provisioning.A_zimbraImapSSLProxyBindPort, null);
    }

    /**
     * port number on which IMAPS proxy server should listen
     *
     * @param zimbraImapSSLProxyBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=349)
    public void setImapSSLProxyBindPort(int zimbraImapSSLProxyBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLProxyBindPort, Integer.toString(zimbraImapSSLProxyBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAPS proxy server should listen
     *
     * @param zimbraImapSSLProxyBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=349)
    public Map<String,Object> setImapSSLProxyBindPort(int zimbraImapSSLProxyBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLProxyBindPort, Integer.toString(zimbraImapSSLProxyBindPort));
        return attrs;
    }

    /**
     * port number on which IMAPS proxy server should listen
     *
     * @param zimbraImapSSLProxyBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=349)
    public void setImapSSLProxyBindPortAsString(String zimbraImapSSLProxyBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLProxyBindPort, zimbraImapSSLProxyBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAPS proxy server should listen
     *
     * @param zimbraImapSSLProxyBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=349)
    public Map<String,Object> setImapSSLProxyBindPortAsString(String zimbraImapSSLProxyBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLProxyBindPort, zimbraImapSSLProxyBindPort);
        return attrs;
    }

    /**
     * port number on which IMAPS proxy server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=349)
    public void unsetImapSSLProxyBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLProxyBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAPS proxy server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=349)
    public Map<String,Object> unsetImapSSLProxyBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLProxyBindPort, "");
        return attrs;
    }

    /**
     * Maximum number of IMAP folders a single user can have open at once
     *
     * @return zimbraImapSessionLimit, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1737)
    public int getImapSessionLimit() {
        return getIntAttr(Provisioning.A_zimbraImapSessionLimit, -1);
    }

    /**
     * Maximum number of IMAP folders a single user can have open at once
     *
     * @param zimbraImapSessionLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1737)
    public void setImapSessionLimit(int zimbraImapSessionLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSessionLimit, Integer.toString(zimbraImapSessionLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of IMAP folders a single user can have open at once
     *
     * @param zimbraImapSessionLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1737)
    public Map<String,Object> setImapSessionLimit(int zimbraImapSessionLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSessionLimit, Integer.toString(zimbraImapSessionLimit));
        return attrs;
    }

    /**
     * Maximum number of IMAP folders a single user can have open at once
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1737)
    public void unsetImapSessionLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSessionLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of IMAP folders a single user can have open at once
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1737)
    public Map<String,Object> unsetImapSessionLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSessionLimit, "");
        return attrs;
    }

    /**
     * number of seconds to wait before forcing IMAP server shutdown
     *
     * @return zimbraImapShutdownGraceSeconds, or -1 if unset
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1080)
    public int getImapShutdownGraceSeconds() {
        return getIntAttr(Provisioning.A_zimbraImapShutdownGraceSeconds, -1);
    }

    /**
     * number of seconds to wait before forcing IMAP server shutdown
     *
     * @param zimbraImapShutdownGraceSeconds new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1080)
    public void setImapShutdownGraceSeconds(int zimbraImapShutdownGraceSeconds) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapShutdownGraceSeconds, Integer.toString(zimbraImapShutdownGraceSeconds));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of seconds to wait before forcing IMAP server shutdown
     *
     * @param zimbraImapShutdownGraceSeconds new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1080)
    public Map<String,Object> setImapShutdownGraceSeconds(int zimbraImapShutdownGraceSeconds, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapShutdownGraceSeconds, Integer.toString(zimbraImapShutdownGraceSeconds));
        return attrs;
    }

    /**
     * number of seconds to wait before forcing IMAP server shutdown
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1080)
    public void unsetImapShutdownGraceSeconds() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapShutdownGraceSeconds, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of seconds to wait before forcing IMAP server shutdown
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1080)
    public Map<String,Object> unsetImapShutdownGraceSeconds(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapShutdownGraceSeconds, "");
        return attrs;
    }

    /**
     * Imap keep alive time in seconds
     *
     * @return zimbraImapThreadKeepAliveTime, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1712)
    public int getImapThreadKeepAliveTime() {
        return getIntAttr(Provisioning.A_zimbraImapThreadKeepAliveTime, -1);
    }

    /**
     * Imap keep alive time in seconds
     *
     * @param zimbraImapThreadKeepAliveTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1712)
    public void setImapThreadKeepAliveTime(int zimbraImapThreadKeepAliveTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThreadKeepAliveTime, Integer.toString(zimbraImapThreadKeepAliveTime));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Imap keep alive time in seconds
     *
     * @param zimbraImapThreadKeepAliveTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1712)
    public Map<String,Object> setImapThreadKeepAliveTime(int zimbraImapThreadKeepAliveTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThreadKeepAliveTime, Integer.toString(zimbraImapThreadKeepAliveTime));
        return attrs;
    }

    /**
     * Imap keep alive time in seconds
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1712)
    public void unsetImapThreadKeepAliveTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThreadKeepAliveTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Imap keep alive time in seconds
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1712)
    public Map<String,Object> unsetImapThreadKeepAliveTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThreadKeepAliveTime, "");
        return attrs;
    }

    /**
     * Imap throttle acct limit
     *
     * @return zimbraImapThrottleAcctLimit, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1716)
    public int getImapThrottleAcctLimit() {
        return getIntAttr(Provisioning.A_zimbraImapThrottleAcctLimit, -1);
    }

    /**
     * Imap throttle acct limit
     *
     * @param zimbraImapThrottleAcctLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1716)
    public void setImapThrottleAcctLimit(int zimbraImapThrottleAcctLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThrottleAcctLimit, Integer.toString(zimbraImapThrottleAcctLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Imap throttle acct limit
     *
     * @param zimbraImapThrottleAcctLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1716)
    public Map<String,Object> setImapThrottleAcctLimit(int zimbraImapThrottleAcctLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThrottleAcctLimit, Integer.toString(zimbraImapThrottleAcctLimit));
        return attrs;
    }

    /**
     * Imap throttle acct limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1716)
    public void unsetImapThrottleAcctLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThrottleAcctLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Imap throttle acct limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1716)
    public Map<String,Object> unsetImapThrottleAcctLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThrottleAcctLimit, "");
        return attrs;
    }

    /**
     * Imap throttle command limit
     *
     * @return zimbraImapThrottleCommandLimit, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1717)
    public int getImapThrottleCommandLimit() {
        return getIntAttr(Provisioning.A_zimbraImapThrottleCommandLimit, -1);
    }

    /**
     * Imap throttle command limit
     *
     * @param zimbraImapThrottleCommandLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1717)
    public void setImapThrottleCommandLimit(int zimbraImapThrottleCommandLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThrottleCommandLimit, Integer.toString(zimbraImapThrottleCommandLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Imap throttle command limit
     *
     * @param zimbraImapThrottleCommandLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1717)
    public Map<String,Object> setImapThrottleCommandLimit(int zimbraImapThrottleCommandLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThrottleCommandLimit, Integer.toString(zimbraImapThrottleCommandLimit));
        return attrs;
    }

    /**
     * Imap throttle command limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1717)
    public void unsetImapThrottleCommandLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThrottleCommandLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Imap throttle command limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1717)
    public Map<String,Object> unsetImapThrottleCommandLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThrottleCommandLimit, "");
        return attrs;
    }

    /**
     * Imap throttle fetch
     *
     * @return zimbraImapThrottleFetch, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1718)
    public boolean isImapThrottleFetch() {
        return getBooleanAttr(Provisioning.A_zimbraImapThrottleFetch, false);
    }

    /**
     * Imap throttle fetch
     *
     * @param zimbraImapThrottleFetch new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1718)
    public void setImapThrottleFetch(boolean zimbraImapThrottleFetch) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThrottleFetch, zimbraImapThrottleFetch ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Imap throttle fetch
     *
     * @param zimbraImapThrottleFetch new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1718)
    public Map<String,Object> setImapThrottleFetch(boolean zimbraImapThrottleFetch, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThrottleFetch, zimbraImapThrottleFetch ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Imap throttle fetch
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1718)
    public void unsetImapThrottleFetch() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThrottleFetch, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Imap throttle fetch
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1718)
    public Map<String,Object> unsetImapThrottleFetch(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThrottleFetch, "");
        return attrs;
    }

    /**
     * Imap throttle ip limit
     *
     * @return zimbraImapThrottleIpLimit, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1715)
    public int getImapThrottleIpLimit() {
        return getIntAttr(Provisioning.A_zimbraImapThrottleIpLimit, -1);
    }

    /**
     * Imap throttle ip limit
     *
     * @param zimbraImapThrottleIpLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1715)
    public void setImapThrottleIpLimit(int zimbraImapThrottleIpLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThrottleIpLimit, Integer.toString(zimbraImapThrottleIpLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Imap throttle ip limit
     *
     * @param zimbraImapThrottleIpLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1715)
    public Map<String,Object> setImapThrottleIpLimit(int zimbraImapThrottleIpLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThrottleIpLimit, Integer.toString(zimbraImapThrottleIpLimit));
        return attrs;
    }

    /**
     * Imap throttle ip limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1715)
    public void unsetImapThrottleIpLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThrottleIpLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Imap throttle ip limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1715)
    public Map<String,Object> unsetImapThrottleIpLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapThrottleIpLimit, "");
        return attrs;
    }

    /**
     * Timeout for imap in seconds
     *
     * @return zimbraImapTimeout, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1723)
    public int getImapTimeout() {
        return getIntAttr(Provisioning.A_zimbraImapTimeout, -1);
    }

    /**
     * Timeout for imap in seconds
     *
     * @param zimbraImapTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1723)
    public void setImapTimeout(int zimbraImapTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapTimeout, Integer.toString(zimbraImapTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout for imap in seconds
     *
     * @param zimbraImapTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1723)
    public Map<String,Object> setImapTimeout(int zimbraImapTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapTimeout, Integer.toString(zimbraImapTimeout));
        return attrs;
    }

    /**
     * Timeout for imap in seconds
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1723)
    public void unsetImapTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout for imap in seconds
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1723)
    public Map<String,Object> unsetImapTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapTimeout, "");
        return attrs;
    }

    /**
     * Flag to enable or disable imap cache
     *
     * @return zimbraImapUseEhcache, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1709)
    public boolean isImapUseEhcache() {
        return getBooleanAttr(Provisioning.A_zimbraImapUseEhcache, false);
    }

    /**
     * Flag to enable or disable imap cache
     *
     * @param zimbraImapUseEhcache new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1709)
    public void setImapUseEhcache(boolean zimbraImapUseEhcache) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapUseEhcache, zimbraImapUseEhcache ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable or disable imap cache
     *
     * @param zimbraImapUseEhcache new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1709)
    public Map<String,Object> setImapUseEhcache(boolean zimbraImapUseEhcache, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapUseEhcache, zimbraImapUseEhcache ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to enable or disable imap cache
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1709)
    public void unsetImapUseEhcache() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapUseEhcache, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable or disable imap cache
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1709)
    public Map<String,Object> unsetImapUseEhcache(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapUseEhcache, "");
        return attrs;
    }

    /**
     * Imap write chunk size in bytes
     *
     * @return zimbraImapWriteChunkSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1711)
    public int getImapWriteChunkSize() {
        return getIntAttr(Provisioning.A_zimbraImapWriteChunkSize, -1);
    }

    /**
     * Imap write chunk size in bytes
     *
     * @param zimbraImapWriteChunkSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1711)
    public void setImapWriteChunkSize(int zimbraImapWriteChunkSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapWriteChunkSize, Integer.toString(zimbraImapWriteChunkSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Imap write chunk size in bytes
     *
     * @param zimbraImapWriteChunkSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1711)
    public Map<String,Object> setImapWriteChunkSize(int zimbraImapWriteChunkSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapWriteChunkSize, Integer.toString(zimbraImapWriteChunkSize));
        return attrs;
    }

    /**
     * Imap write chunk size in bytes
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1711)
    public void unsetImapWriteChunkSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapWriteChunkSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Imap write chunk size in bytes
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1711)
    public Map<String,Object> unsetImapWriteChunkSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapWriteChunkSize, "");
        return attrs;
    }

    /**
     * Set the IMAP session write timeout (nio)
     *
     * @return zimbraImapWriteTimeout, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1710)
    public int getImapWriteTimeout() {
        return getIntAttr(Provisioning.A_zimbraImapWriteTimeout, -1);
    }

    /**
     * Set the IMAP session write timeout (nio)
     *
     * @param zimbraImapWriteTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1710)
    public void setImapWriteTimeout(int zimbraImapWriteTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapWriteTimeout, Integer.toString(zimbraImapWriteTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Set the IMAP session write timeout (nio)
     *
     * @param zimbraImapWriteTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1710)
    public Map<String,Object> setImapWriteTimeout(int zimbraImapWriteTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapWriteTimeout, Integer.toString(zimbraImapWriteTimeout));
        return attrs;
    }

    /**
     * Set the IMAP session write timeout (nio)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1710)
    public void unsetImapWriteTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapWriteTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Set the IMAP session write timeout (nio)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1710)
    public Map<String,Object> unsetImapWriteTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapWriteTimeout, "");
        return attrs;
    }

    /**
     * Time in milliseconds that mailstore will wait for an external indexing
     * service to back up a single mailbox index.
     *
     * @return zimbraIndexBackupTimeout, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2043)
    public int getIndexBackupTimeout() {
        return getIntAttr(Provisioning.A_zimbraIndexBackupTimeout, -1);
    }

    /**
     * Time in milliseconds that mailstore will wait for an external indexing
     * service to back up a single mailbox index.
     *
     * @param zimbraIndexBackupTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2043)
    public void setIndexBackupTimeout(int zimbraIndexBackupTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexBackupTimeout, Integer.toString(zimbraIndexBackupTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time in milliseconds that mailstore will wait for an external indexing
     * service to back up a single mailbox index.
     *
     * @param zimbraIndexBackupTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2043)
    public Map<String,Object> setIndexBackupTimeout(int zimbraIndexBackupTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexBackupTimeout, Integer.toString(zimbraIndexBackupTimeout));
        return attrs;
    }

    /**
     * Time in milliseconds that mailstore will wait for an external indexing
     * service to back up a single mailbox index.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2043)
    public void unsetIndexBackupTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexBackupTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time in milliseconds that mailstore will wait for an external indexing
     * service to back up a single mailbox index.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2043)
    public Map<String,Object> unsetIndexBackupTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexBackupTimeout, "");
        return attrs;
    }

    /**
     * Zimbra index db first term cutoff percentage
     *
     * @return zimbraIndexDbFirstTermCutOffPercentage, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1880)
    public int getIndexDbFirstTermCutOffPercentage() {
        return getIntAttr(Provisioning.A_zimbraIndexDbFirstTermCutOffPercentage, -1);
    }

    /**
     * Zimbra index db first term cutoff percentage
     *
     * @param zimbraIndexDbFirstTermCutOffPercentage new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1880)
    public void setIndexDbFirstTermCutOffPercentage(int zimbraIndexDbFirstTermCutOffPercentage) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexDbFirstTermCutOffPercentage, Integer.toString(zimbraIndexDbFirstTermCutOffPercentage));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra index db first term cutoff percentage
     *
     * @param zimbraIndexDbFirstTermCutOffPercentage new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1880)
    public Map<String,Object> setIndexDbFirstTermCutOffPercentage(int zimbraIndexDbFirstTermCutOffPercentage, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexDbFirstTermCutOffPercentage, Integer.toString(zimbraIndexDbFirstTermCutOffPercentage));
        return attrs;
    }

    /**
     * Zimbra index db first term cutoff percentage
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1880)
    public void unsetIndexDbFirstTermCutOffPercentage() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexDbFirstTermCutOffPercentage, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra index db first term cutoff percentage
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1880)
    public Map<String,Object> unsetIndexDbFirstTermCutOffPercentage(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexDbFirstTermCutOffPercentage, "");
        return attrs;
    }

    /**
     * If indexing of an item is failed. It can be tried after the delay
     * specified in seconds
     *
     * @return zimbraIndexDeferredItemsFailureDelay, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1762)
    public int getIndexDeferredItemsFailureDelay() {
        return getIntAttr(Provisioning.A_zimbraIndexDeferredItemsFailureDelay, -1);
    }

    /**
     * If indexing of an item is failed. It can be tried after the delay
     * specified in seconds
     *
     * @param zimbraIndexDeferredItemsFailureDelay new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1762)
    public void setIndexDeferredItemsFailureDelay(int zimbraIndexDeferredItemsFailureDelay) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexDeferredItemsFailureDelay, Integer.toString(zimbraIndexDeferredItemsFailureDelay));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If indexing of an item is failed. It can be tried after the delay
     * specified in seconds
     *
     * @param zimbraIndexDeferredItemsFailureDelay new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1762)
    public Map<String,Object> setIndexDeferredItemsFailureDelay(int zimbraIndexDeferredItemsFailureDelay, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexDeferredItemsFailureDelay, Integer.toString(zimbraIndexDeferredItemsFailureDelay));
        return attrs;
    }

    /**
     * If indexing of an item is failed. It can be tried after the delay
     * specified in seconds
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1762)
    public void unsetIndexDeferredItemsFailureDelay() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexDeferredItemsFailureDelay, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If indexing of an item is failed. It can be tried after the delay
     * specified in seconds
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1762)
    public Map<String,Object> unsetIndexDeferredItemsFailureDelay(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexDeferredItemsFailureDelay, "");
        return attrs;
    }

    /**
     * flag to enable and disable the database hints.
     *
     * @return zimbraIndexDisableDatabaseHints, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1881)
    public boolean isIndexDisableDatabaseHints() {
        return getBooleanAttr(Provisioning.A_zimbraIndexDisableDatabaseHints, false);
    }

    /**
     * flag to enable and disable the database hints.
     *
     * @param zimbraIndexDisableDatabaseHints new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1881)
    public void setIndexDisableDatabaseHints(boolean zimbraIndexDisableDatabaseHints) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexDisableDatabaseHints, zimbraIndexDisableDatabaseHints ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * flag to enable and disable the database hints.
     *
     * @param zimbraIndexDisableDatabaseHints new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1881)
    public Map<String,Object> setIndexDisableDatabaseHints(boolean zimbraIndexDisableDatabaseHints, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexDisableDatabaseHints, zimbraIndexDisableDatabaseHints ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * flag to enable and disable the database hints.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1881)
    public void unsetIndexDisableDatabaseHints() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexDisableDatabaseHints, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * flag to enable and disable the database hints.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1881)
    public Map<String,Object> unsetIndexDisableDatabaseHints(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexDisableDatabaseHints, "");
        return attrs;
    }

    /**
     * Disable perf counters for lucene indexer
     *
     * @return zimbraIndexDisablePerfCounters, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1791)
    public boolean isIndexDisablePerfCounters() {
        return getBooleanAttr(Provisioning.A_zimbraIndexDisablePerfCounters, false);
    }

    /**
     * Disable perf counters for lucene indexer
     *
     * @param zimbraIndexDisablePerfCounters new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1791)
    public void setIndexDisablePerfCounters(boolean zimbraIndexDisablePerfCounters) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexDisablePerfCounters, zimbraIndexDisablePerfCounters ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Disable perf counters for lucene indexer
     *
     * @param zimbraIndexDisablePerfCounters new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1791)
    public Map<String,Object> setIndexDisablePerfCounters(boolean zimbraIndexDisablePerfCounters, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexDisablePerfCounters, zimbraIndexDisablePerfCounters ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Disable perf counters for lucene indexer
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1791)
    public void unsetIndexDisablePerfCounters() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexDisablePerfCounters, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Disable perf counters for lucene indexer
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1791)
    public Map<String,Object> unsetIndexDisablePerfCounters(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexDisablePerfCounters, "");
        return attrs;
    }

    /**
     * Lucene index io implementation
     *
     * <p>Valid values: [mmap, nio, simple]
     *
     * @return zimbraIndexLuceneIoImpl, or null if unset and/or has invalid value
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1811)
    public ZAttrProvisioning.IndexLuceneIoImpl getIndexLuceneIoImpl() {
        try { String v = getAttr(Provisioning.A_zimbraIndexLuceneIoImpl); return v == null ? null : ZAttrProvisioning.IndexLuceneIoImpl.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Lucene index io implementation
     *
     * <p>Valid values: [mmap, nio, simple]
     *
     * @return zimbraIndexLuceneIoImpl, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1811)
    public String getIndexLuceneIoImplAsString() {
        return getAttr(Provisioning.A_zimbraIndexLuceneIoImpl, null);
    }

    /**
     * Lucene index io implementation
     *
     * <p>Valid values: [mmap, nio, simple]
     *
     * @param zimbraIndexLuceneIoImpl new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1811)
    public void setIndexLuceneIoImpl(ZAttrProvisioning.IndexLuceneIoImpl zimbraIndexLuceneIoImpl) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexLuceneIoImpl, zimbraIndexLuceneIoImpl.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Lucene index io implementation
     *
     * <p>Valid values: [mmap, nio, simple]
     *
     * @param zimbraIndexLuceneIoImpl new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1811)
    public Map<String,Object> setIndexLuceneIoImpl(ZAttrProvisioning.IndexLuceneIoImpl zimbraIndexLuceneIoImpl, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexLuceneIoImpl, zimbraIndexLuceneIoImpl.toString());
        return attrs;
    }

    /**
     * Lucene index io implementation
     *
     * <p>Valid values: [mmap, nio, simple]
     *
     * @param zimbraIndexLuceneIoImpl new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1811)
    public void setIndexLuceneIoImplAsString(String zimbraIndexLuceneIoImpl) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexLuceneIoImpl, zimbraIndexLuceneIoImpl);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Lucene index io implementation
     *
     * <p>Valid values: [mmap, nio, simple]
     *
     * @param zimbraIndexLuceneIoImpl new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1811)
    public Map<String,Object> setIndexLuceneIoImplAsString(String zimbraIndexLuceneIoImpl, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexLuceneIoImpl, zimbraIndexLuceneIoImpl);
        return attrs;
    }

    /**
     * Lucene index io implementation
     *
     * <p>Valid values: [mmap, nio, simple]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1811)
    public void unsetIndexLuceneIoImpl() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexLuceneIoImpl, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Lucene index io implementation
     *
     * <p>Valid values: [mmap, nio, simple]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1811)
    public Map<String,Object> unsetIndexLuceneIoImpl(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexLuceneIoImpl, "");
        return attrs;
    }

    /**
     * Determines how often segment indices are merged by addDocument
     * function. With smaller values, less RAM is used while indexing, and
     * searches are faster, but indexing speed is slower. With larger values,
     * more RAM is used during indexing, and while searches is slower,
     * indexing is faster. Thus larger values greater than 10 are best for
     * batch index creation, and smaller values less than 10 for indices that
     * are interactively maintained
     *
     * @return zimbraIndexLuceneMergeFactor, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1812)
    public int getIndexLuceneMergeFactor() {
        return getIntAttr(Provisioning.A_zimbraIndexLuceneMergeFactor, -1);
    }

    /**
     * Determines how often segment indices are merged by addDocument
     * function. With smaller values, less RAM is used while indexing, and
     * searches are faster, but indexing speed is slower. With larger values,
     * more RAM is used during indexing, and while searches is slower,
     * indexing is faster. Thus larger values greater than 10 are best for
     * batch index creation, and smaller values less than 10 for indices that
     * are interactively maintained
     *
     * @param zimbraIndexLuceneMergeFactor new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1812)
    public void setIndexLuceneMergeFactor(int zimbraIndexLuceneMergeFactor) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexLuceneMergeFactor, Integer.toString(zimbraIndexLuceneMergeFactor));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Determines how often segment indices are merged by addDocument
     * function. With smaller values, less RAM is used while indexing, and
     * searches are faster, but indexing speed is slower. With larger values,
     * more RAM is used during indexing, and while searches is slower,
     * indexing is faster. Thus larger values greater than 10 are best for
     * batch index creation, and smaller values less than 10 for indices that
     * are interactively maintained
     *
     * @param zimbraIndexLuceneMergeFactor new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1812)
    public Map<String,Object> setIndexLuceneMergeFactor(int zimbraIndexLuceneMergeFactor, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexLuceneMergeFactor, Integer.toString(zimbraIndexLuceneMergeFactor));
        return attrs;
    }

    /**
     * Determines how often segment indices are merged by addDocument
     * function. With smaller values, less RAM is used while indexing, and
     * searches are faster, but indexing speed is slower. With larger values,
     * more RAM is used during indexing, and while searches is slower,
     * indexing is faster. Thus larger values greater than 10 are best for
     * batch index creation, and smaller values less than 10 for indices that
     * are interactively maintained
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1812)
    public void unsetIndexLuceneMergeFactor() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexLuceneMergeFactor, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Determines how often segment indices are merged by addDocument
     * function. With smaller values, less RAM is used while indexing, and
     * searches are faster, but indexing speed is slower. With larger values,
     * more RAM is used during indexing, and while searches is slower,
     * indexing is faster. Thus larger values greater than 10 are best for
     * batch index creation, and smaller values less than 10 for indices that
     * are interactively maintained
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1812)
    public Map<String,Object> unsetIndexLuceneMergeFactor(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexLuceneMergeFactor, "");
        return attrs;
    }

    /**
     * When set to TRUE, server will commit changes to Solr after every
     * update request. When set to FALSE, Solr commits will be performed
     * according to Solr configuration. Set to TRUE for automated testing.
     * Recommended production setting is FALSE.
     *
     * @return zimbraIndexManualCommit, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1813)
    public boolean isIndexManualCommit() {
        return getBooleanAttr(Provisioning.A_zimbraIndexManualCommit, false);
    }

    /**
     * When set to TRUE, server will commit changes to Solr after every
     * update request. When set to FALSE, Solr commits will be performed
     * according to Solr configuration. Set to TRUE for automated testing.
     * Recommended production setting is FALSE.
     *
     * @param zimbraIndexManualCommit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1813)
    public void setIndexManualCommit(boolean zimbraIndexManualCommit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexManualCommit, zimbraIndexManualCommit ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When set to TRUE, server will commit changes to Solr after every
     * update request. When set to FALSE, Solr commits will be performed
     * according to Solr configuration. Set to TRUE for automated testing.
     * Recommended production setting is FALSE.
     *
     * @param zimbraIndexManualCommit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1813)
    public Map<String,Object> setIndexManualCommit(boolean zimbraIndexManualCommit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexManualCommit, zimbraIndexManualCommit ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * When set to TRUE, server will commit changes to Solr after every
     * update request. When set to FALSE, Solr commits will be performed
     * according to Solr configuration. Set to TRUE for automated testing.
     * Recommended production setting is FALSE.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1813)
    public void unsetIndexManualCommit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexManualCommit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When set to TRUE, server will commit changes to Solr after every
     * update request. When set to FALSE, Solr commits will be performed
     * according to Solr configuration. Set to TRUE for automated testing.
     * Recommended production setting is FALSE.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1813)
    public Map<String,Object> unsetIndexManualCommit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexManualCommit, "");
        return attrs;
    }

    /**
     * When batching index operations into a Mailbox transaction, the maximum
     * aggregate size of items that we will allow in a single transaction.
     *
     * @return zimbraIndexMaxTransactionBytes, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1814)
    public int getIndexMaxTransactionBytes() {
        return getIntAttr(Provisioning.A_zimbraIndexMaxTransactionBytes, -1);
    }

    /**
     * When batching index operations into a Mailbox transaction, the maximum
     * aggregate size of items that we will allow in a single transaction.
     *
     * @param zimbraIndexMaxTransactionBytes new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1814)
    public void setIndexMaxTransactionBytes(int zimbraIndexMaxTransactionBytes) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexMaxTransactionBytes, Integer.toString(zimbraIndexMaxTransactionBytes));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When batching index operations into a Mailbox transaction, the maximum
     * aggregate size of items that we will allow in a single transaction.
     *
     * @param zimbraIndexMaxTransactionBytes new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1814)
    public Map<String,Object> setIndexMaxTransactionBytes(int zimbraIndexMaxTransactionBytes, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexMaxTransactionBytes, Integer.toString(zimbraIndexMaxTransactionBytes));
        return attrs;
    }

    /**
     * When batching index operations into a Mailbox transaction, the maximum
     * aggregate size of items that we will allow in a single transaction.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1814)
    public void unsetIndexMaxTransactionBytes() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexMaxTransactionBytes, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When batching index operations into a Mailbox transaction, the maximum
     * aggregate size of items that we will allow in a single transaction.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1814)
    public Map<String,Object> unsetIndexMaxTransactionBytes(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexMaxTransactionBytes, "");
        return attrs;
    }

    /**
     * When batching index operations, the maximum number of mail items we
     * allow in a single transaction.
     *
     * @return zimbraIndexMaxTransactionItems, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1815)
    public int getIndexMaxTransactionItems() {
        return getIntAttr(Provisioning.A_zimbraIndexMaxTransactionItems, -1);
    }

    /**
     * When batching index operations, the maximum number of mail items we
     * allow in a single transaction.
     *
     * @param zimbraIndexMaxTransactionItems new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1815)
    public void setIndexMaxTransactionItems(int zimbraIndexMaxTransactionItems) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexMaxTransactionItems, Integer.toString(zimbraIndexMaxTransactionItems));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When batching index operations, the maximum number of mail items we
     * allow in a single transaction.
     *
     * @param zimbraIndexMaxTransactionItems new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1815)
    public Map<String,Object> setIndexMaxTransactionItems(int zimbraIndexMaxTransactionItems, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexMaxTransactionItems, Integer.toString(zimbraIndexMaxTransactionItems));
        return attrs;
    }

    /**
     * When batching index operations, the maximum number of mail items we
     * allow in a single transaction.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1815)
    public void unsetIndexMaxTransactionItems() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexMaxTransactionItems, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When batching index operations, the maximum number of mail items we
     * allow in a single transaction.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1815)
    public Map<String,Object> unsetIndexMaxTransactionItems(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexMaxTransactionItems, "");
        return attrs;
    }

    /**
     * Time in milliseconds that mailstore will wait between attempts to
     * request status from an external indexing service (Solr or SolrCloud).
     *
     * @return zimbraIndexPollingInterval, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2045)
    public int getIndexPollingInterval() {
        return getIntAttr(Provisioning.A_zimbraIndexPollingInterval, -1);
    }

    /**
     * Time in milliseconds that mailstore will wait between attempts to
     * request status from an external indexing service (Solr or SolrCloud).
     *
     * @param zimbraIndexPollingInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2045)
    public void setIndexPollingInterval(int zimbraIndexPollingInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexPollingInterval, Integer.toString(zimbraIndexPollingInterval));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time in milliseconds that mailstore will wait between attempts to
     * request status from an external indexing service (Solr or SolrCloud).
     *
     * @param zimbraIndexPollingInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2045)
    public Map<String,Object> setIndexPollingInterval(int zimbraIndexPollingInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexPollingInterval, Integer.toString(zimbraIndexPollingInterval));
        return attrs;
    }

    /**
     * Time in milliseconds that mailstore will wait between attempts to
     * request status from an external indexing service (Solr or SolrCloud).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2045)
    public void unsetIndexPollingInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexPollingInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time in milliseconds that mailstore will wait between attempts to
     * request status from an external indexing service (Solr or SolrCloud).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2045)
    public Map<String,Object> unsetIndexPollingInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexPollingInterval, "");
        return attrs;
    }

    /**
     * Maximum number of threads for re-index. Re-index threads are not
     * pooled.
     *
     * @return zimbraIndexReIndexThreads, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1862)
    public int getIndexReIndexThreads() {
        return getIntAttr(Provisioning.A_zimbraIndexReIndexThreads, -1);
    }

    /**
     * Maximum number of threads for re-index. Re-index threads are not
     * pooled.
     *
     * @param zimbraIndexReIndexThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1862)
    public void setIndexReIndexThreads(int zimbraIndexReIndexThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReIndexThreads, Integer.toString(zimbraIndexReIndexThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of threads for re-index. Re-index threads are not
     * pooled.
     *
     * @param zimbraIndexReIndexThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1862)
    public Map<String,Object> setIndexReIndexThreads(int zimbraIndexReIndexThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReIndexThreads, Integer.toString(zimbraIndexReIndexThreads));
        return attrs;
    }

    /**
     * Maximum number of threads for re-index. Re-index threads are not
     * pooled.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1862)
    public void unsetIndexReIndexThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReIndexThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of threads for re-index. Re-index threads are not
     * pooled.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1862)
    public Map<String,Object> unsetIndexReIndexThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReIndexThreads, "");
        return attrs;
    }

    /**
     * Maximum number of IndexReaders in the search index cache
     *
     * @return zimbraIndexReaderCacheSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1790)
    public int getIndexReaderCacheSize() {
        return getIntAttr(Provisioning.A_zimbraIndexReaderCacheSize, -1);
    }

    /**
     * Maximum number of IndexReaders in the search index cache
     *
     * @param zimbraIndexReaderCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1790)
    public void setIndexReaderCacheSize(int zimbraIndexReaderCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReaderCacheSize, Integer.toString(zimbraIndexReaderCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of IndexReaders in the search index cache
     *
     * @param zimbraIndexReaderCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1790)
    public Map<String,Object> setIndexReaderCacheSize(int zimbraIndexReaderCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReaderCacheSize, Integer.toString(zimbraIndexReaderCacheSize));
        return attrs;
    }

    /**
     * Maximum number of IndexReaders in the search index cache
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1790)
    public void unsetIndexReaderCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReaderCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of IndexReaders in the search index cache
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1790)
    public Map<String,Object> unsetIndexReaderCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReaderCacheSize, "");
        return attrs;
    }

    /**
     * TTL in seconds for index reader cache. If idle for longer than this
     * value (seconds) then remove the IndexReader from the cache.. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getIndexReaderCacheTtlAsString to access value as a string.
     *
     * @see #getIndexReaderCacheTtlAsString()
     *
     * @return zimbraIndexReaderCacheTtl in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1817)
    public long getIndexReaderCacheTtl() {
        return getTimeInterval(Provisioning.A_zimbraIndexReaderCacheTtl, -1L);
    }

    /**
     * TTL in seconds for index reader cache. If idle for longer than this
     * value (seconds) then remove the IndexReader from the cache.. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraIndexReaderCacheTtl, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1817)
    public String getIndexReaderCacheTtlAsString() {
        return getAttr(Provisioning.A_zimbraIndexReaderCacheTtl, null);
    }

    /**
     * TTL in seconds for index reader cache. If idle for longer than this
     * value (seconds) then remove the IndexReader from the cache.. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraIndexReaderCacheTtl new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1817)
    public void setIndexReaderCacheTtl(String zimbraIndexReaderCacheTtl) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReaderCacheTtl, zimbraIndexReaderCacheTtl);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * TTL in seconds for index reader cache. If idle for longer than this
     * value (seconds) then remove the IndexReader from the cache.. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraIndexReaderCacheTtl new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1817)
    public Map<String,Object> setIndexReaderCacheTtl(String zimbraIndexReaderCacheTtl, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReaderCacheTtl, zimbraIndexReaderCacheTtl);
        return attrs;
    }

    /**
     * TTL in seconds for index reader cache. If idle for longer than this
     * value (seconds) then remove the IndexReader from the cache.. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1817)
    public void unsetIndexReaderCacheTtl() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReaderCacheTtl, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * TTL in seconds for index reader cache. If idle for longer than this
     * value (seconds) then remove the IndexReader from the cache.. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1817)
    public Map<String,Object> unsetIndexReaderCacheTtl(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReaderCacheTtl, "");
        return attrs;
    }

    /**
     * The maximum number of IndexReaders in the GAL search index cache. The
     * GAL sync account Lucene index is cached separately with no automatic
     * eviction.
     *
     * @return zimbraIndexReaderGalSyncCacheSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1846)
    public int getIndexReaderGalSyncCacheSize() {
        return getIntAttr(Provisioning.A_zimbraIndexReaderGalSyncCacheSize, -1);
    }

    /**
     * The maximum number of IndexReaders in the GAL search index cache. The
     * GAL sync account Lucene index is cached separately with no automatic
     * eviction.
     *
     * @param zimbraIndexReaderGalSyncCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1846)
    public void setIndexReaderGalSyncCacheSize(int zimbraIndexReaderGalSyncCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReaderGalSyncCacheSize, Integer.toString(zimbraIndexReaderGalSyncCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum number of IndexReaders in the GAL search index cache. The
     * GAL sync account Lucene index is cached separately with no automatic
     * eviction.
     *
     * @param zimbraIndexReaderGalSyncCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1846)
    public Map<String,Object> setIndexReaderGalSyncCacheSize(int zimbraIndexReaderGalSyncCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReaderGalSyncCacheSize, Integer.toString(zimbraIndexReaderGalSyncCacheSize));
        return attrs;
    }

    /**
     * The maximum number of IndexReaders in the GAL search index cache. The
     * GAL sync account Lucene index is cached separately with no automatic
     * eviction.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1846)
    public void unsetIndexReaderGalSyncCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReaderGalSyncCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum number of IndexReaders in the GAL search index cache. The
     * GAL sync account Lucene index is cached separately with no automatic
     * eviction.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1846)
    public Map<String,Object> unsetIndexReaderGalSyncCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReaderGalSyncCacheSize, "");
        return attrs;
    }

    /**
     * Time in milliseconds that mailstore will wait for an external indexing
     * service to fully replicate an index for a single mailbox. When using
     * SolrCloud, this is the time that a mailstore will wait for all
     * replicas of a solr collection to go live and sync up to the leader.
     *
     * @return zimbraIndexReplicationTimeout, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2042)
    public int getIndexReplicationTimeout() {
        return getIntAttr(Provisioning.A_zimbraIndexReplicationTimeout, -1);
    }

    /**
     * Time in milliseconds that mailstore will wait for an external indexing
     * service to fully replicate an index for a single mailbox. When using
     * SolrCloud, this is the time that a mailstore will wait for all
     * replicas of a solr collection to go live and sync up to the leader.
     *
     * @param zimbraIndexReplicationTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2042)
    public void setIndexReplicationTimeout(int zimbraIndexReplicationTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReplicationTimeout, Integer.toString(zimbraIndexReplicationTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time in milliseconds that mailstore will wait for an external indexing
     * service to fully replicate an index for a single mailbox. When using
     * SolrCloud, this is the time that a mailstore will wait for all
     * replicas of a solr collection to go live and sync up to the leader.
     *
     * @param zimbraIndexReplicationTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2042)
    public Map<String,Object> setIndexReplicationTimeout(int zimbraIndexReplicationTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReplicationTimeout, Integer.toString(zimbraIndexReplicationTimeout));
        return attrs;
    }

    /**
     * Time in milliseconds that mailstore will wait for an external indexing
     * service to fully replicate an index for a single mailbox. When using
     * SolrCloud, this is the time that a mailstore will wait for all
     * replicas of a solr collection to go live and sync up to the leader.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2042)
    public void unsetIndexReplicationTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReplicationTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time in milliseconds that mailstore will wait for an external indexing
     * service to fully replicate an index for a single mailbox. When using
     * SolrCloud, this is the time that a mailstore will wait for all
     * replicas of a solr collection to go live and sync up to the leader.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2042)
    public Map<String,Object> unsetIndexReplicationTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexReplicationTimeout, "");
        return attrs;
    }

    /**
     * Time in milliseconds that mailstore will wait for an external indexing
     * service to restore a single mailbox index.
     *
     * @return zimbraIndexRestoreTimeout, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2044)
    public int getIndexRestoreTimeout() {
        return getIntAttr(Provisioning.A_zimbraIndexRestoreTimeout, -1);
    }

    /**
     * Time in milliseconds that mailstore will wait for an external indexing
     * service to restore a single mailbox index.
     *
     * @param zimbraIndexRestoreTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2044)
    public void setIndexRestoreTimeout(int zimbraIndexRestoreTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexRestoreTimeout, Integer.toString(zimbraIndexRestoreTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time in milliseconds that mailstore will wait for an external indexing
     * service to restore a single mailbox index.
     *
     * @param zimbraIndexRestoreTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2044)
    public Map<String,Object> setIndexRestoreTimeout(int zimbraIndexRestoreTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexRestoreTimeout, Integer.toString(zimbraIndexRestoreTimeout));
        return attrs;
    }

    /**
     * Time in milliseconds that mailstore will wait for an external indexing
     * service to restore a single mailbox index.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2044)
    public void unsetIndexRestoreTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexRestoreTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time in milliseconds that mailstore will wait for an external indexing
     * service to restore a single mailbox index.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2044)
    public Map<String,Object> unsetIndexRestoreTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexRestoreTimeout, "");
        return attrs;
    }

    /**
     * Tagged item count join query cut off
     *
     * @return zimbraIndexTaggedItemCountJoinQueryCutoff, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1882)
    public int getIndexTaggedItemCountJoinQueryCutoff() {
        return getIntAttr(Provisioning.A_zimbraIndexTaggedItemCountJoinQueryCutoff, -1);
    }

    /**
     * Tagged item count join query cut off
     *
     * @param zimbraIndexTaggedItemCountJoinQueryCutoff new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1882)
    public void setIndexTaggedItemCountJoinQueryCutoff(int zimbraIndexTaggedItemCountJoinQueryCutoff) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexTaggedItemCountJoinQueryCutoff, Integer.toString(zimbraIndexTaggedItemCountJoinQueryCutoff));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Tagged item count join query cut off
     *
     * @param zimbraIndexTaggedItemCountJoinQueryCutoff new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1882)
    public Map<String,Object> setIndexTaggedItemCountJoinQueryCutoff(int zimbraIndexTaggedItemCountJoinQueryCutoff, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexTaggedItemCountJoinQueryCutoff, Integer.toString(zimbraIndexTaggedItemCountJoinQueryCutoff));
        return attrs;
    }

    /**
     * Tagged item count join query cut off
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1882)
    public void unsetIndexTaggedItemCountJoinQueryCutoff() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexTaggedItemCountJoinQueryCutoff, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Tagged item count join query cut off
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1882)
    public Map<String,Object> unsetIndexTaggedItemCountJoinQueryCutoff(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexTaggedItemCountJoinQueryCutoff, "");
        return attrs;
    }

    /**
     * Minimum allowable timeout (seconds) specified to NoOpRequest
     *
     * @return zimbraIndexTermsCacheSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1871)
    public int getIndexTermsCacheSize() {
        return getIntAttr(Provisioning.A_zimbraIndexTermsCacheSize, -1);
    }

    /**
     * Minimum allowable timeout (seconds) specified to NoOpRequest
     *
     * @param zimbraIndexTermsCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1871)
    public void setIndexTermsCacheSize(int zimbraIndexTermsCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexTermsCacheSize, Integer.toString(zimbraIndexTermsCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum allowable timeout (seconds) specified to NoOpRequest
     *
     * @param zimbraIndexTermsCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1871)
    public Map<String,Object> setIndexTermsCacheSize(int zimbraIndexTermsCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexTermsCacheSize, Integer.toString(zimbraIndexTermsCacheSize));
        return attrs;
    }

    /**
     * Minimum allowable timeout (seconds) specified to NoOpRequest
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1871)
    public void unsetIndexTermsCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexTermsCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum allowable timeout (seconds) specified to NoOpRequest
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1871)
    public Map<String,Object> unsetIndexTermsCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexTermsCacheSize, "");
        return attrs;
    }

    /**
     * No of threads used by lucene indexer
     *
     * @return zimbraIndexThreads, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1781)
    public int getIndexThreads() {
        return getIntAttr(Provisioning.A_zimbraIndexThreads, -1);
    }

    /**
     * No of threads used by lucene indexer
     *
     * @param zimbraIndexThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1781)
    public void setIndexThreads(int zimbraIndexThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexThreads, Integer.toString(zimbraIndexThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * No of threads used by lucene indexer
     *
     * @param zimbraIndexThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1781)
    public Map<String,Object> setIndexThreads(int zimbraIndexThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexThreads, Integer.toString(zimbraIndexThreads));
        return attrs;
    }

    /**
     * No of threads used by lucene indexer
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1781)
    public void unsetIndexThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * No of threads used by lucene indexer
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1781)
    public Map<String,Object> unsetIndexThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexThreads, "");
        return attrs;
    }

    /**
     * URL for accessing extneral indexing service. First part of the URL
     * before the first colon identifies implementation Factory and should be
     * registered by calling IndexStore.registerFactory(prefix, classname).
     * ZCS ships with two index Factory implementations: 1) SolrIndex
     * identified by prefix &quot;solr&quot; 2) SolrCloudIndex indetified by
     * prefix &quot;solrcloud&quot;
     *
     * @return zimbraIndexURL, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1669)
    public String getIndexURL() {
        return getAttr(Provisioning.A_zimbraIndexURL, null);
    }

    /**
     * URL for accessing extneral indexing service. First part of the URL
     * before the first colon identifies implementation Factory and should be
     * registered by calling IndexStore.registerFactory(prefix, classname).
     * ZCS ships with two index Factory implementations: 1) SolrIndex
     * identified by prefix &quot;solr&quot; 2) SolrCloudIndex indetified by
     * prefix &quot;solrcloud&quot;
     *
     * @param zimbraIndexURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1669)
    public void setIndexURL(String zimbraIndexURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexURL, zimbraIndexURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL for accessing extneral indexing service. First part of the URL
     * before the first colon identifies implementation Factory and should be
     * registered by calling IndexStore.registerFactory(prefix, classname).
     * ZCS ships with two index Factory implementations: 1) SolrIndex
     * identified by prefix &quot;solr&quot; 2) SolrCloudIndex indetified by
     * prefix &quot;solrcloud&quot;
     *
     * @param zimbraIndexURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1669)
    public Map<String,Object> setIndexURL(String zimbraIndexURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexURL, zimbraIndexURL);
        return attrs;
    }

    /**
     * URL for accessing extneral indexing service. First part of the URL
     * before the first colon identifies implementation Factory and should be
     * registered by calling IndexStore.registerFactory(prefix, classname).
     * ZCS ships with two index Factory implementations: 1) SolrIndex
     * identified by prefix &quot;solr&quot; 2) SolrCloudIndex indetified by
     * prefix &quot;solrcloud&quot;
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1669)
    public void unsetIndexURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL for accessing extneral indexing service. First part of the URL
     * before the first colon identifies implementation Factory and should be
     * registered by calling IndexStore.registerFactory(prefix, classname).
     * ZCS ships with two index Factory implementations: 1) SolrIndex
     * identified by prefix &quot;solr&quot; 2) SolrCloudIndex indetified by
     * prefix &quot;solrcloud&quot;
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1669)
    public Map<String,Object> unsetIndexURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexURL, "");
        return attrs;
    }

    /**
     * Maximum wildcard expansions for each individual term in the query.
     *
     * @return zimbraIndexWildcardMaxTermsExpanded, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1847)
    public int getIndexWildcardMaxTermsExpanded() {
        return getIntAttr(Provisioning.A_zimbraIndexWildcardMaxTermsExpanded, -1);
    }

    /**
     * Maximum wildcard expansions for each individual term in the query.
     *
     * @param zimbraIndexWildcardMaxTermsExpanded new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1847)
    public void setIndexWildcardMaxTermsExpanded(int zimbraIndexWildcardMaxTermsExpanded) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexWildcardMaxTermsExpanded, Integer.toString(zimbraIndexWildcardMaxTermsExpanded));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum wildcard expansions for each individual term in the query.
     *
     * @param zimbraIndexWildcardMaxTermsExpanded new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1847)
    public Map<String,Object> setIndexWildcardMaxTermsExpanded(int zimbraIndexWildcardMaxTermsExpanded, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexWildcardMaxTermsExpanded, Integer.toString(zimbraIndexWildcardMaxTermsExpanded));
        return attrs;
    }

    /**
     * Maximum wildcard expansions for each individual term in the query.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1847)
    public void unsetIndexWildcardMaxTermsExpanded() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexWildcardMaxTermsExpanded, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum wildcard expansions for each individual term in the query.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1847)
    public Map<String,Object> unsetIndexWildcardMaxTermsExpanded(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexWildcardMaxTermsExpanded, "");
        return attrs;
    }

    /**
     * Maximum number of items that can be held in memory while queued for
     * indexing
     *
     * @return zimbraIndexingQueueMaxSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1786)
    public int getIndexingQueueMaxSize() {
        return getIntAttr(Provisioning.A_zimbraIndexingQueueMaxSize, -1);
    }

    /**
     * Maximum number of items that can be held in memory while queued for
     * indexing
     *
     * @param zimbraIndexingQueueMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1786)
    public void setIndexingQueueMaxSize(int zimbraIndexingQueueMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexingQueueMaxSize, Integer.toString(zimbraIndexingQueueMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of items that can be held in memory while queued for
     * indexing
     *
     * @param zimbraIndexingQueueMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1786)
    public Map<String,Object> setIndexingQueueMaxSize(int zimbraIndexingQueueMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexingQueueMaxSize, Integer.toString(zimbraIndexingQueueMaxSize));
        return attrs;
    }

    /**
     * Maximum number of items that can be held in memory while queued for
     * indexing
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1786)
    public void unsetIndexingQueueMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexingQueueMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of items that can be held in memory while queued for
     * indexing
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1786)
    public Map<String,Object> unsetIndexingQueueMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexingQueueMaxSize, "");
        return attrs;
    }

    /**
     * Milliseconds that mailstore will wait between attempts to take/put an
     * indexing task from/to a shared indexing queue.
     *
     * @return zimbraIndexingQueuePollingInterval, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1974)
    public int getIndexingQueuePollingInterval() {
        return getIntAttr(Provisioning.A_zimbraIndexingQueuePollingInterval, -1);
    }

    /**
     * Milliseconds that mailstore will wait between attempts to take/put an
     * indexing task from/to a shared indexing queue.
     *
     * @param zimbraIndexingQueuePollingInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1974)
    public void setIndexingQueuePollingInterval(int zimbraIndexingQueuePollingInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexingQueuePollingInterval, Integer.toString(zimbraIndexingQueuePollingInterval));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Milliseconds that mailstore will wait between attempts to take/put an
     * indexing task from/to a shared indexing queue.
     *
     * @param zimbraIndexingQueuePollingInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1974)
    public Map<String,Object> setIndexingQueuePollingInterval(int zimbraIndexingQueuePollingInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexingQueuePollingInterval, Integer.toString(zimbraIndexingQueuePollingInterval));
        return attrs;
    }

    /**
     * Milliseconds that mailstore will wait between attempts to take/put an
     * indexing task from/to a shared indexing queue.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1974)
    public void unsetIndexingQueuePollingInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexingQueuePollingInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Milliseconds that mailstore will wait between attempts to take/put an
     * indexing task from/to a shared indexing queue.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1974)
    public Map<String,Object> unsetIndexingQueuePollingInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexingQueuePollingInterval, "");
        return attrs;
    }

    /**
     * Class that implements access to shared indexing queue. When this
     * attribute is empty, servers will send documents to Solr for indexing
     * as soon as documents arrive.
     *
     * @return zimbraIndexingQueueProvider, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1833)
    public String getIndexingQueueProvider() {
        return getAttr(Provisioning.A_zimbraIndexingQueueProvider, null);
    }

    /**
     * Class that implements access to shared indexing queue. When this
     * attribute is empty, servers will send documents to Solr for indexing
     * as soon as documents arrive.
     *
     * @param zimbraIndexingQueueProvider new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1833)
    public void setIndexingQueueProvider(String zimbraIndexingQueueProvider) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexingQueueProvider, zimbraIndexingQueueProvider);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Class that implements access to shared indexing queue. When this
     * attribute is empty, servers will send documents to Solr for indexing
     * as soon as documents arrive.
     *
     * @param zimbraIndexingQueueProvider new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1833)
    public Map<String,Object> setIndexingQueueProvider(String zimbraIndexingQueueProvider, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexingQueueProvider, zimbraIndexingQueueProvider);
        return attrs;
    }

    /**
     * Class that implements access to shared indexing queue. When this
     * attribute is empty, servers will send documents to Solr for indexing
     * as soon as documents arrive.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1833)
    public void unsetIndexingQueueProvider() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexingQueueProvider, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Class that implements access to shared indexing queue. When this
     * attribute is empty, servers will send documents to Solr for indexing
     * as soon as documents arrive.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1833)
    public Map<String,Object> unsetIndexingQueueProvider(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexingQueueProvider, "");
        return attrs;
    }

    /**
     * Time in milliseconds that mailstore will wait for space to free up in
     * the shared indexing queue. Increase this value if you are reindexing
     * several large mailboxes simultaneously.
     *
     * @return zimbraIndexingQueueTimeout, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2046)
    public int getIndexingQueueTimeout() {
        return getIntAttr(Provisioning.A_zimbraIndexingQueueTimeout, -1);
    }

    /**
     * Time in milliseconds that mailstore will wait for space to free up in
     * the shared indexing queue. Increase this value if you are reindexing
     * several large mailboxes simultaneously.
     *
     * @param zimbraIndexingQueueTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2046)
    public void setIndexingQueueTimeout(int zimbraIndexingQueueTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexingQueueTimeout, Integer.toString(zimbraIndexingQueueTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time in milliseconds that mailstore will wait for space to free up in
     * the shared indexing queue. Increase this value if you are reindexing
     * several large mailboxes simultaneously.
     *
     * @param zimbraIndexingQueueTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2046)
    public Map<String,Object> setIndexingQueueTimeout(int zimbraIndexingQueueTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexingQueueTimeout, Integer.toString(zimbraIndexingQueueTimeout));
        return attrs;
    }

    /**
     * Time in milliseconds that mailstore will wait for space to free up in
     * the shared indexing queue. Increase this value if you are reindexing
     * several large mailboxes simultaneously.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2046)
    public void unsetIndexingQueueTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexingQueueTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time in milliseconds that mailstore will wait for space to free up in
     * the shared indexing queue. Increase this value if you are reindexing
     * several large mailboxes simultaneously.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2046)
    public Map<String,Object> unsetIndexingQueueTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIndexingQueueTimeout, "");
        return attrs;
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the minimum time between current req and last req from the
     * same IP before this suspended IP will be reinstated
     *
     * @return zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1614)
    public int getInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating() {
        return getIntAttr(Provisioning.A_zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating, -1);
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the minimum time between current req and last req from the
     * same IP before this suspended IP will be reinstated
     *
     * @param zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1614)
    public void setInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating(int zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating, Integer.toString(zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the minimum time between current req and last req from the
     * same IP before this suspended IP will be reinstated
     *
     * @param zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1614)
    public Map<String,Object> setInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating(int zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating, Integer.toString(zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating));
        return attrs;
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the minimum time between current req and last req from the
     * same IP before this suspended IP will be reinstated
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1614)
    public void unsetInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the minimum time between current req and last req from the
     * same IP before this suspended IP will be reinstated
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1614)
    public Map<String,Object> unsetInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating, "");
        return attrs;
    }

    /**
     * This attribute is used for failed authentication requests.This is a
     * DOSFilter style check for repeated failed logins from IP, if set to 0
     * no check happens, else failed login is recorded.
     *
     * @return zimbraInvalidLoginFilterMaxFailedLogin, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1613)
    public int getInvalidLoginFilterMaxFailedLogin() {
        return getIntAttr(Provisioning.A_zimbraInvalidLoginFilterMaxFailedLogin, -1);
    }

    /**
     * This attribute is used for failed authentication requests.This is a
     * DOSFilter style check for repeated failed logins from IP, if set to 0
     * no check happens, else failed login is recorded.
     *
     * @param zimbraInvalidLoginFilterMaxFailedLogin new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1613)
    public void setInvalidLoginFilterMaxFailedLogin(int zimbraInvalidLoginFilterMaxFailedLogin) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterMaxFailedLogin, Integer.toString(zimbraInvalidLoginFilterMaxFailedLogin));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used for failed authentication requests.This is a
     * DOSFilter style check for repeated failed logins from IP, if set to 0
     * no check happens, else failed login is recorded.
     *
     * @param zimbraInvalidLoginFilterMaxFailedLogin new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1613)
    public Map<String,Object> setInvalidLoginFilterMaxFailedLogin(int zimbraInvalidLoginFilterMaxFailedLogin, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterMaxFailedLogin, Integer.toString(zimbraInvalidLoginFilterMaxFailedLogin));
        return attrs;
    }

    /**
     * This attribute is used for failed authentication requests.This is a
     * DOSFilter style check for repeated failed logins from IP, if set to 0
     * no check happens, else failed login is recorded.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1613)
    public void unsetInvalidLoginFilterMaxFailedLogin() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterMaxFailedLogin, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used for failed authentication requests.This is a
     * DOSFilter style check for repeated failed logins from IP, if set to 0
     * no check happens, else failed login is recorded.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1613)
    public Map<String,Object> unsetInvalidLoginFilterMaxFailedLogin(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterMaxFailedLogin, "");
        return attrs;
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the max size of data structures that holds the list of
     * failed logins
     *
     * @return zimbraInvalidLoginFilterMaxSizeOfFailedIpDb, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1618)
    public int getInvalidLoginFilterMaxSizeOfFailedIpDb() {
        return getIntAttr(Provisioning.A_zimbraInvalidLoginFilterMaxSizeOfFailedIpDb, -1);
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the max size of data structures that holds the list of
     * failed logins
     *
     * @param zimbraInvalidLoginFilterMaxSizeOfFailedIpDb new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1618)
    public void setInvalidLoginFilterMaxSizeOfFailedIpDb(int zimbraInvalidLoginFilterMaxSizeOfFailedIpDb) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterMaxSizeOfFailedIpDb, Integer.toString(zimbraInvalidLoginFilterMaxSizeOfFailedIpDb));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the max size of data structures that holds the list of
     * failed logins
     *
     * @param zimbraInvalidLoginFilterMaxSizeOfFailedIpDb new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1618)
    public Map<String,Object> setInvalidLoginFilterMaxSizeOfFailedIpDb(int zimbraInvalidLoginFilterMaxSizeOfFailedIpDb, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterMaxSizeOfFailedIpDb, Integer.toString(zimbraInvalidLoginFilterMaxSizeOfFailedIpDb));
        return attrs;
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the max size of data structures that holds the list of
     * failed logins
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1618)
    public void unsetInvalidLoginFilterMaxSizeOfFailedIpDb() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterMaxSizeOfFailedIpDb, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the max size of data structures that holds the list of
     * failed logins
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1618)
    public Map<String,Object> unsetInvalidLoginFilterMaxSizeOfFailedIpDb(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterMaxSizeOfFailedIpDb, "");
        return attrs;
    }

    /**
     * This attribute is used for failed authentication requests. Interval at
     * which Task to reinstate IPs suspended as part of ZimbraInvalidLoging
     * filter are run.
     *
     * @return zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1615)
    public int getInvalidLoginFilterReinstateIpTaskIntervalInMin() {
        return getIntAttr(Provisioning.A_zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin, -1);
    }

    /**
     * This attribute is used for failed authentication requests. Interval at
     * which Task to reinstate IPs suspended as part of ZimbraInvalidLoging
     * filter are run.
     *
     * @param zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1615)
    public void setInvalidLoginFilterReinstateIpTaskIntervalInMin(int zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin, Integer.toString(zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used for failed authentication requests. Interval at
     * which Task to reinstate IPs suspended as part of ZimbraInvalidLoging
     * filter are run.
     *
     * @param zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1615)
    public Map<String,Object> setInvalidLoginFilterReinstateIpTaskIntervalInMin(int zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin, Integer.toString(zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin));
        return attrs;
    }

    /**
     * This attribute is used for failed authentication requests. Interval at
     * which Task to reinstate IPs suspended as part of ZimbraInvalidLoging
     * filter are run.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1615)
    public void unsetInvalidLoginFilterReinstateIpTaskIntervalInMin() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used for failed authentication requests. Interval at
     * which Task to reinstate IPs suspended as part of ZimbraInvalidLoging
     * filter are run.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1615)
    public Map<String,Object> unsetInvalidLoginFilterReinstateIpTaskIntervalInMin(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin, "");
        return attrs;
    }

    /**
     * Maximum number of item to perform an ItemAction on at a time.
     *
     * @return zimbraItemActionBatchSize, or -1 if unset
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1451)
    public int getItemActionBatchSize() {
        return getIntAttr(Provisioning.A_zimbraItemActionBatchSize, -1);
    }

    /**
     * Maximum number of item to perform an ItemAction on at a time.
     *
     * @param zimbraItemActionBatchSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1451)
    public void setItemActionBatchSize(int zimbraItemActionBatchSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraItemActionBatchSize, Integer.toString(zimbraItemActionBatchSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of item to perform an ItemAction on at a time.
     *
     * @param zimbraItemActionBatchSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1451)
    public Map<String,Object> setItemActionBatchSize(int zimbraItemActionBatchSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraItemActionBatchSize, Integer.toString(zimbraItemActionBatchSize));
        return attrs;
    }

    /**
     * Maximum number of item to perform an ItemAction on at a time.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1451)
    public void unsetItemActionBatchSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraItemActionBatchSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of item to perform an ItemAction on at a time.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1451)
    public Map<String,Object> unsetItemActionBatchSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraItemActionBatchSize, "");
        return attrs;
    }

    /**
     * Enabled Kerberos debugging
     *
     * @return zimbraKerberosDebugEnabled, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1798)
    public boolean isKerberosDebugEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraKerberosDebugEnabled, false);
    }

    /**
     * Enabled Kerberos debugging
     *
     * @param zimbraKerberosDebugEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1798)
    public void setKerberosDebugEnabled(boolean zimbraKerberosDebugEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraKerberosDebugEnabled, zimbraKerberosDebugEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enabled Kerberos debugging
     *
     * @param zimbraKerberosDebugEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1798)
    public Map<String,Object> setKerberosDebugEnabled(boolean zimbraKerberosDebugEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraKerberosDebugEnabled, zimbraKerberosDebugEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Enabled Kerberos debugging
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1798)
    public void unsetKerberosDebugEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraKerberosDebugEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enabled Kerberos debugging
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1798)
    public Map<String,Object> unsetKerberosDebugEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraKerberosDebugEnabled, "");
        return attrs;
    }

    /**
     * Flag to get Kerobos Service Principal from Interface Address
     *
     * @return zimbraKerobosServicePrincipalFromInterfaceAddress, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1799)
    public boolean isKerobosServicePrincipalFromInterfaceAddress() {
        return getBooleanAttr(Provisioning.A_zimbraKerobosServicePrincipalFromInterfaceAddress, false);
    }

    /**
     * Flag to get Kerobos Service Principal from Interface Address
     *
     * @param zimbraKerobosServicePrincipalFromInterfaceAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1799)
    public void setKerobosServicePrincipalFromInterfaceAddress(boolean zimbraKerobosServicePrincipalFromInterfaceAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraKerobosServicePrincipalFromInterfaceAddress, zimbraKerobosServicePrincipalFromInterfaceAddress ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to get Kerobos Service Principal from Interface Address
     *
     * @param zimbraKerobosServicePrincipalFromInterfaceAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1799)
    public Map<String,Object> setKerobosServicePrincipalFromInterfaceAddress(boolean zimbraKerobosServicePrincipalFromInterfaceAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraKerobosServicePrincipalFromInterfaceAddress, zimbraKerobosServicePrincipalFromInterfaceAddress ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to get Kerobos Service Principal from Interface Address
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1799)
    public void unsetKerobosServicePrincipalFromInterfaceAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraKerobosServicePrincipalFromInterfaceAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to get Kerobos Service Principal from Interface Address
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1799)
    public Map<String,Object> unsetKerobosServicePrincipalFromInterfaceAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraKerobosServicePrincipalFromInterfaceAddress, "");
        return attrs;
    }

    /**
     * Maximum duration beyond which the mailbox must be scheduled for purge
     * irrespective of whether it is loaded into memory or not.. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getLastPurgeMaxDurationAsString to access value as a string.
     *
     * @see #getLastPurgeMaxDurationAsString()
     *
     * @return zimbraLastPurgeMaxDuration in millseconds, or -1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1382)
    public long getLastPurgeMaxDuration() {
        return getTimeInterval(Provisioning.A_zimbraLastPurgeMaxDuration, -1L);
    }

    /**
     * Maximum duration beyond which the mailbox must be scheduled for purge
     * irrespective of whether it is loaded into memory or not.. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraLastPurgeMaxDuration, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1382)
    public String getLastPurgeMaxDurationAsString() {
        return getAttr(Provisioning.A_zimbraLastPurgeMaxDuration, null);
    }

    /**
     * Maximum duration beyond which the mailbox must be scheduled for purge
     * irrespective of whether it is loaded into memory or not.. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraLastPurgeMaxDuration new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1382)
    public void setLastPurgeMaxDuration(String zimbraLastPurgeMaxDuration) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLastPurgeMaxDuration, zimbraLastPurgeMaxDuration);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum duration beyond which the mailbox must be scheduled for purge
     * irrespective of whether it is loaded into memory or not.. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraLastPurgeMaxDuration new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1382)
    public Map<String,Object> setLastPurgeMaxDuration(String zimbraLastPurgeMaxDuration, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLastPurgeMaxDuration, zimbraLastPurgeMaxDuration);
        return attrs;
    }

    /**
     * Maximum duration beyond which the mailbox must be scheduled for purge
     * irrespective of whether it is loaded into memory or not.. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1382)
    public void unsetLastPurgeMaxDuration() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLastPurgeMaxDuration, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum duration beyond which the mailbox must be scheduled for purge
     * irrespective of whether it is loaded into memory or not.. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1382)
    public Map<String,Object> unsetLastPurgeMaxDuration(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLastPurgeMaxDuration, "");
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of Account objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getLdapCacheAccountMaxAgeAsString to access value as a string.
     *
     * @see #getLdapCacheAccountMaxAgeAsString()
     *
     * @return zimbraLdapCacheAccountMaxAge in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1984)
    public long getLdapCacheAccountMaxAge() {
        return getTimeInterval(Provisioning.A_zimbraLdapCacheAccountMaxAge, -1L);
    }

    /**
     * Maximum age of entries in the in memory cache of Account objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraLdapCacheAccountMaxAge, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1984)
    public String getLdapCacheAccountMaxAgeAsString() {
        return getAttr(Provisioning.A_zimbraLdapCacheAccountMaxAge, null);
    }

    /**
     * Maximum age of entries in the in memory cache of Account objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheAccountMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1984)
    public void setLdapCacheAccountMaxAge(String zimbraLdapCacheAccountMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheAccountMaxAge, zimbraLdapCacheAccountMaxAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of Account objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheAccountMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1984)
    public Map<String,Object> setLdapCacheAccountMaxAge(String zimbraLdapCacheAccountMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheAccountMaxAge, zimbraLdapCacheAccountMaxAge);
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of Account objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1984)
    public void unsetLdapCacheAccountMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheAccountMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of Account objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1984)
    public Map<String,Object> unsetLdapCacheAccountMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheAccountMaxAge, "");
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of Account objects
     *
     * @return zimbraLdapCacheAccountMaxSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1983)
    public int getLdapCacheAccountMaxSize() {
        return getIntAttr(Provisioning.A_zimbraLdapCacheAccountMaxSize, -1);
    }

    /**
     * Maximum number of entries in the in memory cache of Account objects
     *
     * @param zimbraLdapCacheAccountMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1983)
    public void setLdapCacheAccountMaxSize(int zimbraLdapCacheAccountMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheAccountMaxSize, Integer.toString(zimbraLdapCacheAccountMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of Account objects
     *
     * @param zimbraLdapCacheAccountMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1983)
    public Map<String,Object> setLdapCacheAccountMaxSize(int zimbraLdapCacheAccountMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheAccountMaxSize, Integer.toString(zimbraLdapCacheAccountMaxSize));
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of Account objects
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1983)
    public void unsetLdapCacheAccountMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheAccountMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of Account objects
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1983)
    public Map<String,Object> unsetLdapCacheAccountMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheAccountMaxSize, "");
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of AlwaysOnCluster
     * objects. Note that modifications to the LDAP directory that affect the
     * validity of cache entries are generally noticed and will also cause
     * cache entry invalidation. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getLdapCacheAlwaysOnClusterMaxAgeAsString to access value as a string.
     *
     * @see #getLdapCacheAlwaysOnClusterMaxAgeAsString()
     *
     * @return zimbraLdapCacheAlwaysOnClusterMaxAge in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2003)
    public long getLdapCacheAlwaysOnClusterMaxAge() {
        return getTimeInterval(Provisioning.A_zimbraLdapCacheAlwaysOnClusterMaxAge, -1L);
    }

    /**
     * Maximum age of entries in the in memory cache of AlwaysOnCluster
     * objects. Note that modifications to the LDAP directory that affect the
     * validity of cache entries are generally noticed and will also cause
     * cache entry invalidation. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraLdapCacheAlwaysOnClusterMaxAge, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2003)
    public String getLdapCacheAlwaysOnClusterMaxAgeAsString() {
        return getAttr(Provisioning.A_zimbraLdapCacheAlwaysOnClusterMaxAge, null);
    }

    /**
     * Maximum age of entries in the in memory cache of AlwaysOnCluster
     * objects. Note that modifications to the LDAP directory that affect the
     * validity of cache entries are generally noticed and will also cause
     * cache entry invalidation. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraLdapCacheAlwaysOnClusterMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2003)
    public void setLdapCacheAlwaysOnClusterMaxAge(String zimbraLdapCacheAlwaysOnClusterMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheAlwaysOnClusterMaxAge, zimbraLdapCacheAlwaysOnClusterMaxAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of AlwaysOnCluster
     * objects. Note that modifications to the LDAP directory that affect the
     * validity of cache entries are generally noticed and will also cause
     * cache entry invalidation. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraLdapCacheAlwaysOnClusterMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2003)
    public Map<String,Object> setLdapCacheAlwaysOnClusterMaxAge(String zimbraLdapCacheAlwaysOnClusterMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheAlwaysOnClusterMaxAge, zimbraLdapCacheAlwaysOnClusterMaxAge);
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of AlwaysOnCluster
     * objects. Note that modifications to the LDAP directory that affect the
     * validity of cache entries are generally noticed and will also cause
     * cache entry invalidation. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2003)
    public void unsetLdapCacheAlwaysOnClusterMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheAlwaysOnClusterMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of AlwaysOnCluster
     * objects. Note that modifications to the LDAP directory that affect the
     * validity of cache entries are generally noticed and will also cause
     * cache entry invalidation. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2003)
    public Map<String,Object> unsetLdapCacheAlwaysOnClusterMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheAlwaysOnClusterMaxAge, "");
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of AlwaysOnCluster
     * objects
     *
     * @return zimbraLdapCacheAlwaysOnClusterMaxSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2002)
    public int getLdapCacheAlwaysOnClusterMaxSize() {
        return getIntAttr(Provisioning.A_zimbraLdapCacheAlwaysOnClusterMaxSize, -1);
    }

    /**
     * Maximum number of entries in the in memory cache of AlwaysOnCluster
     * objects
     *
     * @param zimbraLdapCacheAlwaysOnClusterMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2002)
    public void setLdapCacheAlwaysOnClusterMaxSize(int zimbraLdapCacheAlwaysOnClusterMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheAlwaysOnClusterMaxSize, Integer.toString(zimbraLdapCacheAlwaysOnClusterMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of AlwaysOnCluster
     * objects
     *
     * @param zimbraLdapCacheAlwaysOnClusterMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2002)
    public Map<String,Object> setLdapCacheAlwaysOnClusterMaxSize(int zimbraLdapCacheAlwaysOnClusterMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheAlwaysOnClusterMaxSize, Integer.toString(zimbraLdapCacheAlwaysOnClusterMaxSize));
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of AlwaysOnCluster
     * objects
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2002)
    public void unsetLdapCacheAlwaysOnClusterMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheAlwaysOnClusterMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of AlwaysOnCluster
     * objects
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2002)
    public Map<String,Object> unsetLdapCacheAlwaysOnClusterMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheAlwaysOnClusterMaxSize, "");
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of Cos objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getLdapCacheCosMaxAgeAsString to access value as a string.
     *
     * @see #getLdapCacheCosMaxAgeAsString()
     *
     * @return zimbraLdapCacheCosMaxAge in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1986)
    public long getLdapCacheCosMaxAge() {
        return getTimeInterval(Provisioning.A_zimbraLdapCacheCosMaxAge, -1L);
    }

    /**
     * Maximum age of entries in the in memory cache of Cos objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraLdapCacheCosMaxAge, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1986)
    public String getLdapCacheCosMaxAgeAsString() {
        return getAttr(Provisioning.A_zimbraLdapCacheCosMaxAge, null);
    }

    /**
     * Maximum age of entries in the in memory cache of Cos objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheCosMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1986)
    public void setLdapCacheCosMaxAge(String zimbraLdapCacheCosMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheCosMaxAge, zimbraLdapCacheCosMaxAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of Cos objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheCosMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1986)
    public Map<String,Object> setLdapCacheCosMaxAge(String zimbraLdapCacheCosMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheCosMaxAge, zimbraLdapCacheCosMaxAge);
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of Cos objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1986)
    public void unsetLdapCacheCosMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheCosMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of Cos objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1986)
    public Map<String,Object> unsetLdapCacheCosMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheCosMaxAge, "");
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of Cos objects
     *
     * @return zimbraLdapCacheCosMaxSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1985)
    public int getLdapCacheCosMaxSize() {
        return getIntAttr(Provisioning.A_zimbraLdapCacheCosMaxSize, -1);
    }

    /**
     * Maximum number of entries in the in memory cache of Cos objects
     *
     * @param zimbraLdapCacheCosMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1985)
    public void setLdapCacheCosMaxSize(int zimbraLdapCacheCosMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheCosMaxSize, Integer.toString(zimbraLdapCacheCosMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of Cos objects
     *
     * @param zimbraLdapCacheCosMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1985)
    public Map<String,Object> setLdapCacheCosMaxSize(int zimbraLdapCacheCosMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheCosMaxSize, Integer.toString(zimbraLdapCacheCosMaxSize));
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of Cos objects
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1985)
    public void unsetLdapCacheCosMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheCosMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of Cos objects
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1985)
    public Map<String,Object> unsetLdapCacheCosMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheCosMaxSize, "");
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of Domain objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getLdapCacheDomainMaxAgeAsString to access value as a string.
     *
     * @see #getLdapCacheDomainMaxAgeAsString()
     *
     * @return zimbraLdapCacheDomainMaxAge in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1990)
    public long getLdapCacheDomainMaxAge() {
        return getTimeInterval(Provisioning.A_zimbraLdapCacheDomainMaxAge, -1L);
    }

    /**
     * Maximum age of entries in the in memory cache of Domain objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraLdapCacheDomainMaxAge, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1990)
    public String getLdapCacheDomainMaxAgeAsString() {
        return getAttr(Provisioning.A_zimbraLdapCacheDomainMaxAge, null);
    }

    /**
     * Maximum age of entries in the in memory cache of Domain objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheDomainMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1990)
    public void setLdapCacheDomainMaxAge(String zimbraLdapCacheDomainMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheDomainMaxAge, zimbraLdapCacheDomainMaxAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of Domain objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheDomainMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1990)
    public Map<String,Object> setLdapCacheDomainMaxAge(String zimbraLdapCacheDomainMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheDomainMaxAge, zimbraLdapCacheDomainMaxAge);
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of Domain objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1990)
    public void unsetLdapCacheDomainMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheDomainMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of Domain objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1990)
    public Map<String,Object> unsetLdapCacheDomainMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheDomainMaxAge, "");
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of Domain objects
     *
     * @return zimbraLdapCacheDomainMaxSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1989)
    public int getLdapCacheDomainMaxSize() {
        return getIntAttr(Provisioning.A_zimbraLdapCacheDomainMaxSize, -1);
    }

    /**
     * Maximum number of entries in the in memory cache of Domain objects
     *
     * @param zimbraLdapCacheDomainMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1989)
    public void setLdapCacheDomainMaxSize(int zimbraLdapCacheDomainMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheDomainMaxSize, Integer.toString(zimbraLdapCacheDomainMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of Domain objects
     *
     * @param zimbraLdapCacheDomainMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1989)
    public Map<String,Object> setLdapCacheDomainMaxSize(int zimbraLdapCacheDomainMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheDomainMaxSize, Integer.toString(zimbraLdapCacheDomainMaxSize));
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of Domain objects
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1989)
    public void unsetLdapCacheDomainMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheDomainMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of Domain objects
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1989)
    public Map<String,Object> unsetLdapCacheDomainMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheDomainMaxSize, "");
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of ExternalDomain
     * objects. Note that modifications to the LDAP directory that affect the
     * validity of cache entries are generally noticed and will also cause
     * cache entry invalidation. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getLdapCacheExternalDomainMaxAgeAsString to access value as a string.
     *
     * @see #getLdapCacheExternalDomainMaxAgeAsString()
     *
     * @return zimbraLdapCacheExternalDomainMaxAge in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1892)
    public long getLdapCacheExternalDomainMaxAge() {
        return getTimeInterval(Provisioning.A_zimbraLdapCacheExternalDomainMaxAge, -1L);
    }

    /**
     * Maximum age of entries in the in memory cache of ExternalDomain
     * objects. Note that modifications to the LDAP directory that affect the
     * validity of cache entries are generally noticed and will also cause
     * cache entry invalidation. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraLdapCacheExternalDomainMaxAge, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1892)
    public String getLdapCacheExternalDomainMaxAgeAsString() {
        return getAttr(Provisioning.A_zimbraLdapCacheExternalDomainMaxAge, null);
    }

    /**
     * Maximum age of entries in the in memory cache of ExternalDomain
     * objects. Note that modifications to the LDAP directory that affect the
     * validity of cache entries are generally noticed and will also cause
     * cache entry invalidation. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraLdapCacheExternalDomainMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1892)
    public void setLdapCacheExternalDomainMaxAge(String zimbraLdapCacheExternalDomainMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheExternalDomainMaxAge, zimbraLdapCacheExternalDomainMaxAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of ExternalDomain
     * objects. Note that modifications to the LDAP directory that affect the
     * validity of cache entries are generally noticed and will also cause
     * cache entry invalidation. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraLdapCacheExternalDomainMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1892)
    public Map<String,Object> setLdapCacheExternalDomainMaxAge(String zimbraLdapCacheExternalDomainMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheExternalDomainMaxAge, zimbraLdapCacheExternalDomainMaxAge);
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of ExternalDomain
     * objects. Note that modifications to the LDAP directory that affect the
     * validity of cache entries are generally noticed and will also cause
     * cache entry invalidation. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1892)
    public void unsetLdapCacheExternalDomainMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheExternalDomainMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of ExternalDomain
     * objects. Note that modifications to the LDAP directory that affect the
     * validity of cache entries are generally noticed and will also cause
     * cache entry invalidation. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1892)
    public Map<String,Object> unsetLdapCacheExternalDomainMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheExternalDomainMaxAge, "");
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of ExternalDomain
     * objects
     *
     * @return zimbraLdapCacheExternalDomainMaxSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1891)
    public int getLdapCacheExternalDomainMaxSize() {
        return getIntAttr(Provisioning.A_zimbraLdapCacheExternalDomainMaxSize, -1);
    }

    /**
     * Maximum number of entries in the in memory cache of ExternalDomain
     * objects
     *
     * @param zimbraLdapCacheExternalDomainMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1891)
    public void setLdapCacheExternalDomainMaxSize(int zimbraLdapCacheExternalDomainMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheExternalDomainMaxSize, Integer.toString(zimbraLdapCacheExternalDomainMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of ExternalDomain
     * objects
     *
     * @param zimbraLdapCacheExternalDomainMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1891)
    public Map<String,Object> setLdapCacheExternalDomainMaxSize(int zimbraLdapCacheExternalDomainMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheExternalDomainMaxSize, Integer.toString(zimbraLdapCacheExternalDomainMaxSize));
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of ExternalDomain
     * objects
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1891)
    public void unsetLdapCacheExternalDomainMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheExternalDomainMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of ExternalDomain
     * objects
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1891)
    public Map<String,Object> unsetLdapCacheExternalDomainMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheExternalDomainMaxSize, "");
        return attrs;
    }

    /**
     * If an entry in a zimbraLdap cache has been retrieved more recently
     * than this duration, the LDAP directory will not be consulted to check
     * that related entries have not been modified. This prevents
     * un-necessary load on the LDAP directory in some circumstances. Setting
     * this value to a longer duration may improve performance slightly at
     * the cost of missing some updates.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getLdapCacheFreshnessCheckLimitAsString to access value as a string.
     *
     * @see #getLdapCacheFreshnessCheckLimitAsString()
     *
     * @return zimbraLdapCacheFreshnessCheckLimit in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1982)
    public long getLdapCacheFreshnessCheckLimit() {
        return getTimeInterval(Provisioning.A_zimbraLdapCacheFreshnessCheckLimit, -1L);
    }

    /**
     * If an entry in a zimbraLdap cache has been retrieved more recently
     * than this duration, the LDAP directory will not be consulted to check
     * that related entries have not been modified. This prevents
     * un-necessary load on the LDAP directory in some circumstances. Setting
     * this value to a longer duration may improve performance slightly at
     * the cost of missing some updates.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraLdapCacheFreshnessCheckLimit, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1982)
    public String getLdapCacheFreshnessCheckLimitAsString() {
        return getAttr(Provisioning.A_zimbraLdapCacheFreshnessCheckLimit, null);
    }

    /**
     * If an entry in a zimbraLdap cache has been retrieved more recently
     * than this duration, the LDAP directory will not be consulted to check
     * that related entries have not been modified. This prevents
     * un-necessary load on the LDAP directory in some circumstances. Setting
     * this value to a longer duration may improve performance slightly at
     * the cost of missing some updates.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraLdapCacheFreshnessCheckLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1982)
    public void setLdapCacheFreshnessCheckLimit(String zimbraLdapCacheFreshnessCheckLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheFreshnessCheckLimit, zimbraLdapCacheFreshnessCheckLimit);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If an entry in a zimbraLdap cache has been retrieved more recently
     * than this duration, the LDAP directory will not be consulted to check
     * that related entries have not been modified. This prevents
     * un-necessary load on the LDAP directory in some circumstances. Setting
     * this value to a longer duration may improve performance slightly at
     * the cost of missing some updates.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraLdapCacheFreshnessCheckLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1982)
    public Map<String,Object> setLdapCacheFreshnessCheckLimit(String zimbraLdapCacheFreshnessCheckLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheFreshnessCheckLimit, zimbraLdapCacheFreshnessCheckLimit);
        return attrs;
    }

    /**
     * If an entry in a zimbraLdap cache has been retrieved more recently
     * than this duration, the LDAP directory will not be consulted to check
     * that related entries have not been modified. This prevents
     * un-necessary load on the LDAP directory in some circumstances. Setting
     * this value to a longer duration may improve performance slightly at
     * the cost of missing some updates.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1982)
    public void unsetLdapCacheFreshnessCheckLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheFreshnessCheckLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If an entry in a zimbraLdap cache has been retrieved more recently
     * than this duration, the LDAP directory will not be consulted to check
     * that related entries have not been modified. This prevents
     * un-necessary load on the LDAP directory in some circumstances. Setting
     * this value to a longer duration may improve performance slightly at
     * the cost of missing some updates.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1982)
    public Map<String,Object> unsetLdapCacheFreshnessCheckLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheFreshnessCheckLimit, "");
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of Group objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getLdapCacheGroupMaxAgeAsString to access value as a string.
     *
     * @see #getLdapCacheGroupMaxAgeAsString()
     *
     * @return zimbraLdapCacheGroupMaxAge in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1995)
    public long getLdapCacheGroupMaxAge() {
        return getTimeInterval(Provisioning.A_zimbraLdapCacheGroupMaxAge, -1L);
    }

    /**
     * Maximum age of entries in the in memory cache of Group objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraLdapCacheGroupMaxAge, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1995)
    public String getLdapCacheGroupMaxAgeAsString() {
        return getAttr(Provisioning.A_zimbraLdapCacheGroupMaxAge, null);
    }

    /**
     * Maximum age of entries in the in memory cache of Group objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheGroupMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1995)
    public void setLdapCacheGroupMaxAge(String zimbraLdapCacheGroupMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheGroupMaxAge, zimbraLdapCacheGroupMaxAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of Group objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheGroupMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1995)
    public Map<String,Object> setLdapCacheGroupMaxAge(String zimbraLdapCacheGroupMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheGroupMaxAge, zimbraLdapCacheGroupMaxAge);
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of Group objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1995)
    public void unsetLdapCacheGroupMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheGroupMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of Group objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1995)
    public Map<String,Object> unsetLdapCacheGroupMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheGroupMaxAge, "");
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of Group objects
     *
     * @return zimbraLdapCacheGroupMaxSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1893)
    public int getLdapCacheGroupMaxSize() {
        return getIntAttr(Provisioning.A_zimbraLdapCacheGroupMaxSize, -1);
    }

    /**
     * Maximum number of entries in the in memory cache of Group objects
     *
     * @param zimbraLdapCacheGroupMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1893)
    public void setLdapCacheGroupMaxSize(int zimbraLdapCacheGroupMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheGroupMaxSize, Integer.toString(zimbraLdapCacheGroupMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of Group objects
     *
     * @param zimbraLdapCacheGroupMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1893)
    public Map<String,Object> setLdapCacheGroupMaxSize(int zimbraLdapCacheGroupMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheGroupMaxSize, Integer.toString(zimbraLdapCacheGroupMaxSize));
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of Group objects
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1893)
    public void unsetLdapCacheGroupMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheGroupMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of Group objects
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1893)
    public Map<String,Object> unsetLdapCacheGroupMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheGroupMaxSize, "");
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of MimeTypeInfo objects.
     * Note that modifications to the LDAP directory that affect the validity
     * of cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getLdapCacheMimeTypeInfoMaxAgeAsString to access value as a string.
     *
     * @see #getLdapCacheMimeTypeInfoMaxAgeAsString()
     *
     * @return zimbraLdapCacheMimeTypeInfoMaxAge in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1994)
    public long getLdapCacheMimeTypeInfoMaxAge() {
        return getTimeInterval(Provisioning.A_zimbraLdapCacheMimeTypeInfoMaxAge, -1L);
    }

    /**
     * Maximum age of entries in the in memory cache of MimeTypeInfo objects.
     * Note that modifications to the LDAP directory that affect the validity
     * of cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraLdapCacheMimeTypeInfoMaxAge, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1994)
    public String getLdapCacheMimeTypeInfoMaxAgeAsString() {
        return getAttr(Provisioning.A_zimbraLdapCacheMimeTypeInfoMaxAge, null);
    }

    /**
     * Maximum age of entries in the in memory cache of MimeTypeInfo objects.
     * Note that modifications to the LDAP directory that affect the validity
     * of cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheMimeTypeInfoMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1994)
    public void setLdapCacheMimeTypeInfoMaxAge(String zimbraLdapCacheMimeTypeInfoMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheMimeTypeInfoMaxAge, zimbraLdapCacheMimeTypeInfoMaxAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of MimeTypeInfo objects.
     * Note that modifications to the LDAP directory that affect the validity
     * of cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheMimeTypeInfoMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1994)
    public Map<String,Object> setLdapCacheMimeTypeInfoMaxAge(String zimbraLdapCacheMimeTypeInfoMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheMimeTypeInfoMaxAge, zimbraLdapCacheMimeTypeInfoMaxAge);
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of MimeTypeInfo objects.
     * Note that modifications to the LDAP directory that affect the validity
     * of cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1994)
    public void unsetLdapCacheMimeTypeInfoMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheMimeTypeInfoMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of MimeTypeInfo objects.
     * Note that modifications to the LDAP directory that affect the validity
     * of cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1994)
    public Map<String,Object> unsetLdapCacheMimeTypeInfoMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheMimeTypeInfoMaxAge, "");
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory caches of ReverseProxyLookup
     * Domain related objects. Note that modifications to the LDAP directory
     * that affect the validity of cache entries are generally noticed and
     * will also cause cache entry invalidation. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getLdapCacheReverseProxyLookupDomainMaxAgeAsString to access value as a string.
     *
     * @see #getLdapCacheReverseProxyLookupDomainMaxAgeAsString()
     *
     * @return zimbraLdapCacheReverseProxyLookupDomainMaxAge in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2009)
    public long getLdapCacheReverseProxyLookupDomainMaxAge() {
        return getTimeInterval(Provisioning.A_zimbraLdapCacheReverseProxyLookupDomainMaxAge, -1L);
    }

    /**
     * Maximum age of entries in the in memory caches of ReverseProxyLookup
     * Domain related objects. Note that modifications to the LDAP directory
     * that affect the validity of cache entries are generally noticed and
     * will also cause cache entry invalidation. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraLdapCacheReverseProxyLookupDomainMaxAge, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2009)
    public String getLdapCacheReverseProxyLookupDomainMaxAgeAsString() {
        return getAttr(Provisioning.A_zimbraLdapCacheReverseProxyLookupDomainMaxAge, null);
    }

    /**
     * Maximum age of entries in the in memory caches of ReverseProxyLookup
     * Domain related objects. Note that modifications to the LDAP directory
     * that affect the validity of cache entries are generally noticed and
     * will also cause cache entry invalidation. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraLdapCacheReverseProxyLookupDomainMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2009)
    public void setLdapCacheReverseProxyLookupDomainMaxAge(String zimbraLdapCacheReverseProxyLookupDomainMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheReverseProxyLookupDomainMaxAge, zimbraLdapCacheReverseProxyLookupDomainMaxAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory caches of ReverseProxyLookup
     * Domain related objects. Note that modifications to the LDAP directory
     * that affect the validity of cache entries are generally noticed and
     * will also cause cache entry invalidation. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraLdapCacheReverseProxyLookupDomainMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2009)
    public Map<String,Object> setLdapCacheReverseProxyLookupDomainMaxAge(String zimbraLdapCacheReverseProxyLookupDomainMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheReverseProxyLookupDomainMaxAge, zimbraLdapCacheReverseProxyLookupDomainMaxAge);
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory caches of ReverseProxyLookup
     * Domain related objects. Note that modifications to the LDAP directory
     * that affect the validity of cache entries are generally noticed and
     * will also cause cache entry invalidation. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2009)
    public void unsetLdapCacheReverseProxyLookupDomainMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheReverseProxyLookupDomainMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory caches of ReverseProxyLookup
     * Domain related objects. Note that modifications to the LDAP directory
     * that affect the validity of cache entries are generally noticed and
     * will also cause cache entry invalidation. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2009)
    public Map<String,Object> unsetLdapCacheReverseProxyLookupDomainMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheReverseProxyLookupDomainMaxAge, "");
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory caches of
     * ReverseProxyLookup Domain related objects
     *
     * @return zimbraLdapCacheReverseProxyLookupDomainMaxSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2008)
    public int getLdapCacheReverseProxyLookupDomainMaxSize() {
        return getIntAttr(Provisioning.A_zimbraLdapCacheReverseProxyLookupDomainMaxSize, -1);
    }

    /**
     * Maximum number of entries in the in memory caches of
     * ReverseProxyLookup Domain related objects
     *
     * @param zimbraLdapCacheReverseProxyLookupDomainMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2008)
    public void setLdapCacheReverseProxyLookupDomainMaxSize(int zimbraLdapCacheReverseProxyLookupDomainMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheReverseProxyLookupDomainMaxSize, Integer.toString(zimbraLdapCacheReverseProxyLookupDomainMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory caches of
     * ReverseProxyLookup Domain related objects
     *
     * @param zimbraLdapCacheReverseProxyLookupDomainMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2008)
    public Map<String,Object> setLdapCacheReverseProxyLookupDomainMaxSize(int zimbraLdapCacheReverseProxyLookupDomainMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheReverseProxyLookupDomainMaxSize, Integer.toString(zimbraLdapCacheReverseProxyLookupDomainMaxSize));
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory caches of
     * ReverseProxyLookup Domain related objects
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2008)
    public void unsetLdapCacheReverseProxyLookupDomainMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheReverseProxyLookupDomainMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory caches of
     * ReverseProxyLookup Domain related objects
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2008)
    public Map<String,Object> unsetLdapCacheReverseProxyLookupDomainMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheReverseProxyLookupDomainMaxSize, "");
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of ReverseProxyLookup
     * ServerInfo objects. Note that modifications to the LDAP directory that
     * affect the validity of cache entries are generally noticed and will
     * also cause cache entry invalidation. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getLdapCacheReverseProxyLookupServerMaxAgeAsString to access value as a string.
     *
     * @see #getLdapCacheReverseProxyLookupServerMaxAgeAsString()
     *
     * @return zimbraLdapCacheReverseProxyLookupServerMaxAge in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2011)
    public long getLdapCacheReverseProxyLookupServerMaxAge() {
        return getTimeInterval(Provisioning.A_zimbraLdapCacheReverseProxyLookupServerMaxAge, -1L);
    }

    /**
     * Maximum age of entries in the in memory cache of ReverseProxyLookup
     * ServerInfo objects. Note that modifications to the LDAP directory that
     * affect the validity of cache entries are generally noticed and will
     * also cause cache entry invalidation. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraLdapCacheReverseProxyLookupServerMaxAge, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2011)
    public String getLdapCacheReverseProxyLookupServerMaxAgeAsString() {
        return getAttr(Provisioning.A_zimbraLdapCacheReverseProxyLookupServerMaxAge, null);
    }

    /**
     * Maximum age of entries in the in memory cache of ReverseProxyLookup
     * ServerInfo objects. Note that modifications to the LDAP directory that
     * affect the validity of cache entries are generally noticed and will
     * also cause cache entry invalidation. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraLdapCacheReverseProxyLookupServerMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2011)
    public void setLdapCacheReverseProxyLookupServerMaxAge(String zimbraLdapCacheReverseProxyLookupServerMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheReverseProxyLookupServerMaxAge, zimbraLdapCacheReverseProxyLookupServerMaxAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of ReverseProxyLookup
     * ServerInfo objects. Note that modifications to the LDAP directory that
     * affect the validity of cache entries are generally noticed and will
     * also cause cache entry invalidation. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraLdapCacheReverseProxyLookupServerMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2011)
    public Map<String,Object> setLdapCacheReverseProxyLookupServerMaxAge(String zimbraLdapCacheReverseProxyLookupServerMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheReverseProxyLookupServerMaxAge, zimbraLdapCacheReverseProxyLookupServerMaxAge);
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of ReverseProxyLookup
     * ServerInfo objects. Note that modifications to the LDAP directory that
     * affect the validity of cache entries are generally noticed and will
     * also cause cache entry invalidation. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2011)
    public void unsetLdapCacheReverseProxyLookupServerMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheReverseProxyLookupServerMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of ReverseProxyLookup
     * ServerInfo objects. Note that modifications to the LDAP directory that
     * affect the validity of cache entries are generally noticed and will
     * also cause cache entry invalidation. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2011)
    public Map<String,Object> unsetLdapCacheReverseProxyLookupServerMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheReverseProxyLookupServerMaxAge, "");
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of ReverseProxyLookup
     * ServerInfo objects
     *
     * @return zimbraLdapCacheReverseProxyLookupServerMaxSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2010)
    public int getLdapCacheReverseProxyLookupServerMaxSize() {
        return getIntAttr(Provisioning.A_zimbraLdapCacheReverseProxyLookupServerMaxSize, -1);
    }

    /**
     * Maximum number of entries in the in memory cache of ReverseProxyLookup
     * ServerInfo objects
     *
     * @param zimbraLdapCacheReverseProxyLookupServerMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2010)
    public void setLdapCacheReverseProxyLookupServerMaxSize(int zimbraLdapCacheReverseProxyLookupServerMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheReverseProxyLookupServerMaxSize, Integer.toString(zimbraLdapCacheReverseProxyLookupServerMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of ReverseProxyLookup
     * ServerInfo objects
     *
     * @param zimbraLdapCacheReverseProxyLookupServerMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2010)
    public Map<String,Object> setLdapCacheReverseProxyLookupServerMaxSize(int zimbraLdapCacheReverseProxyLookupServerMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheReverseProxyLookupServerMaxSize, Integer.toString(zimbraLdapCacheReverseProxyLookupServerMaxSize));
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of ReverseProxyLookup
     * ServerInfo objects
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2010)
    public void unsetLdapCacheReverseProxyLookupServerMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheReverseProxyLookupServerMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of ReverseProxyLookup
     * ServerInfo objects
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2010)
    public Map<String,Object> unsetLdapCacheReverseProxyLookupServerMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheReverseProxyLookupServerMaxSize, "");
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of Right objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getLdapCacheRightMaxAgeAsString to access value as a string.
     *
     * @see #getLdapCacheRightMaxAgeAsString()
     *
     * @return zimbraLdapCacheRightMaxAge in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1997)
    public long getLdapCacheRightMaxAge() {
        return getTimeInterval(Provisioning.A_zimbraLdapCacheRightMaxAge, -1L);
    }

    /**
     * Maximum age of entries in the in memory cache of Right objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraLdapCacheRightMaxAge, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1997)
    public String getLdapCacheRightMaxAgeAsString() {
        return getAttr(Provisioning.A_zimbraLdapCacheRightMaxAge, null);
    }

    /**
     * Maximum age of entries in the in memory cache of Right objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheRightMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1997)
    public void setLdapCacheRightMaxAge(String zimbraLdapCacheRightMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheRightMaxAge, zimbraLdapCacheRightMaxAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of Right objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheRightMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1997)
    public Map<String,Object> setLdapCacheRightMaxAge(String zimbraLdapCacheRightMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheRightMaxAge, zimbraLdapCacheRightMaxAge);
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of Right objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1997)
    public void unsetLdapCacheRightMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheRightMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of Right objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1997)
    public Map<String,Object> unsetLdapCacheRightMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheRightMaxAge, "");
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of Right objects
     *
     * @return zimbraLdapCacheRightMaxSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1996)
    public int getLdapCacheRightMaxSize() {
        return getIntAttr(Provisioning.A_zimbraLdapCacheRightMaxSize, -1);
    }

    /**
     * Maximum number of entries in the in memory cache of Right objects
     *
     * @param zimbraLdapCacheRightMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1996)
    public void setLdapCacheRightMaxSize(int zimbraLdapCacheRightMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheRightMaxSize, Integer.toString(zimbraLdapCacheRightMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of Right objects
     *
     * @param zimbraLdapCacheRightMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1996)
    public Map<String,Object> setLdapCacheRightMaxSize(int zimbraLdapCacheRightMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheRightMaxSize, Integer.toString(zimbraLdapCacheRightMaxSize));
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of Right objects
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1996)
    public void unsetLdapCacheRightMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheRightMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of Right objects
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1996)
    public Map<String,Object> unsetLdapCacheRightMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheRightMaxSize, "");
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of Server objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getLdapCacheServerMaxAgeAsString to access value as a string.
     *
     * @see #getLdapCacheServerMaxAgeAsString()
     *
     * @return zimbraLdapCacheServerMaxAge in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1999)
    public long getLdapCacheServerMaxAge() {
        return getTimeInterval(Provisioning.A_zimbraLdapCacheServerMaxAge, -1L);
    }

    /**
     * Maximum age of entries in the in memory cache of Server objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraLdapCacheServerMaxAge, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1999)
    public String getLdapCacheServerMaxAgeAsString() {
        return getAttr(Provisioning.A_zimbraLdapCacheServerMaxAge, null);
    }

    /**
     * Maximum age of entries in the in memory cache of Server objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheServerMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1999)
    public void setLdapCacheServerMaxAge(String zimbraLdapCacheServerMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheServerMaxAge, zimbraLdapCacheServerMaxAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of Server objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheServerMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1999)
    public Map<String,Object> setLdapCacheServerMaxAge(String zimbraLdapCacheServerMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheServerMaxAge, zimbraLdapCacheServerMaxAge);
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of Server objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1999)
    public void unsetLdapCacheServerMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheServerMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of Server objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1999)
    public Map<String,Object> unsetLdapCacheServerMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheServerMaxAge, "");
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of Server objects
     *
     * @return zimbraLdapCacheServerMaxSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1998)
    public int getLdapCacheServerMaxSize() {
        return getIntAttr(Provisioning.A_zimbraLdapCacheServerMaxSize, -1);
    }

    /**
     * Maximum number of entries in the in memory cache of Server objects
     *
     * @param zimbraLdapCacheServerMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1998)
    public void setLdapCacheServerMaxSize(int zimbraLdapCacheServerMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheServerMaxSize, Integer.toString(zimbraLdapCacheServerMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of Server objects
     *
     * @param zimbraLdapCacheServerMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1998)
    public Map<String,Object> setLdapCacheServerMaxSize(int zimbraLdapCacheServerMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheServerMaxSize, Integer.toString(zimbraLdapCacheServerMaxSize));
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of Server objects
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1998)
    public void unsetLdapCacheServerMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheServerMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of Server objects
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1998)
    public Map<String,Object> unsetLdapCacheServerMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheServerMaxSize, "");
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of ShareLocator objects.
     * Note that modifications to the LDAP directory that affect the validity
     * of cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getLdapCacheShareLocatorMaxAgeAsString to access value as a string.
     *
     * @see #getLdapCacheShareLocatorMaxAgeAsString()
     *
     * @return zimbraLdapCacheShareLocatorMaxAge in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1988)
    public long getLdapCacheShareLocatorMaxAge() {
        return getTimeInterval(Provisioning.A_zimbraLdapCacheShareLocatorMaxAge, -1L);
    }

    /**
     * Maximum age of entries in the in memory cache of ShareLocator objects.
     * Note that modifications to the LDAP directory that affect the validity
     * of cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraLdapCacheShareLocatorMaxAge, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1988)
    public String getLdapCacheShareLocatorMaxAgeAsString() {
        return getAttr(Provisioning.A_zimbraLdapCacheShareLocatorMaxAge, null);
    }

    /**
     * Maximum age of entries in the in memory cache of ShareLocator objects.
     * Note that modifications to the LDAP directory that affect the validity
     * of cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheShareLocatorMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1988)
    public void setLdapCacheShareLocatorMaxAge(String zimbraLdapCacheShareLocatorMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheShareLocatorMaxAge, zimbraLdapCacheShareLocatorMaxAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of ShareLocator objects.
     * Note that modifications to the LDAP directory that affect the validity
     * of cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheShareLocatorMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1988)
    public Map<String,Object> setLdapCacheShareLocatorMaxAge(String zimbraLdapCacheShareLocatorMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheShareLocatorMaxAge, zimbraLdapCacheShareLocatorMaxAge);
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of ShareLocator objects.
     * Note that modifications to the LDAP directory that affect the validity
     * of cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1988)
    public void unsetLdapCacheShareLocatorMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheShareLocatorMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of ShareLocator objects.
     * Note that modifications to the LDAP directory that affect the validity
     * of cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1988)
    public Map<String,Object> unsetLdapCacheShareLocatorMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheShareLocatorMaxAge, "");
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of ShareLocator
     * objects
     *
     * @return zimbraLdapCacheShareLocatorMaxSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1987)
    public int getLdapCacheShareLocatorMaxSize() {
        return getIntAttr(Provisioning.A_zimbraLdapCacheShareLocatorMaxSize, -1);
    }

    /**
     * Maximum number of entries in the in memory cache of ShareLocator
     * objects
     *
     * @param zimbraLdapCacheShareLocatorMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1987)
    public void setLdapCacheShareLocatorMaxSize(int zimbraLdapCacheShareLocatorMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheShareLocatorMaxSize, Integer.toString(zimbraLdapCacheShareLocatorMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of ShareLocator
     * objects
     *
     * @param zimbraLdapCacheShareLocatorMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1987)
    public Map<String,Object> setLdapCacheShareLocatorMaxSize(int zimbraLdapCacheShareLocatorMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheShareLocatorMaxSize, Integer.toString(zimbraLdapCacheShareLocatorMaxSize));
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of ShareLocator
     * objects
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1987)
    public void unsetLdapCacheShareLocatorMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheShareLocatorMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of ShareLocator
     * objects
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1987)
    public Map<String,Object> unsetLdapCacheShareLocatorMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheShareLocatorMaxSize, "");
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of UCService objects.
     * Note that modifications to the LDAP directory that affect the validity
     * of cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getLdapCacheUCServiceMaxAgeAsString to access value as a string.
     *
     * @see #getLdapCacheUCServiceMaxAgeAsString()
     *
     * @return zimbraLdapCacheUCServiceMaxAge in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2001)
    public long getLdapCacheUCServiceMaxAge() {
        return getTimeInterval(Provisioning.A_zimbraLdapCacheUCServiceMaxAge, -1L);
    }

    /**
     * Maximum age of entries in the in memory cache of UCService objects.
     * Note that modifications to the LDAP directory that affect the validity
     * of cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraLdapCacheUCServiceMaxAge, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2001)
    public String getLdapCacheUCServiceMaxAgeAsString() {
        return getAttr(Provisioning.A_zimbraLdapCacheUCServiceMaxAge, null);
    }

    /**
     * Maximum age of entries in the in memory cache of UCService objects.
     * Note that modifications to the LDAP directory that affect the validity
     * of cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheUCServiceMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2001)
    public void setLdapCacheUCServiceMaxAge(String zimbraLdapCacheUCServiceMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheUCServiceMaxAge, zimbraLdapCacheUCServiceMaxAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of UCService objects.
     * Note that modifications to the LDAP directory that affect the validity
     * of cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheUCServiceMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2001)
    public Map<String,Object> setLdapCacheUCServiceMaxAge(String zimbraLdapCacheUCServiceMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheUCServiceMaxAge, zimbraLdapCacheUCServiceMaxAge);
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of UCService objects.
     * Note that modifications to the LDAP directory that affect the validity
     * of cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2001)
    public void unsetLdapCacheUCServiceMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheUCServiceMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of UCService objects.
     * Note that modifications to the LDAP directory that affect the validity
     * of cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2001)
    public Map<String,Object> unsetLdapCacheUCServiceMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheUCServiceMaxAge, "");
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of UCService objects
     *
     * @return zimbraLdapCacheUCServiceMaxSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2000)
    public int getLdapCacheUCServiceMaxSize() {
        return getIntAttr(Provisioning.A_zimbraLdapCacheUCServiceMaxSize, -1);
    }

    /**
     * Maximum number of entries in the in memory cache of UCService objects
     *
     * @param zimbraLdapCacheUCServiceMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2000)
    public void setLdapCacheUCServiceMaxSize(int zimbraLdapCacheUCServiceMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheUCServiceMaxSize, Integer.toString(zimbraLdapCacheUCServiceMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of UCService objects
     *
     * @param zimbraLdapCacheUCServiceMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2000)
    public Map<String,Object> setLdapCacheUCServiceMaxSize(int zimbraLdapCacheUCServiceMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheUCServiceMaxSize, Integer.toString(zimbraLdapCacheUCServiceMaxSize));
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of UCService objects
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2000)
    public void unsetLdapCacheUCServiceMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheUCServiceMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of UCService objects
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2000)
    public Map<String,Object> unsetLdapCacheUCServiceMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheUCServiceMaxSize, "");
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of XMPPComponent
     * objects. Note that modifications to the LDAP directory that affect the
     * validity of cache entries are generally noticed and will also cause
     * cache entry invalidation. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getLdapCacheXMPPComponentMaxAgeAsString to access value as a string.
     *
     * @see #getLdapCacheXMPPComponentMaxAgeAsString()
     *
     * @return zimbraLdapCacheXMPPComponentMaxAge in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2005)
    public long getLdapCacheXMPPComponentMaxAge() {
        return getTimeInterval(Provisioning.A_zimbraLdapCacheXMPPComponentMaxAge, -1L);
    }

    /**
     * Maximum age of entries in the in memory cache of XMPPComponent
     * objects. Note that modifications to the LDAP directory that affect the
     * validity of cache entries are generally noticed and will also cause
     * cache entry invalidation. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraLdapCacheXMPPComponentMaxAge, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2005)
    public String getLdapCacheXMPPComponentMaxAgeAsString() {
        return getAttr(Provisioning.A_zimbraLdapCacheXMPPComponentMaxAge, null);
    }

    /**
     * Maximum age of entries in the in memory cache of XMPPComponent
     * objects. Note that modifications to the LDAP directory that affect the
     * validity of cache entries are generally noticed and will also cause
     * cache entry invalidation. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraLdapCacheXMPPComponentMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2005)
    public void setLdapCacheXMPPComponentMaxAge(String zimbraLdapCacheXMPPComponentMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheXMPPComponentMaxAge, zimbraLdapCacheXMPPComponentMaxAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of XMPPComponent
     * objects. Note that modifications to the LDAP directory that affect the
     * validity of cache entries are generally noticed and will also cause
     * cache entry invalidation. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraLdapCacheXMPPComponentMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2005)
    public Map<String,Object> setLdapCacheXMPPComponentMaxAge(String zimbraLdapCacheXMPPComponentMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheXMPPComponentMaxAge, zimbraLdapCacheXMPPComponentMaxAge);
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of XMPPComponent
     * objects. Note that modifications to the LDAP directory that affect the
     * validity of cache entries are generally noticed and will also cause
     * cache entry invalidation. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2005)
    public void unsetLdapCacheXMPPComponentMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheXMPPComponentMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of XMPPComponent
     * objects. Note that modifications to the LDAP directory that affect the
     * validity of cache entries are generally noticed and will also cause
     * cache entry invalidation. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2005)
    public Map<String,Object> unsetLdapCacheXMPPComponentMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheXMPPComponentMaxAge, "");
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of XMPPComponent
     * objects
     *
     * @return zimbraLdapCacheXMPPComponentMaxSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2004)
    public int getLdapCacheXMPPComponentMaxSize() {
        return getIntAttr(Provisioning.A_zimbraLdapCacheXMPPComponentMaxSize, -1);
    }

    /**
     * Maximum number of entries in the in memory cache of XMPPComponent
     * objects
     *
     * @param zimbraLdapCacheXMPPComponentMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2004)
    public void setLdapCacheXMPPComponentMaxSize(int zimbraLdapCacheXMPPComponentMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheXMPPComponentMaxSize, Integer.toString(zimbraLdapCacheXMPPComponentMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of XMPPComponent
     * objects
     *
     * @param zimbraLdapCacheXMPPComponentMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2004)
    public Map<String,Object> setLdapCacheXMPPComponentMaxSize(int zimbraLdapCacheXMPPComponentMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheXMPPComponentMaxSize, Integer.toString(zimbraLdapCacheXMPPComponentMaxSize));
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of XMPPComponent
     * objects
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2004)
    public void unsetLdapCacheXMPPComponentMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheXMPPComponentMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of XMPPComponent
     * objects
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2004)
    public Map<String,Object> unsetLdapCacheXMPPComponentMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheXMPPComponentMaxSize, "");
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of Zimlet objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getLdapCacheZimletMaxAgeAsString to access value as a string.
     *
     * @see #getLdapCacheZimletMaxAgeAsString()
     *
     * @return zimbraLdapCacheZimletMaxAge in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2007)
    public long getLdapCacheZimletMaxAge() {
        return getTimeInterval(Provisioning.A_zimbraLdapCacheZimletMaxAge, -1L);
    }

    /**
     * Maximum age of entries in the in memory cache of Zimlet objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraLdapCacheZimletMaxAge, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2007)
    public String getLdapCacheZimletMaxAgeAsString() {
        return getAttr(Provisioning.A_zimbraLdapCacheZimletMaxAge, null);
    }

    /**
     * Maximum age of entries in the in memory cache of Zimlet objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheZimletMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2007)
    public void setLdapCacheZimletMaxAge(String zimbraLdapCacheZimletMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheZimletMaxAge, zimbraLdapCacheZimletMaxAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of Zimlet objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraLdapCacheZimletMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2007)
    public Map<String,Object> setLdapCacheZimletMaxAge(String zimbraLdapCacheZimletMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheZimletMaxAge, zimbraLdapCacheZimletMaxAge);
        return attrs;
    }

    /**
     * Maximum age of entries in the in memory cache of Zimlet objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2007)
    public void unsetLdapCacheZimletMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheZimletMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum age of entries in the in memory cache of Zimlet objects. Note
     * that modifications to the LDAP directory that affect the validity of
     * cache entries are generally noticed and will also cause cache entry
     * invalidation. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2007)
    public Map<String,Object> unsetLdapCacheZimletMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheZimletMaxAge, "");
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of Zimlet objects
     *
     * @return zimbraLdapCacheZimletMaxSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2006)
    public int getLdapCacheZimletMaxSize() {
        return getIntAttr(Provisioning.A_zimbraLdapCacheZimletMaxSize, -1);
    }

    /**
     * Maximum number of entries in the in memory cache of Zimlet objects
     *
     * @param zimbraLdapCacheZimletMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2006)
    public void setLdapCacheZimletMaxSize(int zimbraLdapCacheZimletMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheZimletMaxSize, Integer.toString(zimbraLdapCacheZimletMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of Zimlet objects
     *
     * @param zimbraLdapCacheZimletMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2006)
    public Map<String,Object> setLdapCacheZimletMaxSize(int zimbraLdapCacheZimletMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheZimletMaxSize, Integer.toString(zimbraLdapCacheZimletMaxSize));
        return attrs;
    }

    /**
     * Maximum number of entries in the in memory cache of Zimlet objects
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2006)
    public void unsetLdapCacheZimletMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheZimletMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the in memory cache of Zimlet objects
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2006)
    public Map<String,Object> unsetLdapCacheZimletMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapCacheZimletMaxSize, "");
        return attrs;
    }

    /**
     * Whether to include fractional seconds in LDAP gentime values (e.g.
     * zimbraPasswordLockoutFailureTime or
     * zimbraGalLastSuccessfulSyncTimestamp). Releases prior to 8.7 are
     * unable to parse gentime values which include fractional seconds;
     * therefore this value must remain set to FALSE in environments where
     * any release 8.6 or lower is present. It should be changed to TRUE once
     * all systems are upgraded to 8.7 or higher.
     *
     * @return zimbraLdapGentimeFractionalSecondsEnabled, or false if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2018)
    public boolean isLdapGentimeFractionalSecondsEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraLdapGentimeFractionalSecondsEnabled, false);
    }

    /**
     * Whether to include fractional seconds in LDAP gentime values (e.g.
     * zimbraPasswordLockoutFailureTime or
     * zimbraGalLastSuccessfulSyncTimestamp). Releases prior to 8.7 are
     * unable to parse gentime values which include fractional seconds;
     * therefore this value must remain set to FALSE in environments where
     * any release 8.6 or lower is present. It should be changed to TRUE once
     * all systems are upgraded to 8.7 or higher.
     *
     * @param zimbraLdapGentimeFractionalSecondsEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2018)
    public void setLdapGentimeFractionalSecondsEnabled(boolean zimbraLdapGentimeFractionalSecondsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapGentimeFractionalSecondsEnabled, zimbraLdapGentimeFractionalSecondsEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to include fractional seconds in LDAP gentime values (e.g.
     * zimbraPasswordLockoutFailureTime or
     * zimbraGalLastSuccessfulSyncTimestamp). Releases prior to 8.7 are
     * unable to parse gentime values which include fractional seconds;
     * therefore this value must remain set to FALSE in environments where
     * any release 8.6 or lower is present. It should be changed to TRUE once
     * all systems are upgraded to 8.7 or higher.
     *
     * @param zimbraLdapGentimeFractionalSecondsEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2018)
    public Map<String,Object> setLdapGentimeFractionalSecondsEnabled(boolean zimbraLdapGentimeFractionalSecondsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapGentimeFractionalSecondsEnabled, zimbraLdapGentimeFractionalSecondsEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether to include fractional seconds in LDAP gentime values (e.g.
     * zimbraPasswordLockoutFailureTime or
     * zimbraGalLastSuccessfulSyncTimestamp). Releases prior to 8.7 are
     * unable to parse gentime values which include fractional seconds;
     * therefore this value must remain set to FALSE in environments where
     * any release 8.6 or lower is present. It should be changed to TRUE once
     * all systems are upgraded to 8.7 or higher.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2018)
    public void unsetLdapGentimeFractionalSecondsEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapGentimeFractionalSecondsEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to include fractional seconds in LDAP gentime values (e.g.
     * zimbraPasswordLockoutFailureTime or
     * zimbraGalLastSuccessfulSyncTimestamp). Releases prior to 8.7 are
     * unable to parse gentime values which include fractional seconds;
     * therefore this value must remain set to FALSE in environments where
     * any release 8.6 or lower is present. It should be changed to TRUE once
     * all systems are upgraded to 8.7 or higher.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2018)
    public Map<String,Object> unsetLdapGentimeFractionalSecondsEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapGentimeFractionalSecondsEnabled, "");
        return attrs;
    }

    /**
     * interface address on which LMTP server should listen; if empty, binds
     * to all interfaces
     *
     * @return zimbraLmtpBindAddress, or empty array if unset
     */
    @ZAttr(id=25)
    public String[] getLmtpBindAddress() {
        return getMultiAttr(Provisioning.A_zimbraLmtpBindAddress);
    }

    /**
     * interface address on which LMTP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraLmtpBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=25)
    public void setLmtpBindAddress(String[] zimbraLmtpBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindAddress, zimbraLmtpBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which LMTP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraLmtpBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=25)
    public Map<String,Object> setLmtpBindAddress(String[] zimbraLmtpBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindAddress, zimbraLmtpBindAddress);
        return attrs;
    }

    /**
     * interface address on which LMTP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraLmtpBindAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=25)
    public void addLmtpBindAddress(String zimbraLmtpBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraLmtpBindAddress, zimbraLmtpBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which LMTP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraLmtpBindAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=25)
    public Map<String,Object> addLmtpBindAddress(String zimbraLmtpBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraLmtpBindAddress, zimbraLmtpBindAddress);
        return attrs;
    }

    /**
     * interface address on which LMTP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraLmtpBindAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=25)
    public void removeLmtpBindAddress(String zimbraLmtpBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraLmtpBindAddress, zimbraLmtpBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which LMTP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraLmtpBindAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=25)
    public Map<String,Object> removeLmtpBindAddress(String zimbraLmtpBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraLmtpBindAddress, zimbraLmtpBindAddress);
        return attrs;
    }

    /**
     * interface address on which LMTP server should listen; if empty, binds
     * to all interfaces
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=25)
    public void unsetLmtpBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which LMTP server should listen; if empty, binds
     * to all interfaces
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=25)
    public Map<String,Object> unsetLmtpBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindAddress, "");
        return attrs;
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @return zimbraLmtpBindOnStartup, or false if unset
     */
    @ZAttr(id=270)
    public boolean isLmtpBindOnStartup() {
        return getBooleanAttr(Provisioning.A_zimbraLmtpBindOnStartup, false);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param zimbraLmtpBindOnStartup new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=270)
    public void setLmtpBindOnStartup(boolean zimbraLmtpBindOnStartup) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindOnStartup, zimbraLmtpBindOnStartup ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param zimbraLmtpBindOnStartup new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=270)
    public Map<String,Object> setLmtpBindOnStartup(boolean zimbraLmtpBindOnStartup, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindOnStartup, zimbraLmtpBindOnStartup ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=270)
    public void unsetLmtpBindOnStartup() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindOnStartup, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=270)
    public Map<String,Object> unsetLmtpBindOnStartup(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindOnStartup, "");
        return attrs;
    }

    /**
     * port number on which LMTP server should listen
     *
     * <p>Use getLmtpBindPortAsString to access value as a string.
     *
     * @see #getLmtpBindPortAsString()
     *
     * @return zimbraLmtpBindPort, or -1 if unset
     */
    @ZAttr(id=24)
    public int getLmtpBindPort() {
        return getIntAttr(Provisioning.A_zimbraLmtpBindPort, -1);
    }

    /**
     * port number on which LMTP server should listen
     *
     * @return zimbraLmtpBindPort, or null if unset
     */
    @ZAttr(id=24)
    public String getLmtpBindPortAsString() {
        return getAttr(Provisioning.A_zimbraLmtpBindPort, null);
    }

    /**
     * port number on which LMTP server should listen
     *
     * @param zimbraLmtpBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=24)
    public void setLmtpBindPort(int zimbraLmtpBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindPort, Integer.toString(zimbraLmtpBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which LMTP server should listen
     *
     * @param zimbraLmtpBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=24)
    public Map<String,Object> setLmtpBindPort(int zimbraLmtpBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindPort, Integer.toString(zimbraLmtpBindPort));
        return attrs;
    }

    /**
     * port number on which LMTP server should listen
     *
     * @param zimbraLmtpBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=24)
    public void setLmtpBindPortAsString(String zimbraLmtpBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindPort, zimbraLmtpBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which LMTP server should listen
     *
     * @param zimbraLmtpBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=24)
    public Map<String,Object> setLmtpBindPortAsString(String zimbraLmtpBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindPort, zimbraLmtpBindPort);
        return attrs;
    }

    /**
     * port number on which LMTP server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=24)
    public void unsetLmtpBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which LMTP server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=24)
    public Map<String,Object> unsetLmtpBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindPort, "");
        return attrs;
    }

    /**
     * Lmtp Server will reject the client transactions which do not issue
     * LHLO
     *
     * @return zimbraLmtpLHLORequired, or false if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1675)
    public boolean isLmtpLHLORequired() {
        return getBooleanAttr(Provisioning.A_zimbraLmtpLHLORequired, false);
    }

    /**
     * Lmtp Server will reject the client transactions which do not issue
     * LHLO
     *
     * @param zimbraLmtpLHLORequired new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1675)
    public void setLmtpLHLORequired(boolean zimbraLmtpLHLORequired) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpLHLORequired, zimbraLmtpLHLORequired ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Lmtp Server will reject the client transactions which do not issue
     * LHLO
     *
     * @param zimbraLmtpLHLORequired new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1675)
    public Map<String,Object> setLmtpLHLORequired(boolean zimbraLmtpLHLORequired, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpLHLORequired, zimbraLmtpLHLORequired ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Lmtp Server will reject the client transactions which do not issue
     * LHLO
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1675)
    public void unsetLmtpLHLORequired() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpLHLORequired, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Lmtp Server will reject the client transactions which do not issue
     * LHLO
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1675)
    public Map<String,Object> unsetLmtpLHLORequired(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpLHLORequired, "");
        return attrs;
    }

    /**
     * Max line length for in the lmtp message as per the rfc 822
     *
     * @return zimbraLmtpMaxLineLength, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1848)
    public int getLmtpMaxLineLength() {
        return getIntAttr(Provisioning.A_zimbraLmtpMaxLineLength, -1);
    }

    /**
     * Max line length for in the lmtp message as per the rfc 822
     *
     * @param zimbraLmtpMaxLineLength new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1848)
    public void setLmtpMaxLineLength(int zimbraLmtpMaxLineLength) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpMaxLineLength, Integer.toString(zimbraLmtpMaxLineLength));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max line length for in the lmtp message as per the rfc 822
     *
     * @param zimbraLmtpMaxLineLength new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1848)
    public Map<String,Object> setLmtpMaxLineLength(int zimbraLmtpMaxLineLength, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpMaxLineLength, Integer.toString(zimbraLmtpMaxLineLength));
        return attrs;
    }

    /**
     * Max line length for in the lmtp message as per the rfc 822
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1848)
    public void unsetLmtpMaxLineLength() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpMaxLineLength, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max line length for in the lmtp message as per the rfc 822
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1848)
    public Map<String,Object> unsetLmtpMaxLineLength(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpMaxLineLength, "");
        return attrs;
    }

    /**
     * number of handler threads, should match MTA concurrency setting for
     * this server
     *
     * @return zimbraLmtpNumThreads, or -1 if unset
     */
    @ZAttr(id=26)
    public int getLmtpNumThreads() {
        return getIntAttr(Provisioning.A_zimbraLmtpNumThreads, -1);
    }

    /**
     * number of handler threads, should match MTA concurrency setting for
     * this server
     *
     * @param zimbraLmtpNumThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=26)
    public void setLmtpNumThreads(int zimbraLmtpNumThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpNumThreads, Integer.toString(zimbraLmtpNumThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of handler threads, should match MTA concurrency setting for
     * this server
     *
     * @param zimbraLmtpNumThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=26)
    public Map<String,Object> setLmtpNumThreads(int zimbraLmtpNumThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpNumThreads, Integer.toString(zimbraLmtpNumThreads));
        return attrs;
    }

    /**
     * number of handler threads, should match MTA concurrency setting for
     * this server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=26)
    public void unsetLmtpNumThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpNumThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of handler threads, should match MTA concurrency setting for
     * this server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=26)
    public Map<String,Object> unsetLmtpNumThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpNumThreads, "");
        return attrs;
    }

    /**
     * If true, a permanent failure (552) is returned when the user is over
     * quota. If false, a temporary failure (452) is returned.
     *
     * @return zimbraLmtpPermanentFailureWhenOverQuota, or false if unset
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=657)
    public boolean isLmtpPermanentFailureWhenOverQuota() {
        return getBooleanAttr(Provisioning.A_zimbraLmtpPermanentFailureWhenOverQuota, false);
    }

    /**
     * If true, a permanent failure (552) is returned when the user is over
     * quota. If false, a temporary failure (452) is returned.
     *
     * @param zimbraLmtpPermanentFailureWhenOverQuota new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=657)
    public void setLmtpPermanentFailureWhenOverQuota(boolean zimbraLmtpPermanentFailureWhenOverQuota) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpPermanentFailureWhenOverQuota, zimbraLmtpPermanentFailureWhenOverQuota ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If true, a permanent failure (552) is returned when the user is over
     * quota. If false, a temporary failure (452) is returned.
     *
     * @param zimbraLmtpPermanentFailureWhenOverQuota new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=657)
    public Map<String,Object> setLmtpPermanentFailureWhenOverQuota(boolean zimbraLmtpPermanentFailureWhenOverQuota, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpPermanentFailureWhenOverQuota, zimbraLmtpPermanentFailureWhenOverQuota ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * If true, a permanent failure (552) is returned when the user is over
     * quota. If false, a temporary failure (452) is returned.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=657)
    public void unsetLmtpPermanentFailureWhenOverQuota() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpPermanentFailureWhenOverQuota, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If true, a permanent failure (552) is returned when the user is over
     * quota. If false, a temporary failure (452) is returned.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=657)
    public Map<String,Object> unsetLmtpPermanentFailureWhenOverQuota(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpPermanentFailureWhenOverQuota, "");
        return attrs;
    }

    /**
     * number of seconds to wait before forcing LMTP server shutdown
     *
     * @return zimbraLmtpShutdownGraceSeconds, or -1 if unset
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1082)
    public int getLmtpShutdownGraceSeconds() {
        return getIntAttr(Provisioning.A_zimbraLmtpShutdownGraceSeconds, -1);
    }

    /**
     * number of seconds to wait before forcing LMTP server shutdown
     *
     * @param zimbraLmtpShutdownGraceSeconds new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1082)
    public void setLmtpShutdownGraceSeconds(int zimbraLmtpShutdownGraceSeconds) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpShutdownGraceSeconds, Integer.toString(zimbraLmtpShutdownGraceSeconds));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of seconds to wait before forcing LMTP server shutdown
     *
     * @param zimbraLmtpShutdownGraceSeconds new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1082)
    public Map<String,Object> setLmtpShutdownGraceSeconds(int zimbraLmtpShutdownGraceSeconds, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpShutdownGraceSeconds, Integer.toString(zimbraLmtpShutdownGraceSeconds));
        return attrs;
    }

    /**
     * number of seconds to wait before forcing LMTP server shutdown
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1082)
    public void unsetLmtpShutdownGraceSeconds() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpShutdownGraceSeconds, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of seconds to wait before forcing LMTP server shutdown
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1082)
    public Map<String,Object> unsetLmtpShutdownGraceSeconds(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpShutdownGraceSeconds, "");
        return attrs;
    }

    /**
     * Lmtp ip throttle. Maximum lmtp requests per second per account.
     *
     * @return zimbraLmtpThrottleIpLimit, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1800)
    public int getLmtpThrottleIpLimit() {
        return getIntAttr(Provisioning.A_zimbraLmtpThrottleIpLimit, -1);
    }

    /**
     * Lmtp ip throttle. Maximum lmtp requests per second per account.
     *
     * @param zimbraLmtpThrottleIpLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1800)
    public void setLmtpThrottleIpLimit(int zimbraLmtpThrottleIpLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpThrottleIpLimit, Integer.toString(zimbraLmtpThrottleIpLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Lmtp ip throttle. Maximum lmtp requests per second per account.
     *
     * @param zimbraLmtpThrottleIpLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1800)
    public Map<String,Object> setLmtpThrottleIpLimit(int zimbraLmtpThrottleIpLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpThrottleIpLimit, Integer.toString(zimbraLmtpThrottleIpLimit));
        return attrs;
    }

    /**
     * Lmtp ip throttle. Maximum lmtp requests per second per account.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1800)
    public void unsetLmtpThrottleIpLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpThrottleIpLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Lmtp ip throttle. Maximum lmtp requests per second per account.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1800)
    public Map<String,Object> unsetLmtpThrottleIpLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpThrottleIpLimit, "");
        return attrs;
    }

    /**
     * If true, validate the content of incoming LMTP messages
     *
     * @return zimbraLmtpValidateMessages, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1849)
    public boolean isLmtpValidateMessages() {
        return getBooleanAttr(Provisioning.A_zimbraLmtpValidateMessages, false);
    }

    /**
     * If true, validate the content of incoming LMTP messages
     *
     * @param zimbraLmtpValidateMessages new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1849)
    public void setLmtpValidateMessages(boolean zimbraLmtpValidateMessages) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpValidateMessages, zimbraLmtpValidateMessages ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If true, validate the content of incoming LMTP messages
     *
     * @param zimbraLmtpValidateMessages new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1849)
    public Map<String,Object> setLmtpValidateMessages(boolean zimbraLmtpValidateMessages, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpValidateMessages, zimbraLmtpValidateMessages ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * If true, validate the content of incoming LMTP messages
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1849)
    public void unsetLmtpValidateMessages() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpValidateMessages, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If true, validate the content of incoming LMTP messages
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1849)
    public Map<String,Object> unsetLmtpValidateMessages(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpValidateMessages, "");
        return attrs;
    }

    /**
     * locale of entry, e.g. en_US
     *
     * @return zimbraLocale, or null if unset
     */
    @ZAttr(id=345)
    public String getLocaleAsString() {
        return getAttr(Provisioning.A_zimbraLocale, null);
    }

    /**
     * locale of entry, e.g. en_US
     *
     * @param zimbraLocale new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=345)
    public void setLocale(String zimbraLocale) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLocale, zimbraLocale);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * locale of entry, e.g. en_US
     *
     * @param zimbraLocale new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=345)
    public Map<String,Object> setLocale(String zimbraLocale, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLocale, zimbraLocale);
        return attrs;
    }

    /**
     * locale of entry, e.g. en_US
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=345)
    public void unsetLocale() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLocale, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * locale of entry, e.g. en_US
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=345)
    public Map<String,Object> unsetLocale(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLocale, "");
        return attrs;
    }

    /**
     * whether mailbox server should log to syslog
     *
     * @return zimbraLogToSyslog, or false if unset
     */
    @ZAttr(id=520)
    public boolean isLogToSyslog() {
        return getBooleanAttr(Provisioning.A_zimbraLogToSyslog, false);
    }

    /**
     * whether mailbox server should log to syslog
     *
     * @param zimbraLogToSyslog new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=520)
    public void setLogToSyslog(boolean zimbraLogToSyslog) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogToSyslog, zimbraLogToSyslog ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether mailbox server should log to syslog
     *
     * @param zimbraLogToSyslog new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=520)
    public Map<String,Object> setLogToSyslog(boolean zimbraLogToSyslog, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogToSyslog, zimbraLogToSyslog ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * whether mailbox server should log to syslog
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=520)
    public void unsetLogToSyslog() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogToSyslog, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether mailbox server should log to syslog
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=520)
    public Map<String,Object> unsetLogToSyslog(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogToSyslog, "");
        return attrs;
    }

    /**
     * version of lowest supported authentication protocol
     *
     * @return zimbraLowestSupportedAuthVersion, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1589)
    public int getLowestSupportedAuthVersion() {
        return getIntAttr(Provisioning.A_zimbraLowestSupportedAuthVersion, -1);
    }

    /**
     * version of lowest supported authentication protocol
     *
     * @param zimbraLowestSupportedAuthVersion new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1589)
    public void setLowestSupportedAuthVersion(int zimbraLowestSupportedAuthVersion) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLowestSupportedAuthVersion, Integer.toString(zimbraLowestSupportedAuthVersion));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * version of lowest supported authentication protocol
     *
     * @param zimbraLowestSupportedAuthVersion new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1589)
    public Map<String,Object> setLowestSupportedAuthVersion(int zimbraLowestSupportedAuthVersion, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLowestSupportedAuthVersion, Integer.toString(zimbraLowestSupportedAuthVersion));
        return attrs;
    }

    /**
     * version of lowest supported authentication protocol
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1589)
    public void unsetLowestSupportedAuthVersion() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLowestSupportedAuthVersion, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * version of lowest supported authentication protocol
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1589)
    public Map<String,Object> unsetLowestSupportedAuthVersion(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLowestSupportedAuthVersion, "");
        return attrs;
    }

    /**
     * interface address on which HTTP server should listen; if empty, binds
     * to all interfaces
     *
     * @return zimbraMailBindAddress, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1365)
    public String getMailBindAddress() {
        return getAttr(Provisioning.A_zimbraMailBindAddress, null);
    }

    /**
     * interface address on which HTTP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraMailBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1365)
    public void setMailBindAddress(String zimbraMailBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailBindAddress, zimbraMailBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which HTTP server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraMailBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1365)
    public Map<String,Object> setMailBindAddress(String zimbraMailBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailBindAddress, zimbraMailBindAddress);
        return attrs;
    }

    /**
     * interface address on which HTTP server should listen; if empty, binds
     * to all interfaces
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1365)
    public void unsetMailBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which HTTP server should listen; if empty, binds
     * to all interfaces
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1365)
    public Map<String,Object> unsetMailBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailBindAddress, "");
        return attrs;
    }

    /**
     * Mailbox lock read write flag
     *
     * @return zimbraMailBoxLockReadWrite, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1733)
    public boolean isMailBoxLockReadWrite() {
        return getBooleanAttr(Provisioning.A_zimbraMailBoxLockReadWrite, false);
    }

    /**
     * Mailbox lock read write flag
     *
     * @param zimbraMailBoxLockReadWrite new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1733)
    public void setMailBoxLockReadWrite(boolean zimbraMailBoxLockReadWrite) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailBoxLockReadWrite, zimbraMailBoxLockReadWrite ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Mailbox lock read write flag
     *
     * @param zimbraMailBoxLockReadWrite new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1733)
    public Map<String,Object> setMailBoxLockReadWrite(boolean zimbraMailBoxLockReadWrite, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailBoxLockReadWrite, zimbraMailBoxLockReadWrite ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Mailbox lock read write flag
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1733)
    public void unsetMailBoxLockReadWrite() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailBoxLockReadWrite, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Mailbox lock read write flag
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1733)
    public Map<String,Object> unsetMailBoxLockReadWrite(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailBoxLockReadWrite, "");
        return attrs;
    }

    /**
     * Maximum timeout in seconds for mailbox lock
     *
     * @return zimbraMailBoxLockTimeout, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1734)
    public int getMailBoxLockTimeout() {
        return getIntAttr(Provisioning.A_zimbraMailBoxLockTimeout, -1);
    }

    /**
     * Maximum timeout in seconds for mailbox lock
     *
     * @param zimbraMailBoxLockTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1734)
    public void setMailBoxLockTimeout(int zimbraMailBoxLockTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailBoxLockTimeout, Integer.toString(zimbraMailBoxLockTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum timeout in seconds for mailbox lock
     *
     * @param zimbraMailBoxLockTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1734)
    public Map<String,Object> setMailBoxLockTimeout(int zimbraMailBoxLockTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailBoxLockTimeout, Integer.toString(zimbraMailBoxLockTimeout));
        return attrs;
    }

    /**
     * Maximum timeout in seconds for mailbox lock
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1734)
    public void unsetMailBoxLockTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailBoxLockTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum timeout in seconds for mailbox lock
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1734)
    public Map<String,Object> unsetMailBoxLockTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailBoxLockTimeout, "");
        return attrs;
    }

    /**
     * Whether to allow password sent to non-secured port when zimbraMailMode
     * is mixed. If it set to TRUE the server will allow login with clear
     * text AuthRequests and change password with clear text
     * ChangePasswordRequest. If it set to FALSE the server will return an
     * error if an attempt is made to ChangePasswordRequest or AuthRequest.
     *
     * @return zimbraMailClearTextPasswordEnabled, or false if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=791)
    public boolean isMailClearTextPasswordEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMailClearTextPasswordEnabled, false);
    }

    /**
     * Whether to allow password sent to non-secured port when zimbraMailMode
     * is mixed. If it set to TRUE the server will allow login with clear
     * text AuthRequests and change password with clear text
     * ChangePasswordRequest. If it set to FALSE the server will return an
     * error if an attempt is made to ChangePasswordRequest or AuthRequest.
     *
     * @param zimbraMailClearTextPasswordEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=791)
    public void setMailClearTextPasswordEnabled(boolean zimbraMailClearTextPasswordEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailClearTextPasswordEnabled, zimbraMailClearTextPasswordEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow password sent to non-secured port when zimbraMailMode
     * is mixed. If it set to TRUE the server will allow login with clear
     * text AuthRequests and change password with clear text
     * ChangePasswordRequest. If it set to FALSE the server will return an
     * error if an attempt is made to ChangePasswordRequest or AuthRequest.
     *
     * @param zimbraMailClearTextPasswordEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=791)
    public Map<String,Object> setMailClearTextPasswordEnabled(boolean zimbraMailClearTextPasswordEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailClearTextPasswordEnabled, zimbraMailClearTextPasswordEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether to allow password sent to non-secured port when zimbraMailMode
     * is mixed. If it set to TRUE the server will allow login with clear
     * text AuthRequests and change password with clear text
     * ChangePasswordRequest. If it set to FALSE the server will return an
     * error if an attempt is made to ChangePasswordRequest or AuthRequest.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=791)
    public void unsetMailClearTextPasswordEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailClearTextPasswordEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow password sent to non-secured port when zimbraMailMode
     * is mixed. If it set to TRUE the server will allow login with clear
     * text AuthRequests and change password with clear text
     * ChangePasswordRequest. If it set to FALSE the server will return an
     * error if an attempt is made to ChangePasswordRequest or AuthRequest.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=791)
    public Map<String,Object> unsetMailClearTextPasswordEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailClearTextPasswordEnabled, "");
        return attrs;
    }

    /**
     * Maximum size in bytes for the &lt;content &gt; element in SOAP. Mail
     * content larger than this limit will be truncated.
     *
     * @return zimbraMailContentMaxSize, or -1 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=807)
    public long getMailContentMaxSize() {
        return getLongAttr(Provisioning.A_zimbraMailContentMaxSize, -1L);
    }

    /**
     * Maximum size in bytes for the &lt;content &gt; element in SOAP. Mail
     * content larger than this limit will be truncated.
     *
     * @param zimbraMailContentMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=807)
    public void setMailContentMaxSize(long zimbraMailContentMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailContentMaxSize, Long.toString(zimbraMailContentMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum size in bytes for the &lt;content &gt; element in SOAP. Mail
     * content larger than this limit will be truncated.
     *
     * @param zimbraMailContentMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=807)
    public Map<String,Object> setMailContentMaxSize(long zimbraMailContentMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailContentMaxSize, Long.toString(zimbraMailContentMaxSize));
        return attrs;
    }

    /**
     * Maximum size in bytes for the &lt;content &gt; element in SOAP. Mail
     * content larger than this limit will be truncated.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=807)
    public void unsetMailContentMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailContentMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum size in bytes for the &lt;content &gt; element in SOAP. Mail
     * content larger than this limit will be truncated.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=807)
    public Map<String,Object> unsetMailContentMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailContentMaxSize, "");
        return attrs;
    }

    /**
     * Maximum number of messages to delete during a single transaction when
     * emptying a large folder.
     *
     * @return zimbraMailEmptyFolderBatchSize, or -1 if unset
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1097)
    public int getMailEmptyFolderBatchSize() {
        return getIntAttr(Provisioning.A_zimbraMailEmptyFolderBatchSize, -1);
    }

    /**
     * Maximum number of messages to delete during a single transaction when
     * emptying a large folder.
     *
     * @param zimbraMailEmptyFolderBatchSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1097)
    public void setMailEmptyFolderBatchSize(int zimbraMailEmptyFolderBatchSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailEmptyFolderBatchSize, Integer.toString(zimbraMailEmptyFolderBatchSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of messages to delete during a single transaction when
     * emptying a large folder.
     *
     * @param zimbraMailEmptyFolderBatchSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1097)
    public Map<String,Object> setMailEmptyFolderBatchSize(int zimbraMailEmptyFolderBatchSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailEmptyFolderBatchSize, Integer.toString(zimbraMailEmptyFolderBatchSize));
        return attrs;
    }

    /**
     * Maximum number of messages to delete during a single transaction when
     * emptying a large folder.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1097)
    public void unsetMailEmptyFolderBatchSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailEmptyFolderBatchSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of messages to delete during a single transaction when
     * emptying a large folder.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1097)
    public Map<String,Object> unsetMailEmptyFolderBatchSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailEmptyFolderBatchSize, "");
        return attrs;
    }

    /**
     * Number of bytes to buffer in memory per file descriptor in the cache.
     * Larger values result in fewer disk reads, but increase memory
     * consumption.
     *
     * @return zimbraMailFileDescriptorBufferSize, or -1 if unset
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1035)
    public int getMailFileDescriptorBufferSize() {
        return getIntAttr(Provisioning.A_zimbraMailFileDescriptorBufferSize, -1);
    }

    /**
     * Number of bytes to buffer in memory per file descriptor in the cache.
     * Larger values result in fewer disk reads, but increase memory
     * consumption.
     *
     * @param zimbraMailFileDescriptorBufferSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1035)
    public void setMailFileDescriptorBufferSize(int zimbraMailFileDescriptorBufferSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailFileDescriptorBufferSize, Integer.toString(zimbraMailFileDescriptorBufferSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Number of bytes to buffer in memory per file descriptor in the cache.
     * Larger values result in fewer disk reads, but increase memory
     * consumption.
     *
     * @param zimbraMailFileDescriptorBufferSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1035)
    public Map<String,Object> setMailFileDescriptorBufferSize(int zimbraMailFileDescriptorBufferSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailFileDescriptorBufferSize, Integer.toString(zimbraMailFileDescriptorBufferSize));
        return attrs;
    }

    /**
     * Number of bytes to buffer in memory per file descriptor in the cache.
     * Larger values result in fewer disk reads, but increase memory
     * consumption.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1035)
    public void unsetMailFileDescriptorBufferSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailFileDescriptorBufferSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Number of bytes to buffer in memory per file descriptor in the cache.
     * Larger values result in fewer disk reads, but increase memory
     * consumption.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1035)
    public Map<String,Object> unsetMailFileDescriptorBufferSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailFileDescriptorBufferSize, "");
        return attrs;
    }

    /**
     * Maximum number of file descriptors that are opened for accessing
     * message content.
     *
     * @return zimbraMailFileDescriptorCacheSize, or -1 if unset
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1034)
    public int getMailFileDescriptorCacheSize() {
        return getIntAttr(Provisioning.A_zimbraMailFileDescriptorCacheSize, -1);
    }

    /**
     * Maximum number of file descriptors that are opened for accessing
     * message content.
     *
     * @param zimbraMailFileDescriptorCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1034)
    public void setMailFileDescriptorCacheSize(int zimbraMailFileDescriptorCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailFileDescriptorCacheSize, Integer.toString(zimbraMailFileDescriptorCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of file descriptors that are opened for accessing
     * message content.
     *
     * @param zimbraMailFileDescriptorCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1034)
    public Map<String,Object> setMailFileDescriptorCacheSize(int zimbraMailFileDescriptorCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailFileDescriptorCacheSize, Integer.toString(zimbraMailFileDescriptorCacheSize));
        return attrs;
    }

    /**
     * Maximum number of file descriptors that are opened for accessing
     * message content.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1034)
    public void unsetMailFileDescriptorCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailFileDescriptorCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of file descriptors that are opened for accessing
     * message content.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1034)
    public Map<String,Object> unsetMailFileDescriptorCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailFileDescriptorCacheSize, "");
        return attrs;
    }

    /**
     * When set to true, robots.txt on mailboxd will be set up to keep web
     * crawlers out
     *
     * @return zimbraMailKeepOutWebCrawlers, or false if unset
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1161)
    public boolean isMailKeepOutWebCrawlers() {
        return getBooleanAttr(Provisioning.A_zimbraMailKeepOutWebCrawlers, false);
    }

    /**
     * When set to true, robots.txt on mailboxd will be set up to keep web
     * crawlers out
     *
     * @param zimbraMailKeepOutWebCrawlers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1161)
    public void setMailKeepOutWebCrawlers(boolean zimbraMailKeepOutWebCrawlers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailKeepOutWebCrawlers, zimbraMailKeepOutWebCrawlers ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When set to true, robots.txt on mailboxd will be set up to keep web
     * crawlers out
     *
     * @param zimbraMailKeepOutWebCrawlers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1161)
    public Map<String,Object> setMailKeepOutWebCrawlers(boolean zimbraMailKeepOutWebCrawlers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailKeepOutWebCrawlers, zimbraMailKeepOutWebCrawlers ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * When set to true, robots.txt on mailboxd will be set up to keep web
     * crawlers out
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1161)
    public void unsetMailKeepOutWebCrawlers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailKeepOutWebCrawlers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When set to true, robots.txt on mailboxd will be set up to keep web
     * crawlers out
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1161)
    public Map<String,Object> unsetMailKeepOutWebCrawlers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailKeepOutWebCrawlers, "");
        return attrs;
    }

    /**
     * whether to run HTTP or HTTPS or both/mixed mode or redirect mode. See
     * also related attributes zimbraMailPort and zimbraMailSSLPort
     *
     * <p>Valid values: [redirect, http, mixed, https, both]
     *
     * @return zimbraMailMode, or null if unset and/or has invalid value
     */
    @ZAttr(id=308)
    public ZAttrProvisioning.MailMode getMailMode() {
        try { String v = getAttr(Provisioning.A_zimbraMailMode); return v == null ? null : ZAttrProvisioning.MailMode.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * whether to run HTTP or HTTPS or both/mixed mode or redirect mode. See
     * also related attributes zimbraMailPort and zimbraMailSSLPort
     *
     * <p>Valid values: [redirect, http, mixed, https, both]
     *
     * @return zimbraMailMode, or null if unset
     */
    @ZAttr(id=308)
    public String getMailModeAsString() {
        return getAttr(Provisioning.A_zimbraMailMode, null);
    }

    /**
     * whether to run HTTP or HTTPS or both/mixed mode or redirect mode. See
     * also related attributes zimbraMailPort and zimbraMailSSLPort
     *
     * <p>Valid values: [redirect, http, mixed, https, both]
     *
     * @param zimbraMailMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=308)
    public void setMailMode(ZAttrProvisioning.MailMode zimbraMailMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMode, zimbraMailMode.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to run HTTP or HTTPS or both/mixed mode or redirect mode. See
     * also related attributes zimbraMailPort and zimbraMailSSLPort
     *
     * <p>Valid values: [redirect, http, mixed, https, both]
     *
     * @param zimbraMailMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=308)
    public Map<String,Object> setMailMode(ZAttrProvisioning.MailMode zimbraMailMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMode, zimbraMailMode.toString());
        return attrs;
    }

    /**
     * whether to run HTTP or HTTPS or both/mixed mode or redirect mode. See
     * also related attributes zimbraMailPort and zimbraMailSSLPort
     *
     * <p>Valid values: [redirect, http, mixed, https, both]
     *
     * @param zimbraMailMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=308)
    public void setMailModeAsString(String zimbraMailMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMode, zimbraMailMode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to run HTTP or HTTPS or both/mixed mode or redirect mode. See
     * also related attributes zimbraMailPort and zimbraMailSSLPort
     *
     * <p>Valid values: [redirect, http, mixed, https, both]
     *
     * @param zimbraMailMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=308)
    public Map<String,Object> setMailModeAsString(String zimbraMailMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMode, zimbraMailMode);
        return attrs;
    }

    /**
     * whether to run HTTP or HTTPS or both/mixed mode or redirect mode. See
     * also related attributes zimbraMailPort and zimbraMailSSLPort
     *
     * <p>Valid values: [redirect, http, mixed, https, both]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=308)
    public void unsetMailMode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to run HTTP or HTTPS or both/mixed mode or redirect mode. See
     * also related attributes zimbraMailPort and zimbraMailSSLPort
     *
     * <p>Valid values: [redirect, http, mixed, https, both]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=308)
    public Map<String,Object> unsetMailMode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMode, "");
        return attrs;
    }

    /**
     * Flag to enable notes
     *
     * @return zimbraMailNotesEnabled, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1804)
    public boolean isMailNotesEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMailNotesEnabled, false);
    }

    /**
     * Flag to enable notes
     *
     * @param zimbraMailNotesEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1804)
    public void setMailNotesEnabled(boolean zimbraMailNotesEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailNotesEnabled, zimbraMailNotesEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable notes
     *
     * @param zimbraMailNotesEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1804)
    public Map<String,Object> setMailNotesEnabled(boolean zimbraMailNotesEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailNotesEnabled, zimbraMailNotesEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to enable notes
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1804)
    public void unsetMailNotesEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailNotesEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable notes
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1804)
    public Map<String,Object> unsetMailNotesEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailNotesEnabled, "");
        return attrs;
    }

    /**
     * HTTP port for end-user UI
     *
     * <p>Use getMailPortAsString to access value as a string.
     *
     * @see #getMailPortAsString()
     *
     * @return zimbraMailPort, or -1 if unset
     */
    @ZAttr(id=154)
    public int getMailPort() {
        return getIntAttr(Provisioning.A_zimbraMailPort, -1);
    }

    /**
     * HTTP port for end-user UI
     *
     * @return zimbraMailPort, or null if unset
     */
    @ZAttr(id=154)
    public String getMailPortAsString() {
        return getAttr(Provisioning.A_zimbraMailPort, null);
    }

    /**
     * HTTP port for end-user UI
     *
     * @param zimbraMailPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=154)
    public void setMailPort(int zimbraMailPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPort, Integer.toString(zimbraMailPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTP port for end-user UI
     *
     * @param zimbraMailPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=154)
    public Map<String,Object> setMailPort(int zimbraMailPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPort, Integer.toString(zimbraMailPort));
        return attrs;
    }

    /**
     * HTTP port for end-user UI
     *
     * @param zimbraMailPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=154)
    public void setMailPortAsString(String zimbraMailPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPort, zimbraMailPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTP port for end-user UI
     *
     * @param zimbraMailPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=154)
    public Map<String,Object> setMailPortAsString(String zimbraMailPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPort, zimbraMailPort);
        return attrs;
    }

    /**
     * HTTP port for end-user UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=154)
    public void unsetMailPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTP port for end-user UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=154)
    public Map<String,Object> unsetMailPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPort, "");
        return attrs;
    }

    /**
     * The max number of unsuccessful attempts to connect to the current
     * server (as an upstream). If this number is reached, proxy will refuse
     * to connect to the current server, wait for
     * zimbraMailProxyReconnectTimeout and then try to reconnect. Default
     * value is 1. Setting this to 0 means turning this check off.
     *
     * @return zimbraMailProxyMaxFails, or -1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1358)
    public int getMailProxyMaxFails() {
        return getIntAttr(Provisioning.A_zimbraMailProxyMaxFails, -1);
    }

    /**
     * The max number of unsuccessful attempts to connect to the current
     * server (as an upstream). If this number is reached, proxy will refuse
     * to connect to the current server, wait for
     * zimbraMailProxyReconnectTimeout and then try to reconnect. Default
     * value is 1. Setting this to 0 means turning this check off.
     *
     * @param zimbraMailProxyMaxFails new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1358)
    public void setMailProxyMaxFails(int zimbraMailProxyMaxFails) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyMaxFails, Integer.toString(zimbraMailProxyMaxFails));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The max number of unsuccessful attempts to connect to the current
     * server (as an upstream). If this number is reached, proxy will refuse
     * to connect to the current server, wait for
     * zimbraMailProxyReconnectTimeout and then try to reconnect. Default
     * value is 1. Setting this to 0 means turning this check off.
     *
     * @param zimbraMailProxyMaxFails new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1358)
    public Map<String,Object> setMailProxyMaxFails(int zimbraMailProxyMaxFails, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyMaxFails, Integer.toString(zimbraMailProxyMaxFails));
        return attrs;
    }

    /**
     * The max number of unsuccessful attempts to connect to the current
     * server (as an upstream). If this number is reached, proxy will refuse
     * to connect to the current server, wait for
     * zimbraMailProxyReconnectTimeout and then try to reconnect. Default
     * value is 1. Setting this to 0 means turning this check off.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1358)
    public void unsetMailProxyMaxFails() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyMaxFails, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The max number of unsuccessful attempts to connect to the current
     * server (as an upstream). If this number is reached, proxy will refuse
     * to connect to the current server, wait for
     * zimbraMailProxyReconnectTimeout and then try to reconnect. Default
     * value is 1. Setting this to 0 means turning this check off.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1358)
    public Map<String,Object> unsetMailProxyMaxFails(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyMaxFails, "");
        return attrs;
    }

    /**
     * the time in sec that proxy will reconnect the current server (as an
     * upstream) after connection errors happened before
     *
     * @return zimbraMailProxyReconnectTimeout, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1268)
    public String getMailProxyReconnectTimeout() {
        return getAttr(Provisioning.A_zimbraMailProxyReconnectTimeout, null);
    }

    /**
     * the time in sec that proxy will reconnect the current server (as an
     * upstream) after connection errors happened before
     *
     * @param zimbraMailProxyReconnectTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1268)
    public void setMailProxyReconnectTimeout(String zimbraMailProxyReconnectTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyReconnectTimeout, zimbraMailProxyReconnectTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the time in sec that proxy will reconnect the current server (as an
     * upstream) after connection errors happened before
     *
     * @param zimbraMailProxyReconnectTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1268)
    public Map<String,Object> setMailProxyReconnectTimeout(String zimbraMailProxyReconnectTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyReconnectTimeout, zimbraMailProxyReconnectTimeout);
        return attrs;
    }

    /**
     * the time in sec that proxy will reconnect the current server (as an
     * upstream) after connection errors happened before
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1268)
    public void unsetMailProxyReconnectTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyReconnectTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the time in sec that proxy will reconnect the current server (as an
     * upstream) after connection errors happened before
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1268)
    public Map<String,Object> unsetMailProxyReconnectTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyReconnectTimeout, "");
        return attrs;
    }

    /**
     * Maximum number of messages to delete from a folder during a single
     * purge operation. If the limit is exceeded, the mailbox is purged again
     * at the end of the purge cycle until all qualifying messages are
     * purged.
     *
     * @return zimbraMailPurgeBatchSize, or -1 if unset
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1096)
    public int getMailPurgeBatchSize() {
        return getIntAttr(Provisioning.A_zimbraMailPurgeBatchSize, -1);
    }

    /**
     * Maximum number of messages to delete from a folder during a single
     * purge operation. If the limit is exceeded, the mailbox is purged again
     * at the end of the purge cycle until all qualifying messages are
     * purged.
     *
     * @param zimbraMailPurgeBatchSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1096)
    public void setMailPurgeBatchSize(int zimbraMailPurgeBatchSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeBatchSize, Integer.toString(zimbraMailPurgeBatchSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of messages to delete from a folder during a single
     * purge operation. If the limit is exceeded, the mailbox is purged again
     * at the end of the purge cycle until all qualifying messages are
     * purged.
     *
     * @param zimbraMailPurgeBatchSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1096)
    public Map<String,Object> setMailPurgeBatchSize(int zimbraMailPurgeBatchSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeBatchSize, Integer.toString(zimbraMailPurgeBatchSize));
        return attrs;
    }

    /**
     * Maximum number of messages to delete from a folder during a single
     * purge operation. If the limit is exceeded, the mailbox is purged again
     * at the end of the purge cycle until all qualifying messages are
     * purged.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1096)
    public void unsetMailPurgeBatchSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeBatchSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of messages to delete from a folder during a single
     * purge operation. If the limit is exceeded, the mailbox is purged again
     * at the end of the purge cycle until all qualifying messages are
     * purged.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1096)
    public Map<String,Object> unsetMailPurgeBatchSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeBatchSize, "");
        return attrs;
    }

    /**
     * If TRUE, the envelope sender of a message redirected by mail filters
     * will be set to the users address. If FALSE, the envelope sender will
     * be set to the From address of the redirected message.
     *
     * @return zimbraMailRedirectSetEnvelopeSender, or false if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=764)
    public boolean isMailRedirectSetEnvelopeSender() {
        return getBooleanAttr(Provisioning.A_zimbraMailRedirectSetEnvelopeSender, false);
    }

    /**
     * If TRUE, the envelope sender of a message redirected by mail filters
     * will be set to the users address. If FALSE, the envelope sender will
     * be set to the From address of the redirected message.
     *
     * @param zimbraMailRedirectSetEnvelopeSender new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=764)
    public void setMailRedirectSetEnvelopeSender(boolean zimbraMailRedirectSetEnvelopeSender) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailRedirectSetEnvelopeSender, zimbraMailRedirectSetEnvelopeSender ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, the envelope sender of a message redirected by mail filters
     * will be set to the users address. If FALSE, the envelope sender will
     * be set to the From address of the redirected message.
     *
     * @param zimbraMailRedirectSetEnvelopeSender new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=764)
    public Map<String,Object> setMailRedirectSetEnvelopeSender(boolean zimbraMailRedirectSetEnvelopeSender, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailRedirectSetEnvelopeSender, zimbraMailRedirectSetEnvelopeSender ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * If TRUE, the envelope sender of a message redirected by mail filters
     * will be set to the users address. If FALSE, the envelope sender will
     * be set to the From address of the redirected message.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=764)
    public void unsetMailRedirectSetEnvelopeSender() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailRedirectSetEnvelopeSender, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, the envelope sender of a message redirected by mail filters
     * will be set to the users address. If FALSE, the envelope sender will
     * be set to the From address of the redirected message.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=764)
    public Map<String,Object> unsetMailRedirectSetEnvelopeSender(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailRedirectSetEnvelopeSender, "");
        return attrs;
    }

    /**
     * interface address on which HTTPS server should listen; if empty, binds
     * to all interfaces
     *
     * @return zimbraMailSSLBindAddress, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1366)
    public String getMailSSLBindAddress() {
        return getAttr(Provisioning.A_zimbraMailSSLBindAddress, null);
    }

    /**
     * interface address on which HTTPS server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraMailSSLBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1366)
    public void setMailSSLBindAddress(String zimbraMailSSLBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLBindAddress, zimbraMailSSLBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which HTTPS server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraMailSSLBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1366)
    public Map<String,Object> setMailSSLBindAddress(String zimbraMailSSLBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLBindAddress, zimbraMailSSLBindAddress);
        return attrs;
    }

    /**
     * interface address on which HTTPS server should listen; if empty, binds
     * to all interfaces
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1366)
    public void unsetMailSSLBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which HTTPS server should listen; if empty, binds
     * to all interfaces
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1366)
    public Map<String,Object> unsetMailSSLBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLBindAddress, "");
        return attrs;
    }

    /**
     * interface address on which HTTPS server accepting client certificates
     * should listen; if empty, binds to all interfaces
     *
     * @return zimbraMailSSLClientCertBindAddress, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1367)
    public String getMailSSLClientCertBindAddress() {
        return getAttr(Provisioning.A_zimbraMailSSLClientCertBindAddress, null);
    }

    /**
     * interface address on which HTTPS server accepting client certificates
     * should listen; if empty, binds to all interfaces
     *
     * @param zimbraMailSSLClientCertBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1367)
    public void setMailSSLClientCertBindAddress(String zimbraMailSSLClientCertBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertBindAddress, zimbraMailSSLClientCertBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which HTTPS server accepting client certificates
     * should listen; if empty, binds to all interfaces
     *
     * @param zimbraMailSSLClientCertBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1367)
    public Map<String,Object> setMailSSLClientCertBindAddress(String zimbraMailSSLClientCertBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertBindAddress, zimbraMailSSLClientCertBindAddress);
        return attrs;
    }

    /**
     * interface address on which HTTPS server accepting client certificates
     * should listen; if empty, binds to all interfaces
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1367)
    public void unsetMailSSLClientCertBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which HTTPS server accepting client certificates
     * should listen; if empty, binds to all interfaces
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1367)
    public Map<String,Object> unsetMailSSLClientCertBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertBindAddress, "");
        return attrs;
    }

    /**
     * enable authentication via X.509 Client Certificate. Disabled: client
     * authentication is disabled. NeedClientAuth: client authentication is
     * required during SSL handshake on the SSL mutual authentication
     * port(see zimbraMailSSLClientCertPort). The SSL handshake will fail if
     * the client does not present a certificate to authenticate.
     * WantClientAuth: client authentication is requested during SSL
     * handshake on the SSL mutual authentication port(see
     * zimbraMailSSLClientCertPort). The SSL handshake will still proceed if
     * the client does not present a certificate to authenticate. In the case
     * when client does not send a certificate, user will be redirected to
     * the usual entry page of the requested webapp, where username/password
     * is prompted.
     *
     * <p>Valid values: [Disabled, NeedClientAuth, WantClientAuth]
     *
     * @return zimbraMailSSLClientCertMode, or null if unset and/or has invalid value
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1190)
    public ZAttrProvisioning.MailSSLClientCertMode getMailSSLClientCertMode() {
        try { String v = getAttr(Provisioning.A_zimbraMailSSLClientCertMode); return v == null ? null : ZAttrProvisioning.MailSSLClientCertMode.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * enable authentication via X.509 Client Certificate. Disabled: client
     * authentication is disabled. NeedClientAuth: client authentication is
     * required during SSL handshake on the SSL mutual authentication
     * port(see zimbraMailSSLClientCertPort). The SSL handshake will fail if
     * the client does not present a certificate to authenticate.
     * WantClientAuth: client authentication is requested during SSL
     * handshake on the SSL mutual authentication port(see
     * zimbraMailSSLClientCertPort). The SSL handshake will still proceed if
     * the client does not present a certificate to authenticate. In the case
     * when client does not send a certificate, user will be redirected to
     * the usual entry page of the requested webapp, where username/password
     * is prompted.
     *
     * <p>Valid values: [Disabled, NeedClientAuth, WantClientAuth]
     *
     * @return zimbraMailSSLClientCertMode, or null if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1190)
    public String getMailSSLClientCertModeAsString() {
        return getAttr(Provisioning.A_zimbraMailSSLClientCertMode, null);
    }

    /**
     * enable authentication via X.509 Client Certificate. Disabled: client
     * authentication is disabled. NeedClientAuth: client authentication is
     * required during SSL handshake on the SSL mutual authentication
     * port(see zimbraMailSSLClientCertPort). The SSL handshake will fail if
     * the client does not present a certificate to authenticate.
     * WantClientAuth: client authentication is requested during SSL
     * handshake on the SSL mutual authentication port(see
     * zimbraMailSSLClientCertPort). The SSL handshake will still proceed if
     * the client does not present a certificate to authenticate. In the case
     * when client does not send a certificate, user will be redirected to
     * the usual entry page of the requested webapp, where username/password
     * is prompted.
     *
     * <p>Valid values: [Disabled, NeedClientAuth, WantClientAuth]
     *
     * @param zimbraMailSSLClientCertMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1190)
    public void setMailSSLClientCertMode(ZAttrProvisioning.MailSSLClientCertMode zimbraMailSSLClientCertMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertMode, zimbraMailSSLClientCertMode.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable authentication via X.509 Client Certificate. Disabled: client
     * authentication is disabled. NeedClientAuth: client authentication is
     * required during SSL handshake on the SSL mutual authentication
     * port(see zimbraMailSSLClientCertPort). The SSL handshake will fail if
     * the client does not present a certificate to authenticate.
     * WantClientAuth: client authentication is requested during SSL
     * handshake on the SSL mutual authentication port(see
     * zimbraMailSSLClientCertPort). The SSL handshake will still proceed if
     * the client does not present a certificate to authenticate. In the case
     * when client does not send a certificate, user will be redirected to
     * the usual entry page of the requested webapp, where username/password
     * is prompted.
     *
     * <p>Valid values: [Disabled, NeedClientAuth, WantClientAuth]
     *
     * @param zimbraMailSSLClientCertMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1190)
    public Map<String,Object> setMailSSLClientCertMode(ZAttrProvisioning.MailSSLClientCertMode zimbraMailSSLClientCertMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertMode, zimbraMailSSLClientCertMode.toString());
        return attrs;
    }

    /**
     * enable authentication via X.509 Client Certificate. Disabled: client
     * authentication is disabled. NeedClientAuth: client authentication is
     * required during SSL handshake on the SSL mutual authentication
     * port(see zimbraMailSSLClientCertPort). The SSL handshake will fail if
     * the client does not present a certificate to authenticate.
     * WantClientAuth: client authentication is requested during SSL
     * handshake on the SSL mutual authentication port(see
     * zimbraMailSSLClientCertPort). The SSL handshake will still proceed if
     * the client does not present a certificate to authenticate. In the case
     * when client does not send a certificate, user will be redirected to
     * the usual entry page of the requested webapp, where username/password
     * is prompted.
     *
     * <p>Valid values: [Disabled, NeedClientAuth, WantClientAuth]
     *
     * @param zimbraMailSSLClientCertMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1190)
    public void setMailSSLClientCertModeAsString(String zimbraMailSSLClientCertMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertMode, zimbraMailSSLClientCertMode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable authentication via X.509 Client Certificate. Disabled: client
     * authentication is disabled. NeedClientAuth: client authentication is
     * required during SSL handshake on the SSL mutual authentication
     * port(see zimbraMailSSLClientCertPort). The SSL handshake will fail if
     * the client does not present a certificate to authenticate.
     * WantClientAuth: client authentication is requested during SSL
     * handshake on the SSL mutual authentication port(see
     * zimbraMailSSLClientCertPort). The SSL handshake will still proceed if
     * the client does not present a certificate to authenticate. In the case
     * when client does not send a certificate, user will be redirected to
     * the usual entry page of the requested webapp, where username/password
     * is prompted.
     *
     * <p>Valid values: [Disabled, NeedClientAuth, WantClientAuth]
     *
     * @param zimbraMailSSLClientCertMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1190)
    public Map<String,Object> setMailSSLClientCertModeAsString(String zimbraMailSSLClientCertMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertMode, zimbraMailSSLClientCertMode);
        return attrs;
    }

    /**
     * enable authentication via X.509 Client Certificate. Disabled: client
     * authentication is disabled. NeedClientAuth: client authentication is
     * required during SSL handshake on the SSL mutual authentication
     * port(see zimbraMailSSLClientCertPort). The SSL handshake will fail if
     * the client does not present a certificate to authenticate.
     * WantClientAuth: client authentication is requested during SSL
     * handshake on the SSL mutual authentication port(see
     * zimbraMailSSLClientCertPort). The SSL handshake will still proceed if
     * the client does not present a certificate to authenticate. In the case
     * when client does not send a certificate, user will be redirected to
     * the usual entry page of the requested webapp, where username/password
     * is prompted.
     *
     * <p>Valid values: [Disabled, NeedClientAuth, WantClientAuth]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1190)
    public void unsetMailSSLClientCertMode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertMode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable authentication via X.509 Client Certificate. Disabled: client
     * authentication is disabled. NeedClientAuth: client authentication is
     * required during SSL handshake on the SSL mutual authentication
     * port(see zimbraMailSSLClientCertPort). The SSL handshake will fail if
     * the client does not present a certificate to authenticate.
     * WantClientAuth: client authentication is requested during SSL
     * handshake on the SSL mutual authentication port(see
     * zimbraMailSSLClientCertPort). The SSL handshake will still proceed if
     * the client does not present a certificate to authenticate. In the case
     * when client does not send a certificate, user will be redirected to
     * the usual entry page of the requested webapp, where username/password
     * is prompted.
     *
     * <p>Valid values: [Disabled, NeedClientAuth, WantClientAuth]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1190)
    public Map<String,Object> unsetMailSSLClientCertMode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertMode, "");
        return attrs;
    }

    /**
     * enable OCSP support for two way authentication.
     *
     * @return zimbraMailSSLClientCertOCSPEnabled, or false if unset
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1395)
    public boolean isMailSSLClientCertOCSPEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMailSSLClientCertOCSPEnabled, false);
    }

    /**
     * enable OCSP support for two way authentication.
     *
     * @param zimbraMailSSLClientCertOCSPEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1395)
    public void setMailSSLClientCertOCSPEnabled(boolean zimbraMailSSLClientCertOCSPEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertOCSPEnabled, zimbraMailSSLClientCertOCSPEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable OCSP support for two way authentication.
     *
     * @param zimbraMailSSLClientCertOCSPEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1395)
    public Map<String,Object> setMailSSLClientCertOCSPEnabled(boolean zimbraMailSSLClientCertOCSPEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertOCSPEnabled, zimbraMailSSLClientCertOCSPEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * enable OCSP support for two way authentication.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1395)
    public void unsetMailSSLClientCertOCSPEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertOCSPEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable OCSP support for two way authentication.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1395)
    public Map<String,Object> unsetMailSSLClientCertOCSPEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertOCSPEnabled, "");
        return attrs;
    }

    /**
     * SSL port requesting client certificate for end-user UI
     *
     * <p>Use getMailSSLClientCertPortAsString to access value as a string.
     *
     * @see #getMailSSLClientCertPortAsString()
     *
     * @return zimbraMailSSLClientCertPort, or -1 if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1199)
    public int getMailSSLClientCertPort() {
        return getIntAttr(Provisioning.A_zimbraMailSSLClientCertPort, -1);
    }

    /**
     * SSL port requesting client certificate for end-user UI
     *
     * @return zimbraMailSSLClientCertPort, or null if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1199)
    public String getMailSSLClientCertPortAsString() {
        return getAttr(Provisioning.A_zimbraMailSSLClientCertPort, null);
    }

    /**
     * SSL port requesting client certificate for end-user UI
     *
     * @param zimbraMailSSLClientCertPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1199)
    public void setMailSSLClientCertPort(int zimbraMailSSLClientCertPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPort, Integer.toString(zimbraMailSSLClientCertPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port requesting client certificate for end-user UI
     *
     * @param zimbraMailSSLClientCertPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1199)
    public Map<String,Object> setMailSSLClientCertPort(int zimbraMailSSLClientCertPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPort, Integer.toString(zimbraMailSSLClientCertPort));
        return attrs;
    }

    /**
     * SSL port requesting client certificate for end-user UI
     *
     * @param zimbraMailSSLClientCertPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1199)
    public void setMailSSLClientCertPortAsString(String zimbraMailSSLClientCertPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPort, zimbraMailSSLClientCertPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port requesting client certificate for end-user UI
     *
     * @param zimbraMailSSLClientCertPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1199)
    public Map<String,Object> setMailSSLClientCertPortAsString(String zimbraMailSSLClientCertPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPort, zimbraMailSSLClientCertPort);
        return attrs;
    }

    /**
     * SSL port requesting client certificate for end-user UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1199)
    public void unsetMailSSLClientCertPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port requesting client certificate for end-user UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1199)
    public Map<String,Object> unsetMailSSLClientCertPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPort, "");
        return attrs;
    }

    /**
     * SSL port for end-user UI
     *
     * <p>Use getMailSSLPortAsString to access value as a string.
     *
     * @see #getMailSSLPortAsString()
     *
     * @return zimbraMailSSLPort, or -1 if unset
     */
    @ZAttr(id=166)
    public int getMailSSLPort() {
        return getIntAttr(Provisioning.A_zimbraMailSSLPort, -1);
    }

    /**
     * SSL port for end-user UI
     *
     * @return zimbraMailSSLPort, or null if unset
     */
    @ZAttr(id=166)
    public String getMailSSLPortAsString() {
        return getAttr(Provisioning.A_zimbraMailSSLPort, null);
    }

    /**
     * SSL port for end-user UI
     *
     * @param zimbraMailSSLPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=166)
    public void setMailSSLPort(int zimbraMailSSLPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLPort, Integer.toString(zimbraMailSSLPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port for end-user UI
     *
     * @param zimbraMailSSLPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=166)
    public Map<String,Object> setMailSSLPort(int zimbraMailSSLPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLPort, Integer.toString(zimbraMailSSLPort));
        return attrs;
    }

    /**
     * SSL port for end-user UI
     *
     * @param zimbraMailSSLPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=166)
    public void setMailSSLPortAsString(String zimbraMailSSLPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLPort, zimbraMailSSLPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port for end-user UI
     *
     * @param zimbraMailSSLPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=166)
    public Map<String,Object> setMailSSLPortAsString(String zimbraMailSSLPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLPort, zimbraMailSSLPort);
        return attrs;
    }

    /**
     * SSL port for end-user UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=166)
    public void unsetMailSSLPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port for end-user UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=166)
    public Map<String,Object> unsetMailSSLPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLPort, "");
        return attrs;
    }

    /**
     * SSL client certificate port for HTTP proxy
     *
     * <p>Use getMailSSLProxyClientCertPortAsString to access value as a string.
     *
     * @see #getMailSSLProxyClientCertPortAsString()
     *
     * @return zimbraMailSSLProxyClientCertPort, or -1 if unset
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1212)
    public int getMailSSLProxyClientCertPort() {
        return getIntAttr(Provisioning.A_zimbraMailSSLProxyClientCertPort, -1);
    }

    /**
     * SSL client certificate port for HTTP proxy
     *
     * @return zimbraMailSSLProxyClientCertPort, or null if unset
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1212)
    public String getMailSSLProxyClientCertPortAsString() {
        return getAttr(Provisioning.A_zimbraMailSSLProxyClientCertPort, null);
    }

    /**
     * SSL client certificate port for HTTP proxy
     *
     * @param zimbraMailSSLProxyClientCertPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1212)
    public void setMailSSLProxyClientCertPort(int zimbraMailSSLProxyClientCertPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLProxyClientCertPort, Integer.toString(zimbraMailSSLProxyClientCertPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL client certificate port for HTTP proxy
     *
     * @param zimbraMailSSLProxyClientCertPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1212)
    public Map<String,Object> setMailSSLProxyClientCertPort(int zimbraMailSSLProxyClientCertPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLProxyClientCertPort, Integer.toString(zimbraMailSSLProxyClientCertPort));
        return attrs;
    }

    /**
     * SSL client certificate port for HTTP proxy
     *
     * @param zimbraMailSSLProxyClientCertPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1212)
    public void setMailSSLProxyClientCertPortAsString(String zimbraMailSSLProxyClientCertPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLProxyClientCertPort, zimbraMailSSLProxyClientCertPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL client certificate port for HTTP proxy
     *
     * @param zimbraMailSSLProxyClientCertPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1212)
    public Map<String,Object> setMailSSLProxyClientCertPortAsString(String zimbraMailSSLProxyClientCertPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLProxyClientCertPort, zimbraMailSSLProxyClientCertPort);
        return attrs;
    }

    /**
     * SSL client certificate port for HTTP proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1212)
    public void unsetMailSSLProxyClientCertPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLProxyClientCertPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL client certificate port for HTTP proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1212)
    public Map<String,Object> unsetMailSSLProxyClientCertPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLProxyClientCertPort, "");
        return attrs;
    }

    /**
     * In our web app, AJAX and standard html client, we have support for
     * adding the HTTP client IP address as X-Originating-IP in an outbound
     * message. We also use the HTTP client IP address in our logging. In the
     * case of standard client making connections to the SOAP layer, the JSP
     * layer tells the SOAP layer in a http header what the remote HTTP
     * client address is. In the case where nginx or some other proxy layer
     * is fronting our webapps, the proxy tells the SOAP/JSP layers in a http
     * header what the real HTTP client s address is. Our SOAP/JSP layers
     * will trust the client/proxy only if the IP address of the client/proxy
     * is one of the IPs listed in this attribute.
     *
     * @return zimbraMailTrustedIP, or empty array if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1025)
    public String[] getMailTrustedIP() {
        return getMultiAttr(Provisioning.A_zimbraMailTrustedIP);
    }

    /**
     * In our web app, AJAX and standard html client, we have support for
     * adding the HTTP client IP address as X-Originating-IP in an outbound
     * message. We also use the HTTP client IP address in our logging. In the
     * case of standard client making connections to the SOAP layer, the JSP
     * layer tells the SOAP layer in a http header what the remote HTTP
     * client address is. In the case where nginx or some other proxy layer
     * is fronting our webapps, the proxy tells the SOAP/JSP layers in a http
     * header what the real HTTP client s address is. Our SOAP/JSP layers
     * will trust the client/proxy only if the IP address of the client/proxy
     * is one of the IPs listed in this attribute.
     *
     * @param zimbraMailTrustedIP new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1025)
    public void setMailTrustedIP(String[] zimbraMailTrustedIP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTrustedIP, zimbraMailTrustedIP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * In our web app, AJAX and standard html client, we have support for
     * adding the HTTP client IP address as X-Originating-IP in an outbound
     * message. We also use the HTTP client IP address in our logging. In the
     * case of standard client making connections to the SOAP layer, the JSP
     * layer tells the SOAP layer in a http header what the remote HTTP
     * client address is. In the case where nginx or some other proxy layer
     * is fronting our webapps, the proxy tells the SOAP/JSP layers in a http
     * header what the real HTTP client s address is. Our SOAP/JSP layers
     * will trust the client/proxy only if the IP address of the client/proxy
     * is one of the IPs listed in this attribute.
     *
     * @param zimbraMailTrustedIP new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1025)
    public Map<String,Object> setMailTrustedIP(String[] zimbraMailTrustedIP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTrustedIP, zimbraMailTrustedIP);
        return attrs;
    }

    /**
     * In our web app, AJAX and standard html client, we have support for
     * adding the HTTP client IP address as X-Originating-IP in an outbound
     * message. We also use the HTTP client IP address in our logging. In the
     * case of standard client making connections to the SOAP layer, the JSP
     * layer tells the SOAP layer in a http header what the remote HTTP
     * client address is. In the case where nginx or some other proxy layer
     * is fronting our webapps, the proxy tells the SOAP/JSP layers in a http
     * header what the real HTTP client s address is. Our SOAP/JSP layers
     * will trust the client/proxy only if the IP address of the client/proxy
     * is one of the IPs listed in this attribute.
     *
     * @param zimbraMailTrustedIP new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1025)
    public void addMailTrustedIP(String zimbraMailTrustedIP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailTrustedIP, zimbraMailTrustedIP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * In our web app, AJAX and standard html client, we have support for
     * adding the HTTP client IP address as X-Originating-IP in an outbound
     * message. We also use the HTTP client IP address in our logging. In the
     * case of standard client making connections to the SOAP layer, the JSP
     * layer tells the SOAP layer in a http header what the remote HTTP
     * client address is. In the case where nginx or some other proxy layer
     * is fronting our webapps, the proxy tells the SOAP/JSP layers in a http
     * header what the real HTTP client s address is. Our SOAP/JSP layers
     * will trust the client/proxy only if the IP address of the client/proxy
     * is one of the IPs listed in this attribute.
     *
     * @param zimbraMailTrustedIP new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1025)
    public Map<String,Object> addMailTrustedIP(String zimbraMailTrustedIP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailTrustedIP, zimbraMailTrustedIP);
        return attrs;
    }

    /**
     * In our web app, AJAX and standard html client, we have support for
     * adding the HTTP client IP address as X-Originating-IP in an outbound
     * message. We also use the HTTP client IP address in our logging. In the
     * case of standard client making connections to the SOAP layer, the JSP
     * layer tells the SOAP layer in a http header what the remote HTTP
     * client address is. In the case where nginx or some other proxy layer
     * is fronting our webapps, the proxy tells the SOAP/JSP layers in a http
     * header what the real HTTP client s address is. Our SOAP/JSP layers
     * will trust the client/proxy only if the IP address of the client/proxy
     * is one of the IPs listed in this attribute.
     *
     * @param zimbraMailTrustedIP existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1025)
    public void removeMailTrustedIP(String zimbraMailTrustedIP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailTrustedIP, zimbraMailTrustedIP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * In our web app, AJAX and standard html client, we have support for
     * adding the HTTP client IP address as X-Originating-IP in an outbound
     * message. We also use the HTTP client IP address in our logging. In the
     * case of standard client making connections to the SOAP layer, the JSP
     * layer tells the SOAP layer in a http header what the remote HTTP
     * client address is. In the case where nginx or some other proxy layer
     * is fronting our webapps, the proxy tells the SOAP/JSP layers in a http
     * header what the real HTTP client s address is. Our SOAP/JSP layers
     * will trust the client/proxy only if the IP address of the client/proxy
     * is one of the IPs listed in this attribute.
     *
     * @param zimbraMailTrustedIP existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1025)
    public Map<String,Object> removeMailTrustedIP(String zimbraMailTrustedIP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailTrustedIP, zimbraMailTrustedIP);
        return attrs;
    }

    /**
     * In our web app, AJAX and standard html client, we have support for
     * adding the HTTP client IP address as X-Originating-IP in an outbound
     * message. We also use the HTTP client IP address in our logging. In the
     * case of standard client making connections to the SOAP layer, the JSP
     * layer tells the SOAP layer in a http header what the remote HTTP
     * client address is. In the case where nginx or some other proxy layer
     * is fronting our webapps, the proxy tells the SOAP/JSP layers in a http
     * header what the real HTTP client s address is. Our SOAP/JSP layers
     * will trust the client/proxy only if the IP address of the client/proxy
     * is one of the IPs listed in this attribute.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1025)
    public void unsetMailTrustedIP() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTrustedIP, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * In our web app, AJAX and standard html client, we have support for
     * adding the HTTP client IP address as X-Originating-IP in an outbound
     * message. We also use the HTTP client IP address in our logging. In the
     * case of standard client making connections to the SOAP layer, the JSP
     * layer tells the SOAP layer in a http header what the remote HTTP
     * client address is. In the case where nginx or some other proxy layer
     * is fronting our webapps, the proxy tells the SOAP/JSP layers in a http
     * header what the real HTTP client s address is. Our SOAP/JSP layers
     * will trust the client/proxy only if the IP address of the client/proxy
     * is one of the IPs listed in this attribute.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1025)
    public Map<String,Object> unsetMailTrustedIP(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTrustedIP, "");
        return attrs;
    }

    /**
     * URL prefix for where the zimbra app resides on this server
     *
     * @return zimbraMailURL, or null if unset
     */
    @ZAttr(id=340)
    public String getMailURL() {
        return getAttr(Provisioning.A_zimbraMailURL, null);
    }

    /**
     * URL prefix for where the zimbra app resides on this server
     *
     * @param zimbraMailURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=340)
    public void setMailURL(String zimbraMailURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailURL, zimbraMailURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL prefix for where the zimbra app resides on this server
     *
     * @param zimbraMailURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=340)
    public Map<String,Object> setMailURL(String zimbraMailURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailURL, zimbraMailURL);
        return attrs;
    }

    /**
     * URL prefix for where the zimbra app resides on this server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=340)
    public void unsetMailURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL prefix for where the zimbra app resides on this server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=340)
    public Map<String,Object> unsetMailURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailURL, "");
        return attrs;
    }

    /**
     * Used to control whether Java NIO direct buffers are used. Value is
     * propagated to Jetty configuration. In the future, other NIO pieces
     * (IMAP/POP/LMTP) will also honor this.
     *
     * @return zimbraMailUseDirectBuffers, or false if unset
     *
     * @since ZCS 5.0.22
     */
    @ZAttr(id=1002)
    public boolean isMailUseDirectBuffers() {
        return getBooleanAttr(Provisioning.A_zimbraMailUseDirectBuffers, false);
    }

    /**
     * Used to control whether Java NIO direct buffers are used. Value is
     * propagated to Jetty configuration. In the future, other NIO pieces
     * (IMAP/POP/LMTP) will also honor this.
     *
     * @param zimbraMailUseDirectBuffers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.22
     */
    @ZAttr(id=1002)
    public void setMailUseDirectBuffers(boolean zimbraMailUseDirectBuffers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailUseDirectBuffers, zimbraMailUseDirectBuffers ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Used to control whether Java NIO direct buffers are used. Value is
     * propagated to Jetty configuration. In the future, other NIO pieces
     * (IMAP/POP/LMTP) will also honor this.
     *
     * @param zimbraMailUseDirectBuffers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.22
     */
    @ZAttr(id=1002)
    public Map<String,Object> setMailUseDirectBuffers(boolean zimbraMailUseDirectBuffers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailUseDirectBuffers, zimbraMailUseDirectBuffers ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Used to control whether Java NIO direct buffers are used. Value is
     * propagated to Jetty configuration. In the future, other NIO pieces
     * (IMAP/POP/LMTP) will also honor this.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.22
     */
    @ZAttr(id=1002)
    public void unsetMailUseDirectBuffers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailUseDirectBuffers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Used to control whether Java NIO direct buffers are used. Value is
     * propagated to Jetty configuration. In the future, other NIO pieces
     * (IMAP/POP/LMTP) will also honor this.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.22
     */
    @ZAttr(id=1002)
    public Map<String,Object> unsetMailUseDirectBuffers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailUseDirectBuffers, "");
        return attrs;
    }

    /**
     * Duration after which active waitset threads, that have not been
     * updated, are timed out.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getMailboxActiveWaitsetTimeOutAsString to access value as a string.
     *
     * @see #getMailboxActiveWaitsetTimeOutAsString()
     *
     * @return zimbraMailboxActiveWaitsetTimeOut in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2038)
    public long getMailboxActiveWaitsetTimeOut() {
        return getTimeInterval(Provisioning.A_zimbraMailboxActiveWaitsetTimeOut, -1L);
    }

    /**
     * Duration after which active waitset threads, that have not been
     * updated, are timed out.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraMailboxActiveWaitsetTimeOut, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2038)
    public String getMailboxActiveWaitsetTimeOutAsString() {
        return getAttr(Provisioning.A_zimbraMailboxActiveWaitsetTimeOut, null);
    }

    /**
     * Duration after which active waitset threads, that have not been
     * updated, are timed out.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailboxActiveWaitsetTimeOut new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2038)
    public void setMailboxActiveWaitsetTimeOut(String zimbraMailboxActiveWaitsetTimeOut) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxActiveWaitsetTimeOut, zimbraMailboxActiveWaitsetTimeOut);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Duration after which active waitset threads, that have not been
     * updated, are timed out.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailboxActiveWaitsetTimeOut new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2038)
    public Map<String,Object> setMailboxActiveWaitsetTimeOut(String zimbraMailboxActiveWaitsetTimeOut, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxActiveWaitsetTimeOut, zimbraMailboxActiveWaitsetTimeOut);
        return attrs;
    }

    /**
     * Duration after which active waitset threads, that have not been
     * updated, are timed out.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2038)
    public void unsetMailboxActiveWaitsetTimeOut() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxActiveWaitsetTimeOut, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Duration after which active waitset threads, that have not been
     * updated, are timed out.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2038)
    public Map<String,Object> unsetMailboxActiveWaitsetTimeOut(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxActiveWaitsetTimeOut, "");
        return attrs;
    }

    /**
     * Disable timeout for archive formatter.Introduced in bug 56458. This is
     * a workaround for an issue in Jetty 6.1.22.zc6m when we upgrade we
     * should re-evaluate/remove these settings and the code that uses them.
     *
     * @return zimbraMailboxArchiveFormatterDisableTimeout, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1991)
    public boolean isMailboxArchiveFormatterDisableTimeout() {
        return getBooleanAttr(Provisioning.A_zimbraMailboxArchiveFormatterDisableTimeout, false);
    }

    /**
     * Disable timeout for archive formatter.Introduced in bug 56458. This is
     * a workaround for an issue in Jetty 6.1.22.zc6m when we upgrade we
     * should re-evaluate/remove these settings and the code that uses them.
     *
     * @param zimbraMailboxArchiveFormatterDisableTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1991)
    public void setMailboxArchiveFormatterDisableTimeout(boolean zimbraMailboxArchiveFormatterDisableTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxArchiveFormatterDisableTimeout, zimbraMailboxArchiveFormatterDisableTimeout ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Disable timeout for archive formatter.Introduced in bug 56458. This is
     * a workaround for an issue in Jetty 6.1.22.zc6m when we upgrade we
     * should re-evaluate/remove these settings and the code that uses them.
     *
     * @param zimbraMailboxArchiveFormatterDisableTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1991)
    public Map<String,Object> setMailboxArchiveFormatterDisableTimeout(boolean zimbraMailboxArchiveFormatterDisableTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxArchiveFormatterDisableTimeout, zimbraMailboxArchiveFormatterDisableTimeout ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Disable timeout for archive formatter.Introduced in bug 56458. This is
     * a workaround for an issue in Jetty 6.1.22.zc6m when we upgrade we
     * should re-evaluate/remove these settings and the code that uses them.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1991)
    public void unsetMailboxArchiveFormatterDisableTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxArchiveFormatterDisableTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Disable timeout for archive formatter.Introduced in bug 56458. This is
     * a workaround for an issue in Jetty 6.1.22.zc6m when we upgrade we
     * should re-evaluate/remove these settings and the code that uses them.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1991)
    public Map<String,Object> unsetMailboxArchiveFormatterDisableTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxArchiveFormatterDisableTimeout, "");
        return attrs;
    }

    /**
     * Archive formatter search chunk size in bytes
     *
     * @return zimbraMailboxArchiveFormatterSearchChunkSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1993)
    public int getMailboxArchiveFormatterSearchChunkSize() {
        return getIntAttr(Provisioning.A_zimbraMailboxArchiveFormatterSearchChunkSize, -1);
    }

    /**
     * Archive formatter search chunk size in bytes
     *
     * @param zimbraMailboxArchiveFormatterSearchChunkSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1993)
    public void setMailboxArchiveFormatterSearchChunkSize(int zimbraMailboxArchiveFormatterSearchChunkSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxArchiveFormatterSearchChunkSize, Integer.toString(zimbraMailboxArchiveFormatterSearchChunkSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Archive formatter search chunk size in bytes
     *
     * @param zimbraMailboxArchiveFormatterSearchChunkSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1993)
    public Map<String,Object> setMailboxArchiveFormatterSearchChunkSize(int zimbraMailboxArchiveFormatterSearchChunkSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxArchiveFormatterSearchChunkSize, Integer.toString(zimbraMailboxArchiveFormatterSearchChunkSize));
        return attrs;
    }

    /**
     * Archive formatter search chunk size in bytes
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1993)
    public void unsetMailboxArchiveFormatterSearchChunkSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxArchiveFormatterSearchChunkSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Archive formatter search chunk size in bytes
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1993)
    public Map<String,Object> unsetMailboxArchiveFormatterSearchChunkSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxArchiveFormatterSearchChunkSize, "");
        return attrs;
    }

    /**
     * The frequency, in number of changes, at which a mailbox&#039;s
     * ZIMBRA.MAILBOX.CHANGE_CHECKPOINT highwater change value is written.
     *
     * @return zimbraMailboxChangeCheckpointFrequency, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1851)
    public int getMailboxChangeCheckpointFrequency() {
        return getIntAttr(Provisioning.A_zimbraMailboxChangeCheckpointFrequency, -1);
    }

    /**
     * The frequency, in number of changes, at which a mailbox&#039;s
     * ZIMBRA.MAILBOX.CHANGE_CHECKPOINT highwater change value is written.
     *
     * @param zimbraMailboxChangeCheckpointFrequency new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1851)
    public void setMailboxChangeCheckpointFrequency(int zimbraMailboxChangeCheckpointFrequency) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxChangeCheckpointFrequency, Integer.toString(zimbraMailboxChangeCheckpointFrequency));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The frequency, in number of changes, at which a mailbox&#039;s
     * ZIMBRA.MAILBOX.CHANGE_CHECKPOINT highwater change value is written.
     *
     * @param zimbraMailboxChangeCheckpointFrequency new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1851)
    public Map<String,Object> setMailboxChangeCheckpointFrequency(int zimbraMailboxChangeCheckpointFrequency, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxChangeCheckpointFrequency, Integer.toString(zimbraMailboxChangeCheckpointFrequency));
        return attrs;
    }

    /**
     * The frequency, in number of changes, at which a mailbox&#039;s
     * ZIMBRA.MAILBOX.CHANGE_CHECKPOINT highwater change value is written.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1851)
    public void unsetMailboxChangeCheckpointFrequency() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxChangeCheckpointFrequency, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The frequency, in number of changes, at which a mailbox&#039;s
     * ZIMBRA.MAILBOX.CHANGE_CHECKPOINT highwater change value is written.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1851)
    public Map<String,Object> unsetMailboxChangeCheckpointFrequency(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxChangeCheckpointFrequency, "");
        return attrs;
    }

    /**
     * Disable timeout for csv formatter. Introduced in bug 56458. This is a
     * workaround for an issue in Jetty 6.1.22.zc6m when we upgrade we should
     * re-evaluate/remove these settings and the code that uses them.
     *
     * @return zimbraMailboxCsvFormatterDisableTimeout, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1992)
    public boolean isMailboxCsvFormatterDisableTimeout() {
        return getBooleanAttr(Provisioning.A_zimbraMailboxCsvFormatterDisableTimeout, false);
    }

    /**
     * Disable timeout for csv formatter. Introduced in bug 56458. This is a
     * workaround for an issue in Jetty 6.1.22.zc6m when we upgrade we should
     * re-evaluate/remove these settings and the code that uses them.
     *
     * @param zimbraMailboxCsvFormatterDisableTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1992)
    public void setMailboxCsvFormatterDisableTimeout(boolean zimbraMailboxCsvFormatterDisableTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxCsvFormatterDisableTimeout, zimbraMailboxCsvFormatterDisableTimeout ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Disable timeout for csv formatter. Introduced in bug 56458. This is a
     * workaround for an issue in Jetty 6.1.22.zc6m when we upgrade we should
     * re-evaluate/remove these settings and the code that uses them.
     *
     * @param zimbraMailboxCsvFormatterDisableTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1992)
    public Map<String,Object> setMailboxCsvFormatterDisableTimeout(boolean zimbraMailboxCsvFormatterDisableTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxCsvFormatterDisableTimeout, zimbraMailboxCsvFormatterDisableTimeout ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Disable timeout for csv formatter. Introduced in bug 56458. This is a
     * workaround for an issue in Jetty 6.1.22.zc6m when we upgrade we should
     * re-evaluate/remove these settings and the code that uses them.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1992)
    public void unsetMailboxCsvFormatterDisableTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxCsvFormatterDisableTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Disable timeout for csv formatter. Introduced in bug 56458. This is a
     * workaround for an issue in Jetty 6.1.22.zc6m when we upgrade we should
     * re-evaluate/remove these settings and the code that uses them.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1992)
    public Map<String,Object> unsetMailboxCsvFormatterDisableTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxCsvFormatterDisableTimeout, "");
        return attrs;
    }

    /**
     * The max idle time for an HTTP DAV Method in milliseconds. Timeout 0
     * implies an infinite timeout If not setting to 0, suggest at least
     * 600000, 10 minutes. Introduced in bug 79865. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getMailboxDAVConnectionMaxIdleTimeAsString to access value as a string.
     *
     * @see #getMailboxDAVConnectionMaxIdleTimeAsString()
     *
     * @return zimbraMailboxDAVConnectionMaxIdleTime in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1896)
    public long getMailboxDAVConnectionMaxIdleTime() {
        return getTimeInterval(Provisioning.A_zimbraMailboxDAVConnectionMaxIdleTime, -1L);
    }

    /**
     * The max idle time for an HTTP DAV Method in milliseconds. Timeout 0
     * implies an infinite timeout If not setting to 0, suggest at least
     * 600000, 10 minutes. Introduced in bug 79865. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraMailboxDAVConnectionMaxIdleTime, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1896)
    public String getMailboxDAVConnectionMaxIdleTimeAsString() {
        return getAttr(Provisioning.A_zimbraMailboxDAVConnectionMaxIdleTime, null);
    }

    /**
     * The max idle time for an HTTP DAV Method in milliseconds. Timeout 0
     * implies an infinite timeout If not setting to 0, suggest at least
     * 600000, 10 minutes. Introduced in bug 79865. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraMailboxDAVConnectionMaxIdleTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1896)
    public void setMailboxDAVConnectionMaxIdleTime(String zimbraMailboxDAVConnectionMaxIdleTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDAVConnectionMaxIdleTime, zimbraMailboxDAVConnectionMaxIdleTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The max idle time for an HTTP DAV Method in milliseconds. Timeout 0
     * implies an infinite timeout If not setting to 0, suggest at least
     * 600000, 10 minutes. Introduced in bug 79865. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraMailboxDAVConnectionMaxIdleTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1896)
    public Map<String,Object> setMailboxDAVConnectionMaxIdleTime(String zimbraMailboxDAVConnectionMaxIdleTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDAVConnectionMaxIdleTime, zimbraMailboxDAVConnectionMaxIdleTime);
        return attrs;
    }

    /**
     * The max idle time for an HTTP DAV Method in milliseconds. Timeout 0
     * implies an infinite timeout If not setting to 0, suggest at least
     * 600000, 10 minutes. Introduced in bug 79865. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1896)
    public void unsetMailboxDAVConnectionMaxIdleTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDAVConnectionMaxIdleTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The max idle time for an HTTP DAV Method in milliseconds. Timeout 0
     * implies an infinite timeout If not setting to 0, suggest at least
     * 600000, 10 minutes. Introduced in bug 79865. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1896)
    public Map<String,Object> unsetMailboxDAVConnectionMaxIdleTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDAVConnectionMaxIdleTime, "");
        return attrs;
    }

    /**
     * Database URL for obtaining connection from mailstore using JDBC
     * connectors. Example : jdbc:mysql://[ip:port]/ OR
     * jdbc:mysql://[ip1:port],[ip2:port],[ip3:port]/
     *
     * @return zimbraMailboxDbConnectionUrl, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1942)
    public String getMailboxDbConnectionUrl() {
        return getAttr(Provisioning.A_zimbraMailboxDbConnectionUrl, null);
    }

    /**
     * Database URL for obtaining connection from mailstore using JDBC
     * connectors. Example : jdbc:mysql://[ip:port]/ OR
     * jdbc:mysql://[ip1:port],[ip2:port],[ip3:port]/
     *
     * @param zimbraMailboxDbConnectionUrl new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1942)
    public void setMailboxDbConnectionUrl(String zimbraMailboxDbConnectionUrl) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDbConnectionUrl, zimbraMailboxDbConnectionUrl);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Database URL for obtaining connection from mailstore using JDBC
     * connectors. Example : jdbc:mysql://[ip:port]/ OR
     * jdbc:mysql://[ip1:port],[ip2:port],[ip3:port]/
     *
     * @param zimbraMailboxDbConnectionUrl new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1942)
    public Map<String,Object> setMailboxDbConnectionUrl(String zimbraMailboxDbConnectionUrl, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDbConnectionUrl, zimbraMailboxDbConnectionUrl);
        return attrs;
    }

    /**
     * Database URL for obtaining connection from mailstore using JDBC
     * connectors. Example : jdbc:mysql://[ip:port]/ OR
     * jdbc:mysql://[ip1:port],[ip2:port],[ip3:port]/
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1942)
    public void unsetMailboxDbConnectionUrl() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDbConnectionUrl, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Database URL for obtaining connection from mailstore using JDBC
     * connectors. Example : jdbc:mysql://[ip:port]/ OR
     * jdbc:mysql://[ip1:port],[ip2:port],[ip3:port]/
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1942)
    public Map<String,Object> unsetMailboxDbConnectionUrl(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDbConnectionUrl, "");
        return attrs;
    }

    /**
     * Sleep time in milliseconds to give other threads a chance to use the
     * mailbox between deletion batches.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getMailboxDeleteFolderThreadSleepAsString to access value as a string.
     *
     * @see #getMailboxDeleteFolderThreadSleepAsString()
     *
     * @return zimbraMailboxDeleteFolderThreadSleep in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1795)
    public long getMailboxDeleteFolderThreadSleep() {
        return getTimeInterval(Provisioning.A_zimbraMailboxDeleteFolderThreadSleep, -1L);
    }

    /**
     * Sleep time in milliseconds to give other threads a chance to use the
     * mailbox between deletion batches.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraMailboxDeleteFolderThreadSleep, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1795)
    public String getMailboxDeleteFolderThreadSleepAsString() {
        return getAttr(Provisioning.A_zimbraMailboxDeleteFolderThreadSleep, null);
    }

    /**
     * Sleep time in milliseconds to give other threads a chance to use the
     * mailbox between deletion batches.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailboxDeleteFolderThreadSleep new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1795)
    public void setMailboxDeleteFolderThreadSleep(String zimbraMailboxDeleteFolderThreadSleep) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDeleteFolderThreadSleep, zimbraMailboxDeleteFolderThreadSleep);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sleep time in milliseconds to give other threads a chance to use the
     * mailbox between deletion batches.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailboxDeleteFolderThreadSleep new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1795)
    public Map<String,Object> setMailboxDeleteFolderThreadSleep(String zimbraMailboxDeleteFolderThreadSleep, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDeleteFolderThreadSleep, zimbraMailboxDeleteFolderThreadSleep);
        return attrs;
    }

    /**
     * Sleep time in milliseconds to give other threads a chance to use the
     * mailbox between deletion batches.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1795)
    public void unsetMailboxDeleteFolderThreadSleep() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDeleteFolderThreadSleep, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sleep time in milliseconds to give other threads a chance to use the
     * mailbox between deletion batches.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1795)
    public Map<String,Object> unsetMailboxDeleteFolderThreadSleep(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDeleteFolderThreadSleep, "");
        return attrs;
    }

    /**
     * Flag to enable disk cache servlet flush
     *
     * @return zimbraMailboxDiskCacheFlush, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1842)
    public boolean isMailboxDiskCacheFlush() {
        return getBooleanAttr(Provisioning.A_zimbraMailboxDiskCacheFlush, false);
    }

    /**
     * Flag to enable disk cache servlet flush
     *
     * @param zimbraMailboxDiskCacheFlush new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1842)
    public void setMailboxDiskCacheFlush(boolean zimbraMailboxDiskCacheFlush) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDiskCacheFlush, zimbraMailboxDiskCacheFlush ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable disk cache servlet flush
     *
     * @param zimbraMailboxDiskCacheFlush new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1842)
    public Map<String,Object> setMailboxDiskCacheFlush(boolean zimbraMailboxDiskCacheFlush, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDiskCacheFlush, zimbraMailboxDiskCacheFlush ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to enable disk cache servlet flush
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1842)
    public void unsetMailboxDiskCacheFlush() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDiskCacheFlush, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable disk cache servlet flush
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1842)
    public Map<String,Object> unsetMailboxDiskCacheFlush(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDiskCacheFlush, "");
        return attrs;
    }

    /**
     * Size of the cache used by Disk Cache Servlet
     *
     * @return zimbraMailboxDiskCacheSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1843)
    public int getMailboxDiskCacheSize() {
        return getIntAttr(Provisioning.A_zimbraMailboxDiskCacheSize, -1);
    }

    /**
     * Size of the cache used by Disk Cache Servlet
     *
     * @param zimbraMailboxDiskCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1843)
    public void setMailboxDiskCacheSize(int zimbraMailboxDiskCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDiskCacheSize, Integer.toString(zimbraMailboxDiskCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Size of the cache used by Disk Cache Servlet
     *
     * @param zimbraMailboxDiskCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1843)
    public Map<String,Object> setMailboxDiskCacheSize(int zimbraMailboxDiskCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDiskCacheSize, Integer.toString(zimbraMailboxDiskCacheSize));
        return attrs;
    }

    /**
     * Size of the cache used by Disk Cache Servlet
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1843)
    public void unsetMailboxDiskCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDiskCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Size of the cache used by Disk Cache Servlet
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1843)
    public Map<String,Object> unsetMailboxDiskCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxDiskCacheSize, "");
        return attrs;
    }

    /**
     * External mailbox listeners. Redis and AMQP URI&#039;s are supported.
     * Use &quot;redis:default&quot; to publish events to the default Redis
     * server(s) that are specified by zimbraRedisUrl.
     *
     * @return zimbraMailboxListenerUrl, or empty array if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1963)
    public String[] getMailboxListenerUrl() {
        return getMultiAttr(Provisioning.A_zimbraMailboxListenerUrl);
    }

    /**
     * External mailbox listeners. Redis and AMQP URI&#039;s are supported.
     * Use &quot;redis:default&quot; to publish events to the default Redis
     * server(s) that are specified by zimbraRedisUrl.
     *
     * @param zimbraMailboxListenerUrl new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1963)
    public void setMailboxListenerUrl(String[] zimbraMailboxListenerUrl) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxListenerUrl, zimbraMailboxListenerUrl);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * External mailbox listeners. Redis and AMQP URI&#039;s are supported.
     * Use &quot;redis:default&quot; to publish events to the default Redis
     * server(s) that are specified by zimbraRedisUrl.
     *
     * @param zimbraMailboxListenerUrl new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1963)
    public Map<String,Object> setMailboxListenerUrl(String[] zimbraMailboxListenerUrl, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxListenerUrl, zimbraMailboxListenerUrl);
        return attrs;
    }

    /**
     * External mailbox listeners. Redis and AMQP URI&#039;s are supported.
     * Use &quot;redis:default&quot; to publish events to the default Redis
     * server(s) that are specified by zimbraRedisUrl.
     *
     * @param zimbraMailboxListenerUrl new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1963)
    public void addMailboxListenerUrl(String zimbraMailboxListenerUrl) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailboxListenerUrl, zimbraMailboxListenerUrl);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * External mailbox listeners. Redis and AMQP URI&#039;s are supported.
     * Use &quot;redis:default&quot; to publish events to the default Redis
     * server(s) that are specified by zimbraRedisUrl.
     *
     * @param zimbraMailboxListenerUrl new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1963)
    public Map<String,Object> addMailboxListenerUrl(String zimbraMailboxListenerUrl, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailboxListenerUrl, zimbraMailboxListenerUrl);
        return attrs;
    }

    /**
     * External mailbox listeners. Redis and AMQP URI&#039;s are supported.
     * Use &quot;redis:default&quot; to publish events to the default Redis
     * server(s) that are specified by zimbraRedisUrl.
     *
     * @param zimbraMailboxListenerUrl existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1963)
    public void removeMailboxListenerUrl(String zimbraMailboxListenerUrl) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailboxListenerUrl, zimbraMailboxListenerUrl);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * External mailbox listeners. Redis and AMQP URI&#039;s are supported.
     * Use &quot;redis:default&quot; to publish events to the default Redis
     * server(s) that are specified by zimbraRedisUrl.
     *
     * @param zimbraMailboxListenerUrl existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1963)
    public Map<String,Object> removeMailboxListenerUrl(String zimbraMailboxListenerUrl, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailboxListenerUrl, zimbraMailboxListenerUrl);
        return attrs;
    }

    /**
     * External mailbox listeners. Redis and AMQP URI&#039;s are supported.
     * Use &quot;redis:default&quot; to publish events to the default Redis
     * server(s) that are specified by zimbraRedisUrl.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1963)
    public void unsetMailboxListenerUrl() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxListenerUrl, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * External mailbox listeners. Redis and AMQP URI&#039;s are supported.
     * Use &quot;redis:default&quot; to publish events to the default Redis
     * server(s) that are specified by zimbraRedisUrl.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1963)
    public Map<String,Object> unsetMailboxListenerUrl(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxListenerUrl, "");
        return attrs;
    }

    /**
     * Maximum allowed waiting threads on a mailbox lock
     *
     * @return zimbraMailboxLockMaxWaitingThreads, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1732)
    public int getMailboxLockMaxWaitingThreads() {
        return getIntAttr(Provisioning.A_zimbraMailboxLockMaxWaitingThreads, -1);
    }

    /**
     * Maximum allowed waiting threads on a mailbox lock
     *
     * @param zimbraMailboxLockMaxWaitingThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1732)
    public void setMailboxLockMaxWaitingThreads(int zimbraMailboxLockMaxWaitingThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxLockMaxWaitingThreads, Integer.toString(zimbraMailboxLockMaxWaitingThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum allowed waiting threads on a mailbox lock
     *
     * @param zimbraMailboxLockMaxWaitingThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1732)
    public Map<String,Object> setMailboxLockMaxWaitingThreads(int zimbraMailboxLockMaxWaitingThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxLockMaxWaitingThreads, Integer.toString(zimbraMailboxLockMaxWaitingThreads));
        return attrs;
    }

    /**
     * Maximum allowed waiting threads on a mailbox lock
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1732)
    public void unsetMailboxLockMaxWaitingThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxLockMaxWaitingThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum allowed waiting threads on a mailbox lock
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1732)
    public Map<String,Object> unsetMailboxLockMaxWaitingThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxLockMaxWaitingThreads, "");
        return attrs;
    }

    /**
     * The maximum size of a mailboxs internal LRU item cache when there are
     * sessions active.
     *
     * @return zimbraMailboxMailItemActiveCache, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1850)
    public int getMailboxMailItemActiveCache() {
        return getIntAttr(Provisioning.A_zimbraMailboxMailItemActiveCache, -1);
    }

    /**
     * The maximum size of a mailboxs internal LRU item cache when there are
     * sessions active.
     *
     * @param zimbraMailboxMailItemActiveCache new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1850)
    public void setMailboxMailItemActiveCache(int zimbraMailboxMailItemActiveCache) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMailItemActiveCache, Integer.toString(zimbraMailboxMailItemActiveCache));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum size of a mailboxs internal LRU item cache when there are
     * sessions active.
     *
     * @param zimbraMailboxMailItemActiveCache new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1850)
    public Map<String,Object> setMailboxMailItemActiveCache(int zimbraMailboxMailItemActiveCache, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMailItemActiveCache, Integer.toString(zimbraMailboxMailItemActiveCache));
        return attrs;
    }

    /**
     * The maximum size of a mailboxs internal LRU item cache when there are
     * sessions active.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1850)
    public void unsetMailboxMailItemActiveCache() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMailItemActiveCache, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum size of a mailboxs internal LRU item cache when there are
     * sessions active.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1850)
    public Map<String,Object> unsetMailboxMailItemActiveCache(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMailItemActiveCache, "");
        return attrs;
    }

    /**
     * The maximum size of a mailbox&#039;s internal LRU item cache when it
     * has no active sessions.
     *
     * @return zimbraMailboxMailItemInactiveCache, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1855)
    public int getMailboxMailItemInactiveCache() {
        return getIntAttr(Provisioning.A_zimbraMailboxMailItemInactiveCache, -1);
    }

    /**
     * The maximum size of a mailbox&#039;s internal LRU item cache when it
     * has no active sessions.
     *
     * @param zimbraMailboxMailItemInactiveCache new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1855)
    public void setMailboxMailItemInactiveCache(int zimbraMailboxMailItemInactiveCache) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMailItemInactiveCache, Integer.toString(zimbraMailboxMailItemInactiveCache));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum size of a mailbox&#039;s internal LRU item cache when it
     * has no active sessions.
     *
     * @param zimbraMailboxMailItemInactiveCache new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1855)
    public Map<String,Object> setMailboxMailItemInactiveCache(int zimbraMailboxMailItemInactiveCache, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMailItemInactiveCache, Integer.toString(zimbraMailboxMailItemInactiveCache));
        return attrs;
    }

    /**
     * The maximum size of a mailbox&#039;s internal LRU item cache when it
     * has no active sessions.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1855)
    public void unsetMailboxMailItemInactiveCache() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMailItemInactiveCache, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum size of a mailbox&#039;s internal LRU item cache when it
     * has no active sessions.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1855)
    public Map<String,Object> unsetMailboxMailItemInactiveCache(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMailItemInactiveCache, "");
        return attrs;
    }

    /**
     * The maximum number of mailboxes that will be pinned in memory before
     * the mailbox manager starts allowing them to be purged via
     * SoftReference garbage collection.
     *
     * @return zimbraMailboxManagerHardrefCache, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1856)
    public int getMailboxManagerHardrefCache() {
        return getIntAttr(Provisioning.A_zimbraMailboxManagerHardrefCache, -1);
    }

    /**
     * The maximum number of mailboxes that will be pinned in memory before
     * the mailbox manager starts allowing them to be purged via
     * SoftReference garbage collection.
     *
     * @param zimbraMailboxManagerHardrefCache new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1856)
    public void setMailboxManagerHardrefCache(int zimbraMailboxManagerHardrefCache) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxManagerHardrefCache, Integer.toString(zimbraMailboxManagerHardrefCache));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum number of mailboxes that will be pinned in memory before
     * the mailbox manager starts allowing them to be purged via
     * SoftReference garbage collection.
     *
     * @param zimbraMailboxManagerHardrefCache new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1856)
    public Map<String,Object> setMailboxManagerHardrefCache(int zimbraMailboxManagerHardrefCache, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxManagerHardrefCache, Integer.toString(zimbraMailboxManagerHardrefCache));
        return attrs;
    }

    /**
     * The maximum number of mailboxes that will be pinned in memory before
     * the mailbox manager starts allowing them to be purged via
     * SoftReference garbage collection.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1856)
    public void unsetMailboxManagerHardrefCache() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxManagerHardrefCache, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum number of mailboxes that will be pinned in memory before
     * the mailbox manager starts allowing them to be purged via
     * SoftReference garbage collection.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1856)
    public Map<String,Object> unsetMailboxManagerHardrefCache(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxManagerHardrefCache, "");
        return attrs;
    }

    /**
     * Maximum number of HTTP requests per account before ZimbraQoSFilter
     * suspends further requests. Aligns with &quot;Exceeded the max requests
     * limit. Suspending...&quot; warnings in mailbox.log..
     *
     * @return zimbraMailboxMaxConcurrentHttpRequestsPerAccount, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1883)
    public int getMailboxMaxConcurrentHttpRequestsPerAccount() {
        return getIntAttr(Provisioning.A_zimbraMailboxMaxConcurrentHttpRequestsPerAccount, -1);
    }

    /**
     * Maximum number of HTTP requests per account before ZimbraQoSFilter
     * suspends further requests. Aligns with &quot;Exceeded the max requests
     * limit. Suspending...&quot; warnings in mailbox.log..
     *
     * @param zimbraMailboxMaxConcurrentHttpRequestsPerAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1883)
    public void setMailboxMaxConcurrentHttpRequestsPerAccount(int zimbraMailboxMaxConcurrentHttpRequestsPerAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMaxConcurrentHttpRequestsPerAccount, Integer.toString(zimbraMailboxMaxConcurrentHttpRequestsPerAccount));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of HTTP requests per account before ZimbraQoSFilter
     * suspends further requests. Aligns with &quot;Exceeded the max requests
     * limit. Suspending...&quot; warnings in mailbox.log..
     *
     * @param zimbraMailboxMaxConcurrentHttpRequestsPerAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1883)
    public Map<String,Object> setMailboxMaxConcurrentHttpRequestsPerAccount(int zimbraMailboxMaxConcurrentHttpRequestsPerAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMaxConcurrentHttpRequestsPerAccount, Integer.toString(zimbraMailboxMaxConcurrentHttpRequestsPerAccount));
        return attrs;
    }

    /**
     * Maximum number of HTTP requests per account before ZimbraQoSFilter
     * suspends further requests. Aligns with &quot;Exceeded the max requests
     * limit. Suspending...&quot; warnings in mailbox.log..
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1883)
    public void unsetMailboxMaxConcurrentHttpRequestsPerAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMaxConcurrentHttpRequestsPerAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of HTTP requests per account before ZimbraQoSFilter
     * suspends further requests. Aligns with &quot;Exceeded the max requests
     * limit. Suspending...&quot; warnings in mailbox.log..
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1883)
    public Map<String,Object> unsetMailboxMaxConcurrentHttpRequestsPerAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMaxConcurrentHttpRequestsPerAccount, "");
        return attrs;
    }

    /**
     * max number of concurrent HTTP requests per HTTP session .0 means no
     * limit. A change is in effect from new session.
     *
     * @return zimbraMailboxMaxConcurrentRequestsPerSession, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1884)
    public int getMailboxMaxConcurrentRequestsPerSession() {
        return getIntAttr(Provisioning.A_zimbraMailboxMaxConcurrentRequestsPerSession, -1);
    }

    /**
     * max number of concurrent HTTP requests per HTTP session .0 means no
     * limit. A change is in effect from new session.
     *
     * @param zimbraMailboxMaxConcurrentRequestsPerSession new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1884)
    public void setMailboxMaxConcurrentRequestsPerSession(int zimbraMailboxMaxConcurrentRequestsPerSession) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMaxConcurrentRequestsPerSession, Integer.toString(zimbraMailboxMaxConcurrentRequestsPerSession));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max number of concurrent HTTP requests per HTTP session .0 means no
     * limit. A change is in effect from new session.
     *
     * @param zimbraMailboxMaxConcurrentRequestsPerSession new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1884)
    public Map<String,Object> setMailboxMaxConcurrentRequestsPerSession(int zimbraMailboxMaxConcurrentRequestsPerSession, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMaxConcurrentRequestsPerSession, Integer.toString(zimbraMailboxMaxConcurrentRequestsPerSession));
        return attrs;
    }

    /**
     * max number of concurrent HTTP requests per HTTP session .0 means no
     * limit. A change is in effect from new session.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1884)
    public void unsetMailboxMaxConcurrentRequestsPerSession() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMaxConcurrentRequestsPerSession, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max number of concurrent HTTP requests per HTTP session .0 means no
     * limit. A change is in effect from new session.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1884)
    public Map<String,Object> unsetMailboxMaxConcurrentRequestsPerSession(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMaxConcurrentRequestsPerSession, "");
        return attrs;
    }

    /**
     * if true, exclude blobs (HSM or not) from mailbox move
     *
     * @return zimbraMailboxMoveSkipBlobs, or false if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1007)
    public boolean isMailboxMoveSkipBlobs() {
        return getBooleanAttr(Provisioning.A_zimbraMailboxMoveSkipBlobs, false);
    }

    /**
     * if true, exclude blobs (HSM or not) from mailbox move
     *
     * @param zimbraMailboxMoveSkipBlobs new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1007)
    public void setMailboxMoveSkipBlobs(boolean zimbraMailboxMoveSkipBlobs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipBlobs, zimbraMailboxMoveSkipBlobs ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, exclude blobs (HSM or not) from mailbox move
     *
     * @param zimbraMailboxMoveSkipBlobs new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1007)
    public Map<String,Object> setMailboxMoveSkipBlobs(boolean zimbraMailboxMoveSkipBlobs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipBlobs, zimbraMailboxMoveSkipBlobs ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * if true, exclude blobs (HSM or not) from mailbox move
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1007)
    public void unsetMailboxMoveSkipBlobs() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipBlobs, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, exclude blobs (HSM or not) from mailbox move
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1007)
    public Map<String,Object> unsetMailboxMoveSkipBlobs(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipBlobs, "");
        return attrs;
    }

    /**
     * if true, exclude blobs on secondary (HSM) volumes from mailbox move
     *
     * @return zimbraMailboxMoveSkipHsmBlobs, or false if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1008)
    public boolean isMailboxMoveSkipHsmBlobs() {
        return getBooleanAttr(Provisioning.A_zimbraMailboxMoveSkipHsmBlobs, false);
    }

    /**
     * if true, exclude blobs on secondary (HSM) volumes from mailbox move
     *
     * @param zimbraMailboxMoveSkipHsmBlobs new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1008)
    public void setMailboxMoveSkipHsmBlobs(boolean zimbraMailboxMoveSkipHsmBlobs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipHsmBlobs, zimbraMailboxMoveSkipHsmBlobs ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, exclude blobs on secondary (HSM) volumes from mailbox move
     *
     * @param zimbraMailboxMoveSkipHsmBlobs new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1008)
    public Map<String,Object> setMailboxMoveSkipHsmBlobs(boolean zimbraMailboxMoveSkipHsmBlobs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipHsmBlobs, zimbraMailboxMoveSkipHsmBlobs ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * if true, exclude blobs on secondary (HSM) volumes from mailbox move
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1008)
    public void unsetMailboxMoveSkipHsmBlobs() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipHsmBlobs, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, exclude blobs on secondary (HSM) volumes from mailbox move
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1008)
    public Map<String,Object> unsetMailboxMoveSkipHsmBlobs(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipHsmBlobs, "");
        return attrs;
    }

    /**
     * if true, exclude search index from mailbox move
     *
     * @return zimbraMailboxMoveSkipSearchIndex, or false if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1006)
    public boolean isMailboxMoveSkipSearchIndex() {
        return getBooleanAttr(Provisioning.A_zimbraMailboxMoveSkipSearchIndex, false);
    }

    /**
     * if true, exclude search index from mailbox move
     *
     * @param zimbraMailboxMoveSkipSearchIndex new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1006)
    public void setMailboxMoveSkipSearchIndex(boolean zimbraMailboxMoveSkipSearchIndex) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipSearchIndex, zimbraMailboxMoveSkipSearchIndex ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, exclude search index from mailbox move
     *
     * @param zimbraMailboxMoveSkipSearchIndex new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1006)
    public Map<String,Object> setMailboxMoveSkipSearchIndex(boolean zimbraMailboxMoveSkipSearchIndex, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipSearchIndex, zimbraMailboxMoveSkipSearchIndex ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * if true, exclude search index from mailbox move
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1006)
    public void unsetMailboxMoveSkipSearchIndex() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipSearchIndex, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, exclude search index from mailbox move
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1006)
    public Map<String,Object> unsetMailboxMoveSkipSearchIndex(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipSearchIndex, "");
        return attrs;
    }

    /**
     * temp directory for mailbox move
     *
     * @return zimbraMailboxMoveTempDir, or null if unset
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1175)
    public String getMailboxMoveTempDir() {
        return getAttr(Provisioning.A_zimbraMailboxMoveTempDir, null);
    }

    /**
     * temp directory for mailbox move
     *
     * @param zimbraMailboxMoveTempDir new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1175)
    public void setMailboxMoveTempDir(String zimbraMailboxMoveTempDir) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveTempDir, zimbraMailboxMoveTempDir);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * temp directory for mailbox move
     *
     * @param zimbraMailboxMoveTempDir new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1175)
    public Map<String,Object> setMailboxMoveTempDir(String zimbraMailboxMoveTempDir, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveTempDir, zimbraMailboxMoveTempDir);
        return attrs;
    }

    /**
     * temp directory for mailbox move
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1175)
    public void unsetMailboxMoveTempDir() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveTempDir, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * temp directory for mailbox move
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1175)
    public Map<String,Object> unsetMailboxMoveTempDir(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveTempDir, "");
        return attrs;
    }

    /**
     * Time in seconds the server will allow a NoOpRequest to block if wait=1
     * is specified by the client. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getMailboxNoopDefaultTimeoutAsString to access value as a string.
     *
     * @see #getMailboxNoopDefaultTimeoutAsString()
     *
     * @return zimbraMailboxNoopDefaultTimeout in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1859)
    public long getMailboxNoopDefaultTimeout() {
        return getTimeInterval(Provisioning.A_zimbraMailboxNoopDefaultTimeout, -1L);
    }

    /**
     * Time in seconds the server will allow a NoOpRequest to block if wait=1
     * is specified by the client. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraMailboxNoopDefaultTimeout, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1859)
    public String getMailboxNoopDefaultTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraMailboxNoopDefaultTimeout, null);
    }

    /**
     * Time in seconds the server will allow a NoOpRequest to block if wait=1
     * is specified by the client. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailboxNoopDefaultTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1859)
    public void setMailboxNoopDefaultTimeout(String zimbraMailboxNoopDefaultTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxNoopDefaultTimeout, zimbraMailboxNoopDefaultTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time in seconds the server will allow a NoOpRequest to block if wait=1
     * is specified by the client. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailboxNoopDefaultTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1859)
    public Map<String,Object> setMailboxNoopDefaultTimeout(String zimbraMailboxNoopDefaultTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxNoopDefaultTimeout, zimbraMailboxNoopDefaultTimeout);
        return attrs;
    }

    /**
     * Time in seconds the server will allow a NoOpRequest to block if wait=1
     * is specified by the client. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1859)
    public void unsetMailboxNoopDefaultTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxNoopDefaultTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time in seconds the server will allow a NoOpRequest to block if wait=1
     * is specified by the client. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1859)
    public Map<String,Object> unsetMailboxNoopDefaultTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxNoopDefaultTimeout, "");
        return attrs;
    }

    /**
     * Maximum allowable timeout (seconds) specified to NoOpRequest. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getMailboxNoopMaxTimeoutAsString to access value as a string.
     *
     * @see #getMailboxNoopMaxTimeoutAsString()
     *
     * @return zimbraMailboxNoopMaxTimeout in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1860)
    public long getMailboxNoopMaxTimeout() {
        return getTimeInterval(Provisioning.A_zimbraMailboxNoopMaxTimeout, -1L);
    }

    /**
     * Maximum allowable timeout (seconds) specified to NoOpRequest. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraMailboxNoopMaxTimeout, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1860)
    public String getMailboxNoopMaxTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraMailboxNoopMaxTimeout, null);
    }

    /**
     * Maximum allowable timeout (seconds) specified to NoOpRequest. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMailboxNoopMaxTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1860)
    public void setMailboxNoopMaxTimeout(String zimbraMailboxNoopMaxTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxNoopMaxTimeout, zimbraMailboxNoopMaxTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum allowable timeout (seconds) specified to NoOpRequest. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMailboxNoopMaxTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1860)
    public Map<String,Object> setMailboxNoopMaxTimeout(String zimbraMailboxNoopMaxTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxNoopMaxTimeout, zimbraMailboxNoopMaxTimeout);
        return attrs;
    }

    /**
     * Maximum allowable timeout (seconds) specified to NoOpRequest. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1860)
    public void unsetMailboxNoopMaxTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxNoopMaxTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum allowable timeout (seconds) specified to NoOpRequest. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1860)
    public Map<String,Object> unsetMailboxNoopMaxTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxNoopMaxTimeout, "");
        return attrs;
    }

    /**
     * Minimum allowable timeout (seconds) specified to NoOpRequest. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getMailboxNoopMinTimeoutAsString to access value as a string.
     *
     * @see #getMailboxNoopMinTimeoutAsString()
     *
     * @return zimbraMailboxNoopMinTimeout in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1861)
    public long getMailboxNoopMinTimeout() {
        return getTimeInterval(Provisioning.A_zimbraMailboxNoopMinTimeout, -1L);
    }

    /**
     * Minimum allowable timeout (seconds) specified to NoOpRequest. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraMailboxNoopMinTimeout, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1861)
    public String getMailboxNoopMinTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraMailboxNoopMinTimeout, null);
    }

    /**
     * Minimum allowable timeout (seconds) specified to NoOpRequest. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMailboxNoopMinTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1861)
    public void setMailboxNoopMinTimeout(String zimbraMailboxNoopMinTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxNoopMinTimeout, zimbraMailboxNoopMinTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum allowable timeout (seconds) specified to NoOpRequest. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMailboxNoopMinTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1861)
    public Map<String,Object> setMailboxNoopMinTimeout(String zimbraMailboxNoopMinTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxNoopMinTimeout, zimbraMailboxNoopMinTimeout);
        return attrs;
    }

    /**
     * Minimum allowable timeout (seconds) specified to NoOpRequest. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1861)
    public void unsetMailboxNoopMinTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxNoopMinTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum allowable timeout (seconds) specified to NoOpRequest. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1861)
    public Map<String,Object> unsetMailboxNoopMinTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxNoopMinTimeout, "");
        return attrs;
    }

    /**
     * Initial sleep time in millis for mailbox purge thread. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getMailboxPurgeInitialSleepAsString to access value as a string.
     *
     * @see #getMailboxPurgeInitialSleepAsString()
     *
     * @return zimbraMailboxPurgeInitialSleep in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1878)
    public long getMailboxPurgeInitialSleep() {
        return getTimeInterval(Provisioning.A_zimbraMailboxPurgeInitialSleep, -1L);
    }

    /**
     * Initial sleep time in millis for mailbox purge thread. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraMailboxPurgeInitialSleep, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1878)
    public String getMailboxPurgeInitialSleepAsString() {
        return getAttr(Provisioning.A_zimbraMailboxPurgeInitialSleep, null);
    }

    /**
     * Initial sleep time in millis for mailbox purge thread. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMailboxPurgeInitialSleep new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1878)
    public void setMailboxPurgeInitialSleep(String zimbraMailboxPurgeInitialSleep) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxPurgeInitialSleep, zimbraMailboxPurgeInitialSleep);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Initial sleep time in millis for mailbox purge thread. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMailboxPurgeInitialSleep new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1878)
    public Map<String,Object> setMailboxPurgeInitialSleep(String zimbraMailboxPurgeInitialSleep, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxPurgeInitialSleep, zimbraMailboxPurgeInitialSleep);
        return attrs;
    }

    /**
     * Initial sleep time in millis for mailbox purge thread. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1878)
    public void unsetMailboxPurgeInitialSleep() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxPurgeInitialSleep, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Initial sleep time in millis for mailbox purge thread. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1878)
    public Map<String,Object> unsetMailboxPurgeInitialSleep(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxPurgeInitialSleep, "");
        return attrs;
    }

    /**
     * Minimise server resources for small servers such as Zimbra Desktop.
     *
     * @return zimbraMailboxResourceBundleMinimizeResources, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1857)
    public boolean isMailboxResourceBundleMinimizeResources() {
        return getBooleanAttr(Provisioning.A_zimbraMailboxResourceBundleMinimizeResources, false);
    }

    /**
     * Minimise server resources for small servers such as Zimbra Desktop.
     *
     * @param zimbraMailboxResourceBundleMinimizeResources new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1857)
    public void setMailboxResourceBundleMinimizeResources(boolean zimbraMailboxResourceBundleMinimizeResources) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxResourceBundleMinimizeResources, zimbraMailboxResourceBundleMinimizeResources ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimise server resources for small servers such as Zimbra Desktop.
     *
     * @param zimbraMailboxResourceBundleMinimizeResources new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1857)
    public Map<String,Object> setMailboxResourceBundleMinimizeResources(boolean zimbraMailboxResourceBundleMinimizeResources, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxResourceBundleMinimizeResources, zimbraMailboxResourceBundleMinimizeResources ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Minimise server resources for small servers such as Zimbra Desktop.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1857)
    public void unsetMailboxResourceBundleMinimizeResources() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxResourceBundleMinimizeResources, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimise server resources for small servers such as Zimbra Desktop.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1857)
    public Map<String,Object> unsetMailboxResourceBundleMinimizeResources(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxResourceBundleMinimizeResources, "");
        return attrs;
    }

    /**
     * Cache control value for the rest api response
     *
     * @return zimbraMailboxRestResponseCacheControl, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1879)
    public String getMailboxRestResponseCacheControl() {
        return getAttr(Provisioning.A_zimbraMailboxRestResponseCacheControl, null);
    }

    /**
     * Cache control value for the rest api response
     *
     * @param zimbraMailboxRestResponseCacheControl new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1879)
    public void setMailboxRestResponseCacheControl(String zimbraMailboxRestResponseCacheControl) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxRestResponseCacheControl, zimbraMailboxRestResponseCacheControl);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Cache control value for the rest api response
     *
     * @param zimbraMailboxRestResponseCacheControl new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1879)
    public Map<String,Object> setMailboxRestResponseCacheControl(String zimbraMailboxRestResponseCacheControl, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxRestResponseCacheControl, zimbraMailboxRestResponseCacheControl);
        return attrs;
    }

    /**
     * Cache control value for the rest api response
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1879)
    public void unsetMailboxRestResponseCacheControl() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxRestResponseCacheControl, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Cache control value for the rest api response
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1879)
    public Map<String,Object> unsetMailboxRestResponseCacheControl(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxRestResponseCacheControl, "");
        return attrs;
    }

    /**
     * Whether delegated admin rights are supported or not
     *
     * @return zimbraMailboxRightsDelegatedAdminSupported, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1864)
    public boolean isMailboxRightsDelegatedAdminSupported() {
        return getBooleanAttr(Provisioning.A_zimbraMailboxRightsDelegatedAdminSupported, false);
    }

    /**
     * Whether delegated admin rights are supported or not
     *
     * @param zimbraMailboxRightsDelegatedAdminSupported new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1864)
    public void setMailboxRightsDelegatedAdminSupported(boolean zimbraMailboxRightsDelegatedAdminSupported) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxRightsDelegatedAdminSupported, zimbraMailboxRightsDelegatedAdminSupported ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether delegated admin rights are supported or not
     *
     * @param zimbraMailboxRightsDelegatedAdminSupported new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1864)
    public Map<String,Object> setMailboxRightsDelegatedAdminSupported(boolean zimbraMailboxRightsDelegatedAdminSupported, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxRightsDelegatedAdminSupported, zimbraMailboxRightsDelegatedAdminSupported ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether delegated admin rights are supported or not
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1864)
    public void unsetMailboxRightsDelegatedAdminSupported() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxRightsDelegatedAdminSupported, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether delegated admin rights are supported or not
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1864)
    public Map<String,Object> unsetMailboxRightsDelegatedAdminSupported(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxRightsDelegatedAdminSupported, "");
        return attrs;
    }

    /**
     * A flag to indicate whether the mailstore is using a shared database.
     * Starting in 9.x the database can be a Galera cluster. Setting this
     * flag to true indicates that we can retry a transaction when
     * transaction commit fails.
     *
     * @return zimbraMailboxSharedDbEnabled, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1944)
    public boolean isMailboxSharedDbEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMailboxSharedDbEnabled, false);
    }

    /**
     * A flag to indicate whether the mailstore is using a shared database.
     * Starting in 9.x the database can be a Galera cluster. Setting this
     * flag to true indicates that we can retry a transaction when
     * transaction commit fails.
     *
     * @param zimbraMailboxSharedDbEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1944)
    public void setMailboxSharedDbEnabled(boolean zimbraMailboxSharedDbEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSharedDbEnabled, zimbraMailboxSharedDbEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * A flag to indicate whether the mailstore is using a shared database.
     * Starting in 9.x the database can be a Galera cluster. Setting this
     * flag to true indicates that we can retry a transaction when
     * transaction commit fails.
     *
     * @param zimbraMailboxSharedDbEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1944)
    public Map<String,Object> setMailboxSharedDbEnabled(boolean zimbraMailboxSharedDbEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSharedDbEnabled, zimbraMailboxSharedDbEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * A flag to indicate whether the mailstore is using a shared database.
     * Starting in 9.x the database can be a Galera cluster. Setting this
     * flag to true indicates that we can retry a transaction when
     * transaction commit fails.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1944)
    public void unsetMailboxSharedDbEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSharedDbEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * A flag to indicate whether the mailstore is using a shared database.
     * Starting in 9.x the database can be a Galera cluster. Setting this
     * flag to true indicates that we can retry a transaction when
     * transaction commit fails.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1944)
    public Map<String,Object> unsetMailboxSharedDbEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSharedDbEnabled, "");
        return attrs;
    }

    /**
     * Indicates the retry count for commiting a failed database transaction.
     * This is only applicable when using a shared database.
     *
     * @return zimbraMailboxSharedDbTransRetryCount, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1945)
    public int getMailboxSharedDbTransRetryCount() {
        return getIntAttr(Provisioning.A_zimbraMailboxSharedDbTransRetryCount, -1);
    }

    /**
     * Indicates the retry count for commiting a failed database transaction.
     * This is only applicable when using a shared database.
     *
     * @param zimbraMailboxSharedDbTransRetryCount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1945)
    public void setMailboxSharedDbTransRetryCount(int zimbraMailboxSharedDbTransRetryCount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSharedDbTransRetryCount, Integer.toString(zimbraMailboxSharedDbTransRetryCount));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Indicates the retry count for commiting a failed database transaction.
     * This is only applicable when using a shared database.
     *
     * @param zimbraMailboxSharedDbTransRetryCount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1945)
    public Map<String,Object> setMailboxSharedDbTransRetryCount(int zimbraMailboxSharedDbTransRetryCount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSharedDbTransRetryCount, Integer.toString(zimbraMailboxSharedDbTransRetryCount));
        return attrs;
    }

    /**
     * Indicates the retry count for commiting a failed database transaction.
     * This is only applicable when using a shared database.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1945)
    public void unsetMailboxSharedDbTransRetryCount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSharedDbTransRetryCount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Indicates the retry count for commiting a failed database transaction.
     * This is only applicable when using a shared database.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1945)
    public Map<String,Object> unsetMailboxSharedDbTransRetryCount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSharedDbTransRetryCount, "");
        return attrs;
    }

    /**
     * Indicates the pause in seconds between retries for commiting a failed
     * database transaction. This is only applicable when using shared
     * database.
     *
     * @return zimbraMailboxSharedDbTransRetryDelay, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1946)
    public long getMailboxSharedDbTransRetryDelay() {
        return getLongAttr(Provisioning.A_zimbraMailboxSharedDbTransRetryDelay, -1L);
    }

    /**
     * Indicates the pause in seconds between retries for commiting a failed
     * database transaction. This is only applicable when using shared
     * database.
     *
     * @param zimbraMailboxSharedDbTransRetryDelay new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1946)
    public void setMailboxSharedDbTransRetryDelay(long zimbraMailboxSharedDbTransRetryDelay) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSharedDbTransRetryDelay, Long.toString(zimbraMailboxSharedDbTransRetryDelay));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Indicates the pause in seconds between retries for commiting a failed
     * database transaction. This is only applicable when using shared
     * database.
     *
     * @param zimbraMailboxSharedDbTransRetryDelay new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1946)
    public Map<String,Object> setMailboxSharedDbTransRetryDelay(long zimbraMailboxSharedDbTransRetryDelay, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSharedDbTransRetryDelay, Long.toString(zimbraMailboxSharedDbTransRetryDelay));
        return attrs;
    }

    /**
     * Indicates the pause in seconds between retries for commiting a failed
     * database transaction. This is only applicable when using shared
     * database.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1946)
    public void unsetMailboxSharedDbTransRetryDelay() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSharedDbTransRetryDelay, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Indicates the pause in seconds between retries for commiting a failed
     * database transaction. This is only applicable when using shared
     * database.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1946)
    public Map<String,Object> unsetMailboxSharedDbTransRetryDelay(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSharedDbTransRetryDelay, "");
        return attrs;
    }

    /**
     * Number of milliseconds to wait before retrying after a failed
     * connection to an SMTP host. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getMailboxSmtpHostRetryWaitAsString to access value as a string.
     *
     * @see #getMailboxSmtpHostRetryWaitAsString()
     *
     * @return zimbraMailboxSmtpHostRetryWait in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1865)
    public long getMailboxSmtpHostRetryWait() {
        return getTimeInterval(Provisioning.A_zimbraMailboxSmtpHostRetryWait, -1L);
    }

    /**
     * Number of milliseconds to wait before retrying after a failed
     * connection to an SMTP host. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraMailboxSmtpHostRetryWait, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1865)
    public String getMailboxSmtpHostRetryWaitAsString() {
        return getAttr(Provisioning.A_zimbraMailboxSmtpHostRetryWait, null);
    }

    /**
     * Number of milliseconds to wait before retrying after a failed
     * connection to an SMTP host. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailboxSmtpHostRetryWait new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1865)
    public void setMailboxSmtpHostRetryWait(String zimbraMailboxSmtpHostRetryWait) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSmtpHostRetryWait, zimbraMailboxSmtpHostRetryWait);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Number of milliseconds to wait before retrying after a failed
     * connection to an SMTP host. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailboxSmtpHostRetryWait new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1865)
    public Map<String,Object> setMailboxSmtpHostRetryWait(String zimbraMailboxSmtpHostRetryWait, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSmtpHostRetryWait, zimbraMailboxSmtpHostRetryWait);
        return attrs;
    }

    /**
     * Number of milliseconds to wait before retrying after a failed
     * connection to an SMTP host. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1865)
    public void unsetMailboxSmtpHostRetryWait() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSmtpHostRetryWait, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Number of milliseconds to wait before retrying after a failed
     * connection to an SMTP host. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1865)
    public Map<String,Object> unsetMailboxSmtpHostRetryWait(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSmtpHostRetryWait, "");
        return attrs;
    }

    /**
     * Flag to enable smtptolmtp server
     *
     * @return zimbraMailboxSmtpToLmtpEnabled, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1885)
    public boolean isMailboxSmtpToLmtpEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMailboxSmtpToLmtpEnabled, false);
    }

    /**
     * Flag to enable smtptolmtp server
     *
     * @param zimbraMailboxSmtpToLmtpEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1885)
    public void setMailboxSmtpToLmtpEnabled(boolean zimbraMailboxSmtpToLmtpEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSmtpToLmtpEnabled, zimbraMailboxSmtpToLmtpEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable smtptolmtp server
     *
     * @param zimbraMailboxSmtpToLmtpEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1885)
    public Map<String,Object> setMailboxSmtpToLmtpEnabled(boolean zimbraMailboxSmtpToLmtpEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSmtpToLmtpEnabled, zimbraMailboxSmtpToLmtpEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to enable smtptolmtp server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1885)
    public void unsetMailboxSmtpToLmtpEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSmtpToLmtpEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable smtptolmtp server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1885)
    public Map<String,Object> unsetMailboxSmtpToLmtpEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSmtpToLmtpEnabled, "");
        return attrs;
    }

    /**
     * SmtptoLmtp port
     *
     * <p>Use getMailboxSmtpToLmtpPortAsString to access value as a string.
     *
     * @see #getMailboxSmtpToLmtpPortAsString()
     *
     * @return zimbraMailboxSmtpToLmtpPort, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1886)
    public int getMailboxSmtpToLmtpPort() {
        return getIntAttr(Provisioning.A_zimbraMailboxSmtpToLmtpPort, -1);
    }

    /**
     * SmtptoLmtp port
     *
     * @return zimbraMailboxSmtpToLmtpPort, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1886)
    public String getMailboxSmtpToLmtpPortAsString() {
        return getAttr(Provisioning.A_zimbraMailboxSmtpToLmtpPort, null);
    }

    /**
     * SmtptoLmtp port
     *
     * @param zimbraMailboxSmtpToLmtpPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1886)
    public void setMailboxSmtpToLmtpPort(int zimbraMailboxSmtpToLmtpPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSmtpToLmtpPort, Integer.toString(zimbraMailboxSmtpToLmtpPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SmtptoLmtp port
     *
     * @param zimbraMailboxSmtpToLmtpPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1886)
    public Map<String,Object> setMailboxSmtpToLmtpPort(int zimbraMailboxSmtpToLmtpPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSmtpToLmtpPort, Integer.toString(zimbraMailboxSmtpToLmtpPort));
        return attrs;
    }

    /**
     * SmtptoLmtp port
     *
     * @param zimbraMailboxSmtpToLmtpPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1886)
    public void setMailboxSmtpToLmtpPortAsString(String zimbraMailboxSmtpToLmtpPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSmtpToLmtpPort, zimbraMailboxSmtpToLmtpPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SmtptoLmtp port
     *
     * @param zimbraMailboxSmtpToLmtpPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1886)
    public Map<String,Object> setMailboxSmtpToLmtpPortAsString(String zimbraMailboxSmtpToLmtpPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSmtpToLmtpPort, zimbraMailboxSmtpToLmtpPort);
        return attrs;
    }

    /**
     * SmtptoLmtp port
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1886)
    public void unsetMailboxSmtpToLmtpPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSmtpToLmtpPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SmtptoLmtp port
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1886)
    public Map<String,Object> unsetMailboxSmtpToLmtpPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSmtpToLmtpPort, "");
        return attrs;
    }

    /**
     * Flag to enable logging of slow soap api calls.
     *
     * @return zimbraMailboxSoapApiSlowLoggingEnabled, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1866)
    public boolean isMailboxSoapApiSlowLoggingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMailboxSoapApiSlowLoggingEnabled, false);
    }

    /**
     * Flag to enable logging of slow soap api calls.
     *
     * @param zimbraMailboxSoapApiSlowLoggingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1866)
    public void setMailboxSoapApiSlowLoggingEnabled(boolean zimbraMailboxSoapApiSlowLoggingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSoapApiSlowLoggingEnabled, zimbraMailboxSoapApiSlowLoggingEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable logging of slow soap api calls.
     *
     * @param zimbraMailboxSoapApiSlowLoggingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1866)
    public Map<String,Object> setMailboxSoapApiSlowLoggingEnabled(boolean zimbraMailboxSoapApiSlowLoggingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSoapApiSlowLoggingEnabled, zimbraMailboxSoapApiSlowLoggingEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to enable logging of slow soap api calls.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1866)
    public void unsetMailboxSoapApiSlowLoggingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSoapApiSlowLoggingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable logging of slow soap api calls.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1866)
    public Map<String,Object> unsetMailboxSoapApiSlowLoggingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSoapApiSlowLoggingEnabled, "");
        return attrs;
    }

    /**
     * Threshold time to determine slow soap api calls.make sure it&#039;s
     * less than nginx&#039;s zimbraReverseProxyUpstreamPollingTimeout, which
     * is now 3600 seconds. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getMailboxSoapApiSlowLoggingThresholdAsString to access value as a string.
     *
     * @see #getMailboxSoapApiSlowLoggingThresholdAsString()
     *
     * @return zimbraMailboxSoapApiSlowLoggingThreshold in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1867)
    public long getMailboxSoapApiSlowLoggingThreshold() {
        return getTimeInterval(Provisioning.A_zimbraMailboxSoapApiSlowLoggingThreshold, -1L);
    }

    /**
     * Threshold time to determine slow soap api calls.make sure it&#039;s
     * less than nginx&#039;s zimbraReverseProxyUpstreamPollingTimeout, which
     * is now 3600 seconds. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraMailboxSoapApiSlowLoggingThreshold, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1867)
    public String getMailboxSoapApiSlowLoggingThresholdAsString() {
        return getAttr(Provisioning.A_zimbraMailboxSoapApiSlowLoggingThreshold, null);
    }

    /**
     * Threshold time to determine slow soap api calls.make sure it&#039;s
     * less than nginx&#039;s zimbraReverseProxyUpstreamPollingTimeout, which
     * is now 3600 seconds. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailboxSoapApiSlowLoggingThreshold new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1867)
    public void setMailboxSoapApiSlowLoggingThreshold(String zimbraMailboxSoapApiSlowLoggingThreshold) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSoapApiSlowLoggingThreshold, zimbraMailboxSoapApiSlowLoggingThreshold);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Threshold time to determine slow soap api calls.make sure it&#039;s
     * less than nginx&#039;s zimbraReverseProxyUpstreamPollingTimeout, which
     * is now 3600 seconds. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailboxSoapApiSlowLoggingThreshold new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1867)
    public Map<String,Object> setMailboxSoapApiSlowLoggingThreshold(String zimbraMailboxSoapApiSlowLoggingThreshold, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSoapApiSlowLoggingThreshold, zimbraMailboxSoapApiSlowLoggingThreshold);
        return attrs;
    }

    /**
     * Threshold time to determine slow soap api calls.make sure it&#039;s
     * less than nginx&#039;s zimbraReverseProxyUpstreamPollingTimeout, which
     * is now 3600 seconds. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1867)
    public void unsetMailboxSoapApiSlowLoggingThreshold() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSoapApiSlowLoggingThreshold, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Threshold time to determine slow soap api calls.make sure it&#039;s
     * less than nginx&#039;s zimbraReverseProxyUpstreamPollingTimeout, which
     * is now 3600 seconds. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1867)
    public Map<String,Object> unsetMailboxSoapApiSlowLoggingThreshold(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSoapApiSlowLoggingThreshold, "");
        return attrs;
    }

    /**
     * For Junk/Not Junk Msg/ConvActionRequests this queue size limits the
     * the server workqueue for processing the forwards.
     *
     * @return zimbraMailboxSpamHandlerSpamReportQueueSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1868)
    public int getMailboxSpamHandlerSpamReportQueueSize() {
        return getIntAttr(Provisioning.A_zimbraMailboxSpamHandlerSpamReportQueueSize, -1);
    }

    /**
     * For Junk/Not Junk Msg/ConvActionRequests this queue size limits the
     * the server workqueue for processing the forwards.
     *
     * @param zimbraMailboxSpamHandlerSpamReportQueueSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1868)
    public void setMailboxSpamHandlerSpamReportQueueSize(int zimbraMailboxSpamHandlerSpamReportQueueSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSpamHandlerSpamReportQueueSize, Integer.toString(zimbraMailboxSpamHandlerSpamReportQueueSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For Junk/Not Junk Msg/ConvActionRequests this queue size limits the
     * the server workqueue for processing the forwards.
     *
     * @param zimbraMailboxSpamHandlerSpamReportQueueSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1868)
    public Map<String,Object> setMailboxSpamHandlerSpamReportQueueSize(int zimbraMailboxSpamHandlerSpamReportQueueSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSpamHandlerSpamReportQueueSize, Integer.toString(zimbraMailboxSpamHandlerSpamReportQueueSize));
        return attrs;
    }

    /**
     * For Junk/Not Junk Msg/ConvActionRequests this queue size limits the
     * the server workqueue for processing the forwards.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1868)
    public void unsetMailboxSpamHandlerSpamReportQueueSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSpamHandlerSpamReportQueueSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For Junk/Not Junk Msg/ConvActionRequests this queue size limits the
     * the server workqueue for processing the forwards.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1868)
    public Map<String,Object> unsetMailboxSpamHandlerSpamReportQueueSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxSpamHandlerSpamReportQueueSize, "");
        return attrs;
    }

    /**
     * Print warn logs when the specified percentage of threads are used out
     * of total in tcpserver
     *
     * @return zimbraMailboxThreadPoolWarnPercent, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1869)
    public int getMailboxThreadPoolWarnPercent() {
        return getIntAttr(Provisioning.A_zimbraMailboxThreadPoolWarnPercent, -1);
    }

    /**
     * Print warn logs when the specified percentage of threads are used out
     * of total in tcpserver
     *
     * @param zimbraMailboxThreadPoolWarnPercent new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1869)
    public void setMailboxThreadPoolWarnPercent(int zimbraMailboxThreadPoolWarnPercent) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxThreadPoolWarnPercent, Integer.toString(zimbraMailboxThreadPoolWarnPercent));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Print warn logs when the specified percentage of threads are used out
     * of total in tcpserver
     *
     * @param zimbraMailboxThreadPoolWarnPercent new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1869)
    public Map<String,Object> setMailboxThreadPoolWarnPercent(int zimbraMailboxThreadPoolWarnPercent, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxThreadPoolWarnPercent, Integer.toString(zimbraMailboxThreadPoolWarnPercent));
        return attrs;
    }

    /**
     * Print warn logs when the specified percentage of threads are used out
     * of total in tcpserver
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1869)
    public void unsetMailboxThreadPoolWarnPercent() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxThreadPoolWarnPercent, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Print warn logs when the specified percentage of threads are used out
     * of total in tcpserver
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1869)
    public Map<String,Object> unsetMailboxThreadPoolWarnPercent(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxThreadPoolWarnPercent, "");
        return attrs;
    }

    /**
     * Time in milliseconds between IMAP/POP/LMTP rate limiter stale entry
     * cleanup cycle.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getMailboxThrottleReapIntervalAsString to access value as a string.
     *
     * @see #getMailboxThrottleReapIntervalAsString()
     *
     * @return zimbraMailboxThrottleReapInterval in millseconds, or -1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2053)
    public long getMailboxThrottleReapInterval() {
        return getTimeInterval(Provisioning.A_zimbraMailboxThrottleReapInterval, -1L);
    }

    /**
     * Time in milliseconds between IMAP/POP/LMTP rate limiter stale entry
     * cleanup cycle.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraMailboxThrottleReapInterval, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2053)
    public String getMailboxThrottleReapIntervalAsString() {
        return getAttr(Provisioning.A_zimbraMailboxThrottleReapInterval, null);
    }

    /**
     * Time in milliseconds between IMAP/POP/LMTP rate limiter stale entry
     * cleanup cycle.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraMailboxThrottleReapInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2053)
    public void setMailboxThrottleReapInterval(String zimbraMailboxThrottleReapInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxThrottleReapInterval, zimbraMailboxThrottleReapInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time in milliseconds between IMAP/POP/LMTP rate limiter stale entry
     * cleanup cycle.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraMailboxThrottleReapInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2053)
    public Map<String,Object> setMailboxThrottleReapInterval(String zimbraMailboxThrottleReapInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxThrottleReapInterval, zimbraMailboxThrottleReapInterval);
        return attrs;
    }

    /**
     * Time in milliseconds between IMAP/POP/LMTP rate limiter stale entry
     * cleanup cycle.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2053)
    public void unsetMailboxThrottleReapInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxThrottleReapInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time in milliseconds between IMAP/POP/LMTP rate limiter stale entry
     * cleanup cycle.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2053)
    public Map<String,Object> unsetMailboxThrottleReapInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxThrottleReapInterval, "");
        return attrs;
    }

    /**
     * Max age in millis used for purging the items in tombstone. Default is
     * 3 months. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getMailboxTombstoneMaxAgeAsString to access value as a string.
     *
     * @see #getMailboxTombstoneMaxAgeAsString()
     *
     * @return zimbraMailboxTombstoneMaxAge in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1889)
    public long getMailboxTombstoneMaxAge() {
        return getTimeInterval(Provisioning.A_zimbraMailboxTombstoneMaxAge, -1L);
    }

    /**
     * Max age in millis used for purging the items in tombstone. Default is
     * 3 months. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraMailboxTombstoneMaxAge, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1889)
    public String getMailboxTombstoneMaxAgeAsString() {
        return getAttr(Provisioning.A_zimbraMailboxTombstoneMaxAge, null);
    }

    /**
     * Max age in millis used for purging the items in tombstone. Default is
     * 3 months. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraMailboxTombstoneMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1889)
    public void setMailboxTombstoneMaxAge(String zimbraMailboxTombstoneMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxTombstoneMaxAge, zimbraMailboxTombstoneMaxAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max age in millis used for purging the items in tombstone. Default is
     * 3 months. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraMailboxTombstoneMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1889)
    public Map<String,Object> setMailboxTombstoneMaxAge(String zimbraMailboxTombstoneMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxTombstoneMaxAge, zimbraMailboxTombstoneMaxAge);
        return attrs;
    }

    /**
     * Max age in millis used for purging the items in tombstone. Default is
     * 3 months. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1889)
    public void unsetMailboxTombstoneMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxTombstoneMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max age in millis used for purging the items in tombstone. Default is
     * 3 months. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1889)
    public Map<String,Object> unsetMailboxTombstoneMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxTombstoneMaxAge, "");
        return attrs;
    }

    /**
     * Whether volume paths are relative or absolute.
     *
     * @return zimbraMailboxVolumeRelativePath, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1863)
    public boolean isMailboxVolumeRelativePath() {
        return getBooleanAttr(Provisioning.A_zimbraMailboxVolumeRelativePath, false);
    }

    /**
     * Whether volume paths are relative or absolute.
     *
     * @param zimbraMailboxVolumeRelativePath new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1863)
    public void setMailboxVolumeRelativePath(boolean zimbraMailboxVolumeRelativePath) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxVolumeRelativePath, zimbraMailboxVolumeRelativePath ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether volume paths are relative or absolute.
     *
     * @param zimbraMailboxVolumeRelativePath new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1863)
    public Map<String,Object> setMailboxVolumeRelativePath(boolean zimbraMailboxVolumeRelativePath, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxVolumeRelativePath, zimbraMailboxVolumeRelativePath ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether volume paths are relative or absolute.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1863)
    public void unsetMailboxVolumeRelativePath() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxVolumeRelativePath, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether volume paths are relative or absolute.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1863)
    public Map<String,Object> unsetMailboxVolumeRelativePath(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxVolumeRelativePath, "");
        return attrs;
    }

    /**
     * Default Timeout in seconds a non-admin WaitSetRequest will block..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getMailboxWaitsetDefaultRequestTimeoutAsString to access value as a string.
     *
     * @see #getMailboxWaitsetDefaultRequestTimeoutAsString()
     *
     * @return zimbraMailboxWaitsetDefaultRequestTimeout in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1872)
    public long getMailboxWaitsetDefaultRequestTimeout() {
        return getTimeInterval(Provisioning.A_zimbraMailboxWaitsetDefaultRequestTimeout, -1L);
    }

    /**
     * Default Timeout in seconds a non-admin WaitSetRequest will block..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraMailboxWaitsetDefaultRequestTimeout, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1872)
    public String getMailboxWaitsetDefaultRequestTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraMailboxWaitsetDefaultRequestTimeout, null);
    }

    /**
     * Default Timeout in seconds a non-admin WaitSetRequest will block..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMailboxWaitsetDefaultRequestTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1872)
    public void setMailboxWaitsetDefaultRequestTimeout(String zimbraMailboxWaitsetDefaultRequestTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetDefaultRequestTimeout, zimbraMailboxWaitsetDefaultRequestTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Default Timeout in seconds a non-admin WaitSetRequest will block..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMailboxWaitsetDefaultRequestTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1872)
    public Map<String,Object> setMailboxWaitsetDefaultRequestTimeout(String zimbraMailboxWaitsetDefaultRequestTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetDefaultRequestTimeout, zimbraMailboxWaitsetDefaultRequestTimeout);
        return attrs;
    }

    /**
     * Default Timeout in seconds a non-admin WaitSetRequest will block..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1872)
    public void unsetMailboxWaitsetDefaultRequestTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetDefaultRequestTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Default Timeout in seconds a non-admin WaitSetRequest will block..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1872)
    public Map<String,Object> unsetMailboxWaitsetDefaultRequestTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetDefaultRequestTimeout, "");
        return attrs;
    }

    /**
     * Initial timeout in milliseconds to wait before processing any
     * WaitSetRequest.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getMailboxWaitsetInitialSleepTimeAsString to access value as a string.
     *
     * @see #getMailboxWaitsetInitialSleepTimeAsString()
     *
     * @return zimbraMailboxWaitsetInitialSleepTime in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1873)
    public long getMailboxWaitsetInitialSleepTime() {
        return getTimeInterval(Provisioning.A_zimbraMailboxWaitsetInitialSleepTime, -1L);
    }

    /**
     * Initial timeout in milliseconds to wait before processing any
     * WaitSetRequest.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraMailboxWaitsetInitialSleepTime, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1873)
    public String getMailboxWaitsetInitialSleepTimeAsString() {
        return getAttr(Provisioning.A_zimbraMailboxWaitsetInitialSleepTime, null);
    }

    /**
     * Initial timeout in milliseconds to wait before processing any
     * WaitSetRequest.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailboxWaitsetInitialSleepTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1873)
    public void setMailboxWaitsetInitialSleepTime(String zimbraMailboxWaitsetInitialSleepTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetInitialSleepTime, zimbraMailboxWaitsetInitialSleepTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Initial timeout in milliseconds to wait before processing any
     * WaitSetRequest.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailboxWaitsetInitialSleepTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1873)
    public Map<String,Object> setMailboxWaitsetInitialSleepTime(String zimbraMailboxWaitsetInitialSleepTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetInitialSleepTime, zimbraMailboxWaitsetInitialSleepTime);
        return attrs;
    }

    /**
     * Initial timeout in milliseconds to wait before processing any
     * WaitSetRequest.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1873)
    public void unsetMailboxWaitsetInitialSleepTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetInitialSleepTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Initial timeout in milliseconds to wait before processing any
     * WaitSetRequest.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1873)
    public Map<String,Object> unsetMailboxWaitsetInitialSleepTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetInitialSleepTime, "");
        return attrs;
    }

    /**
     * Maximum number of non-admin WaitSets a single account may have open.
     *
     * @return zimbraMailboxWaitsetMaxPerAccount, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1874)
    public int getMailboxWaitsetMaxPerAccount() {
        return getIntAttr(Provisioning.A_zimbraMailboxWaitsetMaxPerAccount, -1);
    }

    /**
     * Maximum number of non-admin WaitSets a single account may have open.
     *
     * @param zimbraMailboxWaitsetMaxPerAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1874)
    public void setMailboxWaitsetMaxPerAccount(int zimbraMailboxWaitsetMaxPerAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetMaxPerAccount, Integer.toString(zimbraMailboxWaitsetMaxPerAccount));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of non-admin WaitSets a single account may have open.
     *
     * @param zimbraMailboxWaitsetMaxPerAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1874)
    public Map<String,Object> setMailboxWaitsetMaxPerAccount(int zimbraMailboxWaitsetMaxPerAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetMaxPerAccount, Integer.toString(zimbraMailboxWaitsetMaxPerAccount));
        return attrs;
    }

    /**
     * Maximum number of non-admin WaitSets a single account may have open.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1874)
    public void unsetMailboxWaitsetMaxPerAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetMaxPerAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of non-admin WaitSets a single account may have open.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1874)
    public Map<String,Object> unsetMailboxWaitsetMaxPerAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetMaxPerAccount, "");
        return attrs;
    }

    /**
     * Maximum Timeout in seconds a non-admin WaitSetRequest will block..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getMailboxWaitsetMaxRequestTimeoutAsString to access value as a string.
     *
     * @see #getMailboxWaitsetMaxRequestTimeoutAsString()
     *
     * @return zimbraMailboxWaitsetMaxRequestTimeout in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1875)
    public long getMailboxWaitsetMaxRequestTimeout() {
        return getTimeInterval(Provisioning.A_zimbraMailboxWaitsetMaxRequestTimeout, -1L);
    }

    /**
     * Maximum Timeout in seconds a non-admin WaitSetRequest will block..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraMailboxWaitsetMaxRequestTimeout, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1875)
    public String getMailboxWaitsetMaxRequestTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraMailboxWaitsetMaxRequestTimeout, null);
    }

    /**
     * Maximum Timeout in seconds a non-admin WaitSetRequest will block..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMailboxWaitsetMaxRequestTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1875)
    public void setMailboxWaitsetMaxRequestTimeout(String zimbraMailboxWaitsetMaxRequestTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetMaxRequestTimeout, zimbraMailboxWaitsetMaxRequestTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum Timeout in seconds a non-admin WaitSetRequest will block..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMailboxWaitsetMaxRequestTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1875)
    public Map<String,Object> setMailboxWaitsetMaxRequestTimeout(String zimbraMailboxWaitsetMaxRequestTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetMaxRequestTimeout, zimbraMailboxWaitsetMaxRequestTimeout);
        return attrs;
    }

    /**
     * Maximum Timeout in seconds a non-admin WaitSetRequest will block..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1875)
    public void unsetMailboxWaitsetMaxRequestTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetMaxRequestTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum Timeout in seconds a non-admin WaitSetRequest will block..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1875)
    public Map<String,Object> unsetMailboxWaitsetMaxRequestTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetMaxRequestTimeout, "");
        return attrs;
    }

    /**
     * Minimum Timeout (seconds) a non-admin WaitSetRequest will block. Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getMailboxWaitsetMinRequestTimeoutAsString to access value as a string.
     *
     * @see #getMailboxWaitsetMinRequestTimeoutAsString()
     *
     * @return zimbraMailboxWaitsetMinRequestTimeout in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1876)
    public long getMailboxWaitsetMinRequestTimeout() {
        return getTimeInterval(Provisioning.A_zimbraMailboxWaitsetMinRequestTimeout, -1L);
    }

    /**
     * Minimum Timeout (seconds) a non-admin WaitSetRequest will block. Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraMailboxWaitsetMinRequestTimeout, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1876)
    public String getMailboxWaitsetMinRequestTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraMailboxWaitsetMinRequestTimeout, null);
    }

    /**
     * Minimum Timeout (seconds) a non-admin WaitSetRequest will block. Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMailboxWaitsetMinRequestTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1876)
    public void setMailboxWaitsetMinRequestTimeout(String zimbraMailboxWaitsetMinRequestTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetMinRequestTimeout, zimbraMailboxWaitsetMinRequestTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum Timeout (seconds) a non-admin WaitSetRequest will block. Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMailboxWaitsetMinRequestTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1876)
    public Map<String,Object> setMailboxWaitsetMinRequestTimeout(String zimbraMailboxWaitsetMinRequestTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetMinRequestTimeout, zimbraMailboxWaitsetMinRequestTimeout);
        return attrs;
    }

    /**
     * Minimum Timeout (seconds) a non-admin WaitSetRequest will block. Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1876)
    public void unsetMailboxWaitsetMinRequestTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetMinRequestTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum Timeout (seconds) a non-admin WaitSetRequest will block. Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1876)
    public Map<String,Object> unsetMailboxWaitsetMinRequestTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetMinRequestTimeout, "");
        return attrs;
    }

    /**
     * Time in milliseconds to sleep handling a WaitSetRequest if there is no
     * data after initial check. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getMailboxWaitsetNoDataSleepTimeAsString to access value as a string.
     *
     * @see #getMailboxWaitsetNoDataSleepTimeAsString()
     *
     * @return zimbraMailboxWaitsetNoDataSleepTime in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1877)
    public long getMailboxWaitsetNoDataSleepTime() {
        return getTimeInterval(Provisioning.A_zimbraMailboxWaitsetNoDataSleepTime, -1L);
    }

    /**
     * Time in milliseconds to sleep handling a WaitSetRequest if there is no
     * data after initial check. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraMailboxWaitsetNoDataSleepTime, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1877)
    public String getMailboxWaitsetNoDataSleepTimeAsString() {
        return getAttr(Provisioning.A_zimbraMailboxWaitsetNoDataSleepTime, null);
    }

    /**
     * Time in milliseconds to sleep handling a WaitSetRequest if there is no
     * data after initial check. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailboxWaitsetNoDataSleepTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1877)
    public void setMailboxWaitsetNoDataSleepTime(String zimbraMailboxWaitsetNoDataSleepTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetNoDataSleepTime, zimbraMailboxWaitsetNoDataSleepTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time in milliseconds to sleep handling a WaitSetRequest if there is no
     * data after initial check. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailboxWaitsetNoDataSleepTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1877)
    public Map<String,Object> setMailboxWaitsetNoDataSleepTime(String zimbraMailboxWaitsetNoDataSleepTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetNoDataSleepTime, zimbraMailboxWaitsetNoDataSleepTime);
        return attrs;
    }

    /**
     * Time in milliseconds to sleep handling a WaitSetRequest if there is no
     * data after initial check. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1877)
    public void unsetMailboxWaitsetNoDataSleepTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetNoDataSleepTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time in milliseconds to sleep handling a WaitSetRequest if there is no
     * data after initial check. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1877)
    public Map<String,Object> unsetMailboxWaitsetNoDataSleepTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetNoDataSleepTime, "");
        return attrs;
    }

    /**
     * Waitset sweeper thread interval.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getMailboxWaitsetSweepDelayAsString to access value as a string.
     *
     * @see #getMailboxWaitsetSweepDelayAsString()
     *
     * @return zimbraMailboxWaitsetSweepDelay in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2039)
    public long getMailboxWaitsetSweepDelay() {
        return getTimeInterval(Provisioning.A_zimbraMailboxWaitsetSweepDelay, -1L);
    }

    /**
     * Waitset sweeper thread interval.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraMailboxWaitsetSweepDelay, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2039)
    public String getMailboxWaitsetSweepDelayAsString() {
        return getAttr(Provisioning.A_zimbraMailboxWaitsetSweepDelay, null);
    }

    /**
     * Waitset sweeper thread interval.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailboxWaitsetSweepDelay new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2039)
    public void setMailboxWaitsetSweepDelay(String zimbraMailboxWaitsetSweepDelay) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetSweepDelay, zimbraMailboxWaitsetSweepDelay);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Waitset sweeper thread interval.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailboxWaitsetSweepDelay new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2039)
    public Map<String,Object> setMailboxWaitsetSweepDelay(String zimbraMailboxWaitsetSweepDelay, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetSweepDelay, zimbraMailboxWaitsetSweepDelay);
        return attrs;
    }

    /**
     * Waitset sweeper thread interval.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2039)
    public void unsetMailboxWaitsetSweepDelay() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetSweepDelay, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Waitset sweeper thread interval.. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2039)
    public Map<String,Object> unsetMailboxWaitsetSweepDelay(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxWaitsetSweepDelay, "");
        return attrs;
    }

    /**
     * List of SSL/TLS protocols (as documented by SunJSSE Provider Protocols
     * and used in setEnabledProtocols) to be enabled in Jetty for HTTPS,
     * IMAPS, POP3S, and STARTTLS (including LMTP)
     *
     * @return zimbraMailboxdSSLProtocols, or empty array if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1657)
    public String[] getMailboxdSSLProtocols() {
        return getMultiAttr(Provisioning.A_zimbraMailboxdSSLProtocols);
    }

    /**
     * List of SSL/TLS protocols (as documented by SunJSSE Provider Protocols
     * and used in setEnabledProtocols) to be enabled in Jetty for HTTPS,
     * IMAPS, POP3S, and STARTTLS (including LMTP)
     *
     * @param zimbraMailboxdSSLProtocols new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1657)
    public void setMailboxdSSLProtocols(String[] zimbraMailboxdSSLProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdSSLProtocols, zimbraMailboxdSSLProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of SSL/TLS protocols (as documented by SunJSSE Provider Protocols
     * and used in setEnabledProtocols) to be enabled in Jetty for HTTPS,
     * IMAPS, POP3S, and STARTTLS (including LMTP)
     *
     * @param zimbraMailboxdSSLProtocols new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1657)
    public Map<String,Object> setMailboxdSSLProtocols(String[] zimbraMailboxdSSLProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdSSLProtocols, zimbraMailboxdSSLProtocols);
        return attrs;
    }

    /**
     * List of SSL/TLS protocols (as documented by SunJSSE Provider Protocols
     * and used in setEnabledProtocols) to be enabled in Jetty for HTTPS,
     * IMAPS, POP3S, and STARTTLS (including LMTP)
     *
     * @param zimbraMailboxdSSLProtocols new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1657)
    public void addMailboxdSSLProtocols(String zimbraMailboxdSSLProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailboxdSSLProtocols, zimbraMailboxdSSLProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of SSL/TLS protocols (as documented by SunJSSE Provider Protocols
     * and used in setEnabledProtocols) to be enabled in Jetty for HTTPS,
     * IMAPS, POP3S, and STARTTLS (including LMTP)
     *
     * @param zimbraMailboxdSSLProtocols new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1657)
    public Map<String,Object> addMailboxdSSLProtocols(String zimbraMailboxdSSLProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailboxdSSLProtocols, zimbraMailboxdSSLProtocols);
        return attrs;
    }

    /**
     * List of SSL/TLS protocols (as documented by SunJSSE Provider Protocols
     * and used in setEnabledProtocols) to be enabled in Jetty for HTTPS,
     * IMAPS, POP3S, and STARTTLS (including LMTP)
     *
     * @param zimbraMailboxdSSLProtocols existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1657)
    public void removeMailboxdSSLProtocols(String zimbraMailboxdSSLProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailboxdSSLProtocols, zimbraMailboxdSSLProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of SSL/TLS protocols (as documented by SunJSSE Provider Protocols
     * and used in setEnabledProtocols) to be enabled in Jetty for HTTPS,
     * IMAPS, POP3S, and STARTTLS (including LMTP)
     *
     * @param zimbraMailboxdSSLProtocols existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1657)
    public Map<String,Object> removeMailboxdSSLProtocols(String zimbraMailboxdSSLProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailboxdSSLProtocols, zimbraMailboxdSSLProtocols);
        return attrs;
    }

    /**
     * List of SSL/TLS protocols (as documented by SunJSSE Provider Protocols
     * and used in setEnabledProtocols) to be enabled in Jetty for HTTPS,
     * IMAPS, POP3S, and STARTTLS (including LMTP)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1657)
    public void unsetMailboxdSSLProtocols() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdSSLProtocols, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of SSL/TLS protocols (as documented by SunJSSE Provider Protocols
     * and used in setEnabledProtocols) to be enabled in Jetty for HTTPS,
     * IMAPS, POP3S, and STARTTLS (including LMTP)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1657)
    public Map<String,Object> unsetMailboxdSSLProtocols(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdSSLProtocols, "");
        return attrs;
    }

    /**
     * Whether TLS renegotiation is allowed. See also RFC 5746 and
     * CVE-2011-1473 for concerns about possible SSL renegotiation DoS
     *
     * @return zimbraMailboxdSSLRenegotiationAllowed, or false if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1832)
    public boolean isMailboxdSSLRenegotiationAllowed() {
        return getBooleanAttr(Provisioning.A_zimbraMailboxdSSLRenegotiationAllowed, false);
    }

    /**
     * Whether TLS renegotiation is allowed. See also RFC 5746 and
     * CVE-2011-1473 for concerns about possible SSL renegotiation DoS
     *
     * @param zimbraMailboxdSSLRenegotiationAllowed new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1832)
    public void setMailboxdSSLRenegotiationAllowed(boolean zimbraMailboxdSSLRenegotiationAllowed) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdSSLRenegotiationAllowed, zimbraMailboxdSSLRenegotiationAllowed ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether TLS renegotiation is allowed. See also RFC 5746 and
     * CVE-2011-1473 for concerns about possible SSL renegotiation DoS
     *
     * @param zimbraMailboxdSSLRenegotiationAllowed new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1832)
    public Map<String,Object> setMailboxdSSLRenegotiationAllowed(boolean zimbraMailboxdSSLRenegotiationAllowed, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdSSLRenegotiationAllowed, zimbraMailboxdSSLRenegotiationAllowed ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether TLS renegotiation is allowed. See also RFC 5746 and
     * CVE-2011-1473 for concerns about possible SSL renegotiation DoS
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1832)
    public void unsetMailboxdSSLRenegotiationAllowed() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdSSLRenegotiationAllowed, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether TLS renegotiation is allowed. See also RFC 5746 and
     * CVE-2011-1473 for concerns about possible SSL renegotiation DoS
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1832)
    public Map<String,Object> unsetMailboxdSSLRenegotiationAllowed(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdSSLRenegotiationAllowed, "");
        return attrs;
    }

    /**
     * Whether to invoke mount commands during startup, if any have been
     * configured in zmvolume.
     *
     * @return zimbraMailboxdVolumeMountEnabled, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2047)
    public boolean isMailboxdVolumeMountEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMailboxdVolumeMountEnabled, false);
    }

    /**
     * Whether to invoke mount commands during startup, if any have been
     * configured in zmvolume.
     *
     * @param zimbraMailboxdVolumeMountEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2047)
    public void setMailboxdVolumeMountEnabled(boolean zimbraMailboxdVolumeMountEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdVolumeMountEnabled, zimbraMailboxdVolumeMountEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to invoke mount commands during startup, if any have been
     * configured in zmvolume.
     *
     * @param zimbraMailboxdVolumeMountEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2047)
    public Map<String,Object> setMailboxdVolumeMountEnabled(boolean zimbraMailboxdVolumeMountEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdVolumeMountEnabled, zimbraMailboxdVolumeMountEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether to invoke mount commands during startup, if any have been
     * configured in zmvolume.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2047)
    public void unsetMailboxdVolumeMountEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdVolumeMountEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to invoke mount commands during startup, if any have been
     * configured in zmvolume.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2047)
    public Map<String,Object> unsetMailboxdVolumeMountEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdVolumeMountEnabled, "");
        return attrs;
    }

    /**
     * Maximum number of times a server will re-attempt to send a document to
     * an indexing service. When value is higher than 0 and an attempt to
     * index a document fails, server will put the document into the indexing
     * queue for additional indexing attempts.
     *
     * @return zimbraMaxIndexingRetries, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1950)
    public int getMaxIndexingRetries() {
        return getIntAttr(Provisioning.A_zimbraMaxIndexingRetries, -1);
    }

    /**
     * Maximum number of times a server will re-attempt to send a document to
     * an indexing service. When value is higher than 0 and an attempt to
     * index a document fails, server will put the document into the indexing
     * queue for additional indexing attempts.
     *
     * @param zimbraMaxIndexingRetries new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1950)
    public void setMaxIndexingRetries(int zimbraMaxIndexingRetries) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxIndexingRetries, Integer.toString(zimbraMaxIndexingRetries));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of times a server will re-attempt to send a document to
     * an indexing service. When value is higher than 0 and an attempt to
     * index a document fails, server will put the document into the indexing
     * queue for additional indexing attempts.
     *
     * @param zimbraMaxIndexingRetries new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1950)
    public Map<String,Object> setMaxIndexingRetries(int zimbraMaxIndexingRetries, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxIndexingRetries, Integer.toString(zimbraMaxIndexingRetries));
        return attrs;
    }

    /**
     * Maximum number of times a server will re-attempt to send a document to
     * an indexing service. When value is higher than 0 and an attempt to
     * index a document fails, server will put the document into the indexing
     * queue for additional indexing attempts.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1950)
    public void unsetMaxIndexingRetries() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxIndexingRetries, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of times a server will re-attempt to send a document to
     * an indexing service. When value is higher than 0 and an attempt to
     * index a document fails, server will put the document into the indexing
     * queue for additional indexing attempts.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1950)
    public Map<String,Object> unsetMaxIndexingRetries(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxIndexingRetries, "");
        return attrs;
    }

    /**
     * interface address on which memcached server should listen
     *
     * @return zimbraMemcachedBindAddress, or empty array if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=581)
    public String[] getMemcachedBindAddress() {
        return getMultiAttr(Provisioning.A_zimbraMemcachedBindAddress);
    }

    /**
     * interface address on which memcached server should listen
     *
     * @param zimbraMemcachedBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=581)
    public void setMemcachedBindAddress(String[] zimbraMemcachedBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedBindAddress, zimbraMemcachedBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which memcached server should listen
     *
     * @param zimbraMemcachedBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=581)
    public Map<String,Object> setMemcachedBindAddress(String[] zimbraMemcachedBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedBindAddress, zimbraMemcachedBindAddress);
        return attrs;
    }

    /**
     * interface address on which memcached server should listen
     *
     * @param zimbraMemcachedBindAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=581)
    public void addMemcachedBindAddress(String zimbraMemcachedBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMemcachedBindAddress, zimbraMemcachedBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which memcached server should listen
     *
     * @param zimbraMemcachedBindAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=581)
    public Map<String,Object> addMemcachedBindAddress(String zimbraMemcachedBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMemcachedBindAddress, zimbraMemcachedBindAddress);
        return attrs;
    }

    /**
     * interface address on which memcached server should listen
     *
     * @param zimbraMemcachedBindAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=581)
    public void removeMemcachedBindAddress(String zimbraMemcachedBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMemcachedBindAddress, zimbraMemcachedBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which memcached server should listen
     *
     * @param zimbraMemcachedBindAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=581)
    public Map<String,Object> removeMemcachedBindAddress(String zimbraMemcachedBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMemcachedBindAddress, zimbraMemcachedBindAddress);
        return attrs;
    }

    /**
     * interface address on which memcached server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=581)
    public void unsetMemcachedBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which memcached server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=581)
    public Map<String,Object> unsetMemcachedBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedBindAddress, "");
        return attrs;
    }

    /**
     * if true, use binary protocol of memcached; if false, use ascii
     * protocol
     *
     * @return zimbraMemcachedClientBinaryProtocolEnabled, or false if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1015)
    public boolean isMemcachedClientBinaryProtocolEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMemcachedClientBinaryProtocolEnabled, false);
    }

    /**
     * if true, use binary protocol of memcached; if false, use ascii
     * protocol
     *
     * @param zimbraMemcachedClientBinaryProtocolEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1015)
    public void setMemcachedClientBinaryProtocolEnabled(boolean zimbraMemcachedClientBinaryProtocolEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientBinaryProtocolEnabled, zimbraMemcachedClientBinaryProtocolEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, use binary protocol of memcached; if false, use ascii
     * protocol
     *
     * @param zimbraMemcachedClientBinaryProtocolEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1015)
    public Map<String,Object> setMemcachedClientBinaryProtocolEnabled(boolean zimbraMemcachedClientBinaryProtocolEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientBinaryProtocolEnabled, zimbraMemcachedClientBinaryProtocolEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * if true, use binary protocol of memcached; if false, use ascii
     * protocol
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1015)
    public void unsetMemcachedClientBinaryProtocolEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientBinaryProtocolEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, use binary protocol of memcached; if false, use ascii
     * protocol
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1015)
    public Map<String,Object> unsetMemcachedClientBinaryProtocolEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientBinaryProtocolEnabled, "");
        return attrs;
    }

    /**
     * default expiration time in seconds for memcached values; default is 1
     * day
     *
     * @return zimbraMemcachedClientExpirySeconds, or -1 if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1017)
    public int getMemcachedClientExpirySeconds() {
        return getIntAttr(Provisioning.A_zimbraMemcachedClientExpirySeconds, -1);
    }

    /**
     * default expiration time in seconds for memcached values; default is 1
     * day
     *
     * @param zimbraMemcachedClientExpirySeconds new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1017)
    public void setMemcachedClientExpirySeconds(int zimbraMemcachedClientExpirySeconds) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientExpirySeconds, Integer.toString(zimbraMemcachedClientExpirySeconds));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default expiration time in seconds for memcached values; default is 1
     * day
     *
     * @param zimbraMemcachedClientExpirySeconds new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1017)
    public Map<String,Object> setMemcachedClientExpirySeconds(int zimbraMemcachedClientExpirySeconds, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientExpirySeconds, Integer.toString(zimbraMemcachedClientExpirySeconds));
        return attrs;
    }

    /**
     * default expiration time in seconds for memcached values; default is 1
     * day
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1017)
    public void unsetMemcachedClientExpirySeconds() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientExpirySeconds, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default expiration time in seconds for memcached values; default is 1
     * day
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1017)
    public Map<String,Object> unsetMemcachedClientExpirySeconds(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientExpirySeconds, "");
        return attrs;
    }

    /**
     * memcached hash algorithm
     *
     * @return zimbraMemcachedClientHashAlgorithm, or null if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1016)
    public String getMemcachedClientHashAlgorithm() {
        return getAttr(Provisioning.A_zimbraMemcachedClientHashAlgorithm, null);
    }

    /**
     * memcached hash algorithm
     *
     * @param zimbraMemcachedClientHashAlgorithm new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1016)
    public void setMemcachedClientHashAlgorithm(String zimbraMemcachedClientHashAlgorithm) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientHashAlgorithm, zimbraMemcachedClientHashAlgorithm);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * memcached hash algorithm
     *
     * @param zimbraMemcachedClientHashAlgorithm new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1016)
    public Map<String,Object> setMemcachedClientHashAlgorithm(String zimbraMemcachedClientHashAlgorithm, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientHashAlgorithm, zimbraMemcachedClientHashAlgorithm);
        return attrs;
    }

    /**
     * memcached hash algorithm
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1016)
    public void unsetMemcachedClientHashAlgorithm() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientHashAlgorithm, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * memcached hash algorithm
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1016)
    public Map<String,Object> unsetMemcachedClientHashAlgorithm(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientHashAlgorithm, "");
        return attrs;
    }

    /**
     * list of host:port for memcached servers; set to empty value to disable
     * the use of memcached
     *
     * @return zimbraMemcachedClientServerList, or empty array if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1014)
    public String[] getMemcachedClientServerList() {
        return getMultiAttr(Provisioning.A_zimbraMemcachedClientServerList);
    }

    /**
     * list of host:port for memcached servers; set to empty value to disable
     * the use of memcached
     *
     * @param zimbraMemcachedClientServerList new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1014)
    public void setMemcachedClientServerList(String[] zimbraMemcachedClientServerList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientServerList, zimbraMemcachedClientServerList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list of host:port for memcached servers; set to empty value to disable
     * the use of memcached
     *
     * @param zimbraMemcachedClientServerList new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1014)
    public Map<String,Object> setMemcachedClientServerList(String[] zimbraMemcachedClientServerList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientServerList, zimbraMemcachedClientServerList);
        return attrs;
    }

    /**
     * list of host:port for memcached servers; set to empty value to disable
     * the use of memcached
     *
     * @param zimbraMemcachedClientServerList new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1014)
    public void addMemcachedClientServerList(String zimbraMemcachedClientServerList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMemcachedClientServerList, zimbraMemcachedClientServerList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list of host:port for memcached servers; set to empty value to disable
     * the use of memcached
     *
     * @param zimbraMemcachedClientServerList new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1014)
    public Map<String,Object> addMemcachedClientServerList(String zimbraMemcachedClientServerList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMemcachedClientServerList, zimbraMemcachedClientServerList);
        return attrs;
    }

    /**
     * list of host:port for memcached servers; set to empty value to disable
     * the use of memcached
     *
     * @param zimbraMemcachedClientServerList existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1014)
    public void removeMemcachedClientServerList(String zimbraMemcachedClientServerList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMemcachedClientServerList, zimbraMemcachedClientServerList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list of host:port for memcached servers; set to empty value to disable
     * the use of memcached
     *
     * @param zimbraMemcachedClientServerList existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1014)
    public Map<String,Object> removeMemcachedClientServerList(String zimbraMemcachedClientServerList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMemcachedClientServerList, zimbraMemcachedClientServerList);
        return attrs;
    }

    /**
     * list of host:port for memcached servers; set to empty value to disable
     * the use of memcached
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1014)
    public void unsetMemcachedClientServerList() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientServerList, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list of host:port for memcached servers; set to empty value to disable
     * the use of memcached
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1014)
    public Map<String,Object> unsetMemcachedClientServerList(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientServerList, "");
        return attrs;
    }

    /**
     * default timeout in milliseconds for async memcached operations
     *
     * @return zimbraMemcachedClientTimeoutMillis, or -1 if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1018)
    public int getMemcachedClientTimeoutMillis() {
        return getIntAttr(Provisioning.A_zimbraMemcachedClientTimeoutMillis, -1);
    }

    /**
     * default timeout in milliseconds for async memcached operations
     *
     * @param zimbraMemcachedClientTimeoutMillis new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1018)
    public void setMemcachedClientTimeoutMillis(int zimbraMemcachedClientTimeoutMillis) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientTimeoutMillis, Integer.toString(zimbraMemcachedClientTimeoutMillis));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default timeout in milliseconds for async memcached operations
     *
     * @param zimbraMemcachedClientTimeoutMillis new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1018)
    public Map<String,Object> setMemcachedClientTimeoutMillis(int zimbraMemcachedClientTimeoutMillis, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientTimeoutMillis, Integer.toString(zimbraMemcachedClientTimeoutMillis));
        return attrs;
    }

    /**
     * default timeout in milliseconds for async memcached operations
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1018)
    public void unsetMemcachedClientTimeoutMillis() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientTimeoutMillis, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default timeout in milliseconds for async memcached operations
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1018)
    public Map<String,Object> unsetMemcachedClientTimeoutMillis(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientTimeoutMillis, "");
        return attrs;
    }

    /**
     * Maximum number of JavaMail MimeMessage objects in the message cache.
     *
     * @return zimbraMessageCacheSize, or -1 if unset
     */
    @ZAttr(id=297)
    public int getMessageCacheSize() {
        return getIntAttr(Provisioning.A_zimbraMessageCacheSize, -1);
    }

    /**
     * Maximum number of JavaMail MimeMessage objects in the message cache.
     *
     * @param zimbraMessageCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=297)
    public void setMessageCacheSize(int zimbraMessageCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageCacheSize, Integer.toString(zimbraMessageCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of JavaMail MimeMessage objects in the message cache.
     *
     * @param zimbraMessageCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=297)
    public Map<String,Object> setMessageCacheSize(int zimbraMessageCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageCacheSize, Integer.toString(zimbraMessageCacheSize));
        return attrs;
    }

    /**
     * Maximum number of JavaMail MimeMessage objects in the message cache.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=297)
    public void unsetMessageCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of JavaMail MimeMessage objects in the message cache.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=297)
    public Map<String,Object> unsetMessageCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageCacheSize, "");
        return attrs;
    }

    /**
     * whether message channel service is enabled on this server
     *
     * @return zimbraMessageChannelEnabled, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1417)
    public boolean isMessageChannelEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMessageChannelEnabled, false);
    }

    /**
     * whether message channel service is enabled on this server
     *
     * @param zimbraMessageChannelEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1417)
    public void setMessageChannelEnabled(boolean zimbraMessageChannelEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageChannelEnabled, zimbraMessageChannelEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether message channel service is enabled on this server
     *
     * @param zimbraMessageChannelEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1417)
    public Map<String,Object> setMessageChannelEnabled(boolean zimbraMessageChannelEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageChannelEnabled, zimbraMessageChannelEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * whether message channel service is enabled on this server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1417)
    public void unsetMessageChannelEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageChannelEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether message channel service is enabled on this server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1417)
    public Map<String,Object> unsetMessageChannelEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageChannelEnabled, "");
        return attrs;
    }

    /**
     * port number on which message channel should listen
     *
     * @return zimbraMessageChannelPort, or -1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1415)
    public int getMessageChannelPort() {
        return getIntAttr(Provisioning.A_zimbraMessageChannelPort, -1);
    }

    /**
     * port number on which message channel should listen
     *
     * @param zimbraMessageChannelPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1415)
    public void setMessageChannelPort(int zimbraMessageChannelPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageChannelPort, Integer.toString(zimbraMessageChannelPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which message channel should listen
     *
     * @param zimbraMessageChannelPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1415)
    public Map<String,Object> setMessageChannelPort(int zimbraMessageChannelPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageChannelPort, Integer.toString(zimbraMessageChannelPort));
        return attrs;
    }

    /**
     * port number on which message channel should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1415)
    public void unsetMessageChannelPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageChannelPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which message channel should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1415)
    public Map<String,Object> unsetMessageChannelPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageChannelPort, "");
        return attrs;
    }

    /**
     * interface address on which milter server should listen; if not
     * specified, binds to 127.0.0.1
     *
     * @return zimbraMilterBindAddress, or empty array if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1115)
    public String[] getMilterBindAddress() {
        return getMultiAttr(Provisioning.A_zimbraMilterBindAddress);
    }

    /**
     * interface address on which milter server should listen; if not
     * specified, binds to 127.0.0.1
     *
     * @param zimbraMilterBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1115)
    public void setMilterBindAddress(String[] zimbraMilterBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterBindAddress, zimbraMilterBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which milter server should listen; if not
     * specified, binds to 127.0.0.1
     *
     * @param zimbraMilterBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1115)
    public Map<String,Object> setMilterBindAddress(String[] zimbraMilterBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterBindAddress, zimbraMilterBindAddress);
        return attrs;
    }

    /**
     * interface address on which milter server should listen; if not
     * specified, binds to 127.0.0.1
     *
     * @param zimbraMilterBindAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1115)
    public void addMilterBindAddress(String zimbraMilterBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMilterBindAddress, zimbraMilterBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which milter server should listen; if not
     * specified, binds to 127.0.0.1
     *
     * @param zimbraMilterBindAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1115)
    public Map<String,Object> addMilterBindAddress(String zimbraMilterBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMilterBindAddress, zimbraMilterBindAddress);
        return attrs;
    }

    /**
     * interface address on which milter server should listen; if not
     * specified, binds to 127.0.0.1
     *
     * @param zimbraMilterBindAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1115)
    public void removeMilterBindAddress(String zimbraMilterBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMilterBindAddress, zimbraMilterBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which milter server should listen; if not
     * specified, binds to 127.0.0.1
     *
     * @param zimbraMilterBindAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1115)
    public Map<String,Object> removeMilterBindAddress(String zimbraMilterBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMilterBindAddress, zimbraMilterBindAddress);
        return attrs;
    }

    /**
     * interface address on which milter server should listen; if not
     * specified, binds to 127.0.0.1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1115)
    public void unsetMilterBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which milter server should listen; if not
     * specified, binds to 127.0.0.1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1115)
    public Map<String,Object> unsetMilterBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterBindAddress, "");
        return attrs;
    }

    /**
     * port number on which milter server should listen
     *
     * <p>Use getMilterBindPortAsString to access value as a string.
     *
     * @see #getMilterBindPortAsString()
     *
     * @return zimbraMilterBindPort, or -1 if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1114)
    public int getMilterBindPort() {
        return getIntAttr(Provisioning.A_zimbraMilterBindPort, -1);
    }

    /**
     * port number on which milter server should listen
     *
     * @return zimbraMilterBindPort, or null if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1114)
    public String getMilterBindPortAsString() {
        return getAttr(Provisioning.A_zimbraMilterBindPort, null);
    }

    /**
     * port number on which milter server should listen
     *
     * @param zimbraMilterBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1114)
    public void setMilterBindPort(int zimbraMilterBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterBindPort, Integer.toString(zimbraMilterBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which milter server should listen
     *
     * @param zimbraMilterBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1114)
    public Map<String,Object> setMilterBindPort(int zimbraMilterBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterBindPort, Integer.toString(zimbraMilterBindPort));
        return attrs;
    }

    /**
     * port number on which milter server should listen
     *
     * @param zimbraMilterBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1114)
    public void setMilterBindPortAsString(String zimbraMilterBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterBindPort, zimbraMilterBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which milter server should listen
     *
     * @param zimbraMilterBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1114)
    public Map<String,Object> setMilterBindPortAsString(String zimbraMilterBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterBindPort, zimbraMilterBindPort);
        return attrs;
    }

    /**
     * port number on which milter server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1114)
    public void unsetMilterBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which milter server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1114)
    public Map<String,Object> unsetMilterBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterBindPort, "");
        return attrs;
    }

    /**
     * Maximum number of concurrent MILTER connections allowed. New
     * connections exceeding this limit are rejected.
     *
     * @return zimbraMilterMaxConnections, or -1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1157)
    public int getMilterMaxConnections() {
        return getIntAttr(Provisioning.A_zimbraMilterMaxConnections, -1);
    }

    /**
     * Maximum number of concurrent MILTER connections allowed. New
     * connections exceeding this limit are rejected.
     *
     * @param zimbraMilterMaxConnections new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1157)
    public void setMilterMaxConnections(int zimbraMilterMaxConnections) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterMaxConnections, Integer.toString(zimbraMilterMaxConnections));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of concurrent MILTER connections allowed. New
     * connections exceeding this limit are rejected.
     *
     * @param zimbraMilterMaxConnections new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1157)
    public Map<String,Object> setMilterMaxConnections(int zimbraMilterMaxConnections, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterMaxConnections, Integer.toString(zimbraMilterMaxConnections));
        return attrs;
    }

    /**
     * Maximum number of concurrent MILTER connections allowed. New
     * connections exceeding this limit are rejected.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1157)
    public void unsetMilterMaxConnections() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterMaxConnections, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of concurrent MILTER connections allowed. New
     * connections exceeding this limit are rejected.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1157)
    public Map<String,Object> unsetMilterMaxConnections(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterMaxConnections, "");
        return attrs;
    }

    /**
     * Milter server drops client connection which are inactive for more than
     * zimbraMilterMaxIdleTIme seconds. postfix 2.11 has 2 timeouts which
     * affect whether to accept a message when DATA is coming slowly from the
     * remote system. One is every 300s (smtpd_timeout?) which fires when not
     * data arrives for that time.The other gets noticed once all data has
     * been read if more than 3600s (ipc_timeout?) has passed since the
     * connection was initiated and results in &#039;451 4.3.0 Error: queue
     * file write error&#039;.Commands are sent to milter for &quot;mail
     * from&quot; and &quot;rcpt to&quot; entries, then potentially no
     * further communication is made until all data for the message has been
     * read, so milter_max_idle_time needs to be long enough for that. The
     * value of milter_max_idle_time is to ensure we drop the connection if
     * there is a problem at the MTA end - hence the default value is
     * slightly longer than the max time the MTA should need. . Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getMilterMaxIdleTimeAsString to access value as a string.
     *
     * @see #getMilterMaxIdleTimeAsString()
     *
     * @return zimbraMilterMaxIdleTime in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1769)
    public long getMilterMaxIdleTime() {
        return getTimeInterval(Provisioning.A_zimbraMilterMaxIdleTime, -1L);
    }

    /**
     * Milter server drops client connection which are inactive for more than
     * zimbraMilterMaxIdleTIme seconds. postfix 2.11 has 2 timeouts which
     * affect whether to accept a message when DATA is coming slowly from the
     * remote system. One is every 300s (smtpd_timeout?) which fires when not
     * data arrives for that time.The other gets noticed once all data has
     * been read if more than 3600s (ipc_timeout?) has passed since the
     * connection was initiated and results in &#039;451 4.3.0 Error: queue
     * file write error&#039;.Commands are sent to milter for &quot;mail
     * from&quot; and &quot;rcpt to&quot; entries, then potentially no
     * further communication is made until all data for the message has been
     * read, so milter_max_idle_time needs to be long enough for that. The
     * value of milter_max_idle_time is to ensure we drop the connection if
     * there is a problem at the MTA end - hence the default value is
     * slightly longer than the max time the MTA should need. . Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraMilterMaxIdleTime, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1769)
    public String getMilterMaxIdleTimeAsString() {
        return getAttr(Provisioning.A_zimbraMilterMaxIdleTime, null);
    }

    /**
     * Milter server drops client connection which are inactive for more than
     * zimbraMilterMaxIdleTIme seconds. postfix 2.11 has 2 timeouts which
     * affect whether to accept a message when DATA is coming slowly from the
     * remote system. One is every 300s (smtpd_timeout?) which fires when not
     * data arrives for that time.The other gets noticed once all data has
     * been read if more than 3600s (ipc_timeout?) has passed since the
     * connection was initiated and results in &#039;451 4.3.0 Error: queue
     * file write error&#039;.Commands are sent to milter for &quot;mail
     * from&quot; and &quot;rcpt to&quot; entries, then potentially no
     * further communication is made until all data for the message has been
     * read, so milter_max_idle_time needs to be long enough for that. The
     * value of milter_max_idle_time is to ensure we drop the connection if
     * there is a problem at the MTA end - hence the default value is
     * slightly longer than the max time the MTA should need. . Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMilterMaxIdleTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1769)
    public void setMilterMaxIdleTime(String zimbraMilterMaxIdleTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterMaxIdleTime, zimbraMilterMaxIdleTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Milter server drops client connection which are inactive for more than
     * zimbraMilterMaxIdleTIme seconds. postfix 2.11 has 2 timeouts which
     * affect whether to accept a message when DATA is coming slowly from the
     * remote system. One is every 300s (smtpd_timeout?) which fires when not
     * data arrives for that time.The other gets noticed once all data has
     * been read if more than 3600s (ipc_timeout?) has passed since the
     * connection was initiated and results in &#039;451 4.3.0 Error: queue
     * file write error&#039;.Commands are sent to milter for &quot;mail
     * from&quot; and &quot;rcpt to&quot; entries, then potentially no
     * further communication is made until all data for the message has been
     * read, so milter_max_idle_time needs to be long enough for that. The
     * value of milter_max_idle_time is to ensure we drop the connection if
     * there is a problem at the MTA end - hence the default value is
     * slightly longer than the max time the MTA should need. . Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMilterMaxIdleTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1769)
    public Map<String,Object> setMilterMaxIdleTime(String zimbraMilterMaxIdleTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterMaxIdleTime, zimbraMilterMaxIdleTime);
        return attrs;
    }

    /**
     * Milter server drops client connection which are inactive for more than
     * zimbraMilterMaxIdleTIme seconds. postfix 2.11 has 2 timeouts which
     * affect whether to accept a message when DATA is coming slowly from the
     * remote system. One is every 300s (smtpd_timeout?) which fires when not
     * data arrives for that time.The other gets noticed once all data has
     * been read if more than 3600s (ipc_timeout?) has passed since the
     * connection was initiated and results in &#039;451 4.3.0 Error: queue
     * file write error&#039;.Commands are sent to milter for &quot;mail
     * from&quot; and &quot;rcpt to&quot; entries, then potentially no
     * further communication is made until all data for the message has been
     * read, so milter_max_idle_time needs to be long enough for that. The
     * value of milter_max_idle_time is to ensure we drop the connection if
     * there is a problem at the MTA end - hence the default value is
     * slightly longer than the max time the MTA should need. . Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1769)
    public void unsetMilterMaxIdleTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterMaxIdleTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Milter server drops client connection which are inactive for more than
     * zimbraMilterMaxIdleTIme seconds. postfix 2.11 has 2 timeouts which
     * affect whether to accept a message when DATA is coming slowly from the
     * remote system. One is every 300s (smtpd_timeout?) which fires when not
     * data arrives for that time.The other gets noticed once all data has
     * been read if more than 3600s (ipc_timeout?) has passed since the
     * connection was initiated and results in &#039;451 4.3.0 Error: queue
     * file write error&#039;.Commands are sent to milter for &quot;mail
     * from&quot; and &quot;rcpt to&quot; entries, then potentially no
     * further communication is made until all data for the message has been
     * read, so milter_max_idle_time needs to be long enough for that. The
     * value of milter_max_idle_time is to ensure we drop the connection if
     * there is a problem at the MTA end - hence the default value is
     * slightly longer than the max time the MTA should need. . Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1769)
    public Map<String,Object> unsetMilterMaxIdleTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterMaxIdleTime, "");
        return attrs;
    }

    /**
     * number of milter handler threads
     *
     * @return zimbraMilterNumThreads, or -1 if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1144)
    public int getMilterNumThreads() {
        return getIntAttr(Provisioning.A_zimbraMilterNumThreads, -1);
    }

    /**
     * number of milter handler threads
     *
     * @param zimbraMilterNumThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1144)
    public void setMilterNumThreads(int zimbraMilterNumThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterNumThreads, Integer.toString(zimbraMilterNumThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of milter handler threads
     *
     * @param zimbraMilterNumThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1144)
    public Map<String,Object> setMilterNumThreads(int zimbraMilterNumThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterNumThreads, Integer.toString(zimbraMilterNumThreads));
        return attrs;
    }

    /**
     * number of milter handler threads
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1144)
    public void unsetMilterNumThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterNumThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of milter handler threads
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1144)
    public Map<String,Object> unsetMilterNumThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterNumThreads, "");
        return attrs;
    }

    /**
     * Milter server keep alive time in seconds for threads in threadpool.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getMilterThreadKeepAliveTimeAsString to access value as a string.
     *
     * @see #getMilterThreadKeepAliveTimeAsString()
     *
     * @return zimbraMilterThreadKeepAliveTime in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1770)
    public long getMilterThreadKeepAliveTime() {
        return getTimeInterval(Provisioning.A_zimbraMilterThreadKeepAliveTime, -1L);
    }

    /**
     * Milter server keep alive time in seconds for threads in threadpool.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraMilterThreadKeepAliveTime, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1770)
    public String getMilterThreadKeepAliveTimeAsString() {
        return getAttr(Provisioning.A_zimbraMilterThreadKeepAliveTime, null);
    }

    /**
     * Milter server keep alive time in seconds for threads in threadpool.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMilterThreadKeepAliveTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1770)
    public void setMilterThreadKeepAliveTime(String zimbraMilterThreadKeepAliveTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterThreadKeepAliveTime, zimbraMilterThreadKeepAliveTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Milter server keep alive time in seconds for threads in threadpool.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMilterThreadKeepAliveTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1770)
    public Map<String,Object> setMilterThreadKeepAliveTime(String zimbraMilterThreadKeepAliveTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterThreadKeepAliveTime, zimbraMilterThreadKeepAliveTime);
        return attrs;
    }

    /**
     * Milter server keep alive time in seconds for threads in threadpool.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1770)
    public void unsetMilterThreadKeepAliveTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterThreadKeepAliveTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Milter server keep alive time in seconds for threads in threadpool.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1770)
    public Map<String,Object> unsetMilterThreadKeepAliveTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterThreadKeepAliveTime, "");
        return attrs;
    }

    /**
     * Write chunk size in bytes for Milter server output stream
     *
     * @return zimbraMilterWriteChunkSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1771)
    public int getMilterWriteChunkSize() {
        return getIntAttr(Provisioning.A_zimbraMilterWriteChunkSize, -1);
    }

    /**
     * Write chunk size in bytes for Milter server output stream
     *
     * @param zimbraMilterWriteChunkSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1771)
    public void setMilterWriteChunkSize(int zimbraMilterWriteChunkSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterWriteChunkSize, Integer.toString(zimbraMilterWriteChunkSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Write chunk size in bytes for Milter server output stream
     *
     * @param zimbraMilterWriteChunkSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1771)
    public Map<String,Object> setMilterWriteChunkSize(int zimbraMilterWriteChunkSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterWriteChunkSize, Integer.toString(zimbraMilterWriteChunkSize));
        return attrs;
    }

    /**
     * Write chunk size in bytes for Milter server output stream
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1771)
    public void unsetMilterWriteChunkSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterWriteChunkSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Write chunk size in bytes for Milter server output stream
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1771)
    public Map<String,Object> unsetMilterWriteChunkSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterWriteChunkSize, "");
        return attrs;
    }

    /**
     * Write timeout in seconds for Milter server output stream. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getMilterWriteTimeoutAsString to access value as a string.
     *
     * @see #getMilterWriteTimeoutAsString()
     *
     * @return zimbraMilterWriteTimeout in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1772)
    public long getMilterWriteTimeout() {
        return getTimeInterval(Provisioning.A_zimbraMilterWriteTimeout, -1L);
    }

    /**
     * Write timeout in seconds for Milter server output stream. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraMilterWriteTimeout, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1772)
    public String getMilterWriteTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraMilterWriteTimeout, null);
    }

    /**
     * Write timeout in seconds for Milter server output stream. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMilterWriteTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1772)
    public void setMilterWriteTimeout(String zimbraMilterWriteTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterWriteTimeout, zimbraMilterWriteTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Write timeout in seconds for Milter server output stream. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMilterWriteTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1772)
    public Map<String,Object> setMilterWriteTimeout(String zimbraMilterWriteTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterWriteTimeout, zimbraMilterWriteTimeout);
        return attrs;
    }

    /**
     * Write timeout in seconds for Milter server output stream. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1772)
    public void unsetMilterWriteTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterWriteTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Write timeout in seconds for Milter server output stream. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1772)
    public Map<String,Object> unsetMilterWriteTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterWriteTimeout, "");
        return attrs;
    }

    /**
     * Whether the UUENCODE decoder is run when parsing messages from the
     * store
     *
     * @return zimbraMimeConverterEnableUuencode, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1899)
    public boolean isMimeConverterEnableUuencode() {
        return getBooleanAttr(Provisioning.A_zimbraMimeConverterEnableUuencode, false);
    }

    /**
     * Whether the UUENCODE decoder is run when parsing messages from the
     * store
     *
     * @param zimbraMimeConverterEnableUuencode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1899)
    public void setMimeConverterEnableUuencode(boolean zimbraMimeConverterEnableUuencode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeConverterEnableUuencode, zimbraMimeConverterEnableUuencode ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether the UUENCODE decoder is run when parsing messages from the
     * store
     *
     * @param zimbraMimeConverterEnableUuencode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1899)
    public Map<String,Object> setMimeConverterEnableUuencode(boolean zimbraMimeConverterEnableUuencode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeConverterEnableUuencode, zimbraMimeConverterEnableUuencode ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether the UUENCODE decoder is run when parsing messages from the
     * store
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1899)
    public void unsetMimeConverterEnableUuencode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeConverterEnableUuencode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether the UUENCODE decoder is run when parsing messages from the
     * store
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1899)
    public Map<String,Object> unsetMimeConverterEnableUuencode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeConverterEnableUuencode, "");
        return attrs;
    }

    /**
     * Whether the TNEF decoder is run when parsing messages from the store
     *
     * @return zimbraMimeConverterEnabledTnef, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1898)
    public boolean isMimeConverterEnabledTnef() {
        return getBooleanAttr(Provisioning.A_zimbraMimeConverterEnabledTnef, false);
    }

    /**
     * Whether the TNEF decoder is run when parsing messages from the store
     *
     * @param zimbraMimeConverterEnabledTnef new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1898)
    public void setMimeConverterEnabledTnef(boolean zimbraMimeConverterEnabledTnef) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeConverterEnabledTnef, zimbraMimeConverterEnabledTnef ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether the TNEF decoder is run when parsing messages from the store
     *
     * @param zimbraMimeConverterEnabledTnef new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1898)
    public Map<String,Object> setMimeConverterEnabledTnef(boolean zimbraMimeConverterEnabledTnef, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeConverterEnabledTnef, zimbraMimeConverterEnabledTnef ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether the TNEF decoder is run when parsing messages from the store
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1898)
    public void unsetMimeConverterEnabledTnef() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeConverterEnabledTnef, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether the TNEF decoder is run when parsing messages from the store
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1898)
    public Map<String,Object> unsetMimeConverterEnabledTnef(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeConverterEnabledTnef, "");
        return attrs;
    }

    /**
     * Recursive MIME part depth beneath which converters will not act
     *
     * @return zimbraMimeConverterMaxMimepartDepth, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1897)
    public int getMimeConverterMaxMimepartDepth() {
        return getIntAttr(Provisioning.A_zimbraMimeConverterMaxMimepartDepth, -1);
    }

    /**
     * Recursive MIME part depth beneath which converters will not act
     *
     * @param zimbraMimeConverterMaxMimepartDepth new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1897)
    public void setMimeConverterMaxMimepartDepth(int zimbraMimeConverterMaxMimepartDepth) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeConverterMaxMimepartDepth, Integer.toString(zimbraMimeConverterMaxMimepartDepth));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Recursive MIME part depth beneath which converters will not act
     *
     * @param zimbraMimeConverterMaxMimepartDepth new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1897)
    public Map<String,Object> setMimeConverterMaxMimepartDepth(int zimbraMimeConverterMaxMimepartDepth, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeConverterMaxMimepartDepth, Integer.toString(zimbraMimeConverterMaxMimepartDepth));
        return attrs;
    }

    /**
     * Recursive MIME part depth beneath which converters will not act
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1897)
    public void unsetMimeConverterMaxMimepartDepth() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeConverterMaxMimepartDepth, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Recursive MIME part depth beneath which converters will not act
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1897)
    public Map<String,Object> unsetMimeConverterMaxMimepartDepth(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeConverterMaxMimepartDepth, "");
        return attrs;
    }

    /**
     * Enable text extraction for the during mime parsing
     *
     * @return zimbraMimeEnableTextExtraction, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1853)
    public boolean isMimeEnableTextExtraction() {
        return getBooleanAttr(Provisioning.A_zimbraMimeEnableTextExtraction, false);
    }

    /**
     * Enable text extraction for the during mime parsing
     *
     * @param zimbraMimeEnableTextExtraction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1853)
    public void setMimeEnableTextExtraction(boolean zimbraMimeEnableTextExtraction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeEnableTextExtraction, zimbraMimeEnableTextExtraction ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable text extraction for the during mime parsing
     *
     * @param zimbraMimeEnableTextExtraction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1853)
    public Map<String,Object> setMimeEnableTextExtraction(boolean zimbraMimeEnableTextExtraction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeEnableTextExtraction, zimbraMimeEnableTextExtraction ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Enable text extraction for the during mime parsing
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1853)
    public void unsetMimeEnableTextExtraction() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeEnableTextExtraction, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable text extraction for the during mime parsing
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1853)
    public Map<String,Object> unsetMimeEnableTextExtraction(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeEnableTextExtraction, "");
        return attrs;
    }

    /**
     * Flag to enable or disable encoding the missing blob in mime part
     *
     * @return zimbraMimeEncodeMissingBlob, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1763)
    public boolean isMimeEncodeMissingBlob() {
        return getBooleanAttr(Provisioning.A_zimbraMimeEncodeMissingBlob, false);
    }

    /**
     * Flag to enable or disable encoding the missing blob in mime part
     *
     * @param zimbraMimeEncodeMissingBlob new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1763)
    public void setMimeEncodeMissingBlob(boolean zimbraMimeEncodeMissingBlob) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeEncodeMissingBlob, zimbraMimeEncodeMissingBlob ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable or disable encoding the missing blob in mime part
     *
     * @param zimbraMimeEncodeMissingBlob new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1763)
    public Map<String,Object> setMimeEncodeMissingBlob(boolean zimbraMimeEncodeMissingBlob, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeEncodeMissingBlob, zimbraMimeEncodeMissingBlob ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to enable or disable encoding the missing blob in mime part
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1763)
    public void unsetMimeEncodeMissingBlob() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeEncodeMissingBlob, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable or disable encoding the missing blob in mime part
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1763)
    public Map<String,Object> unsetMimeEncodeMissingBlob(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeEncodeMissingBlob, "");
        return attrs;
    }

    /**
     * Flag to disable empty content in mime message
     *
     * @return zimbraMimeExcludeEmptyContent, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1764)
    public boolean isMimeExcludeEmptyContent() {
        return getBooleanAttr(Provisioning.A_zimbraMimeExcludeEmptyContent, false);
    }

    /**
     * Flag to disable empty content in mime message
     *
     * @param zimbraMimeExcludeEmptyContent new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1764)
    public void setMimeExcludeEmptyContent(boolean zimbraMimeExcludeEmptyContent) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeExcludeEmptyContent, zimbraMimeExcludeEmptyContent ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to disable empty content in mime message
     *
     * @param zimbraMimeExcludeEmptyContent new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1764)
    public Map<String,Object> setMimeExcludeEmptyContent(boolean zimbraMimeExcludeEmptyContent, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeExcludeEmptyContent, zimbraMimeExcludeEmptyContent ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to disable empty content in mime message
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1764)
    public void unsetMimeExcludeEmptyContent() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeExcludeEmptyContent, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to disable empty content in mime message
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1764)
    public Map<String,Object> unsetMimeExcludeEmptyContent(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeExcludeEmptyContent, "");
        return attrs;
    }

    /**
     * Maximum image size in bytes to resize
     *
     * @return zimbraMimeMaxImageSizeToResize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1801)
    public int getMimeMaxImageSizeToResize() {
        return getIntAttr(Provisioning.A_zimbraMimeMaxImageSizeToResize, -1);
    }

    /**
     * Maximum image size in bytes to resize
     *
     * @param zimbraMimeMaxImageSizeToResize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1801)
    public void setMimeMaxImageSizeToResize(int zimbraMimeMaxImageSizeToResize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeMaxImageSizeToResize, Integer.toString(zimbraMimeMaxImageSizeToResize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum image size in bytes to resize
     *
     * @param zimbraMimeMaxImageSizeToResize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1801)
    public Map<String,Object> setMimeMaxImageSizeToResize(int zimbraMimeMaxImageSizeToResize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeMaxImageSizeToResize, Integer.toString(zimbraMimeMaxImageSizeToResize));
        return attrs;
    }

    /**
     * Maximum image size in bytes to resize
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1801)
    public void unsetMimeMaxImageSizeToResize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeMaxImageSizeToResize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum image size in bytes to resize
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1801)
    public Map<String,Object> unsetMimeMaxImageSizeToResize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeMaxImageSizeToResize, "");
        return attrs;
    }

    /**
     * If true, always encode text attachments as base64
     *
     * @return zimbraMimeOverrideDefaultTransferEncodingToBase64, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1894)
    public boolean isMimeOverrideDefaultTransferEncodingToBase64() {
        return getBooleanAttr(Provisioning.A_zimbraMimeOverrideDefaultTransferEncodingToBase64, false);
    }

    /**
     * If true, always encode text attachments as base64
     *
     * @param zimbraMimeOverrideDefaultTransferEncodingToBase64 new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1894)
    public void setMimeOverrideDefaultTransferEncodingToBase64(boolean zimbraMimeOverrideDefaultTransferEncodingToBase64) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeOverrideDefaultTransferEncodingToBase64, zimbraMimeOverrideDefaultTransferEncodingToBase64 ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If true, always encode text attachments as base64
     *
     * @param zimbraMimeOverrideDefaultTransferEncodingToBase64 new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1894)
    public Map<String,Object> setMimeOverrideDefaultTransferEncodingToBase64(boolean zimbraMimeOverrideDefaultTransferEncodingToBase64, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeOverrideDefaultTransferEncodingToBase64, zimbraMimeOverrideDefaultTransferEncodingToBase64 ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * If true, always encode text attachments as base64
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1894)
    public void unsetMimeOverrideDefaultTransferEncodingToBase64() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeOverrideDefaultTransferEncodingToBase64, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If true, always encode text attachments as base64
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1894)
    public Map<String,Object> unsetMimeOverrideDefaultTransferEncodingToBase64(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMimeOverrideDefaultTransferEncodingToBase64, "");
        return attrs;
    }

    /**
     * Maximum total size of a mail message that can be synced to device
     * without truncation. It cannot be larger than zimbraMTAMaxMessageSize.
     * 0 means zimbraMTAMaxMessageSize or INTEGER_MAX, whichever is smaller
     *
     * @return zimbraMobileMaxMessageSize, or -1 if unset
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1596)
    public int getMobileMaxMessageSize() {
        return getIntAttr(Provisioning.A_zimbraMobileMaxMessageSize, -1);
    }

    /**
     * Maximum total size of a mail message that can be synced to device
     * without truncation. It cannot be larger than zimbraMTAMaxMessageSize.
     * 0 means zimbraMTAMaxMessageSize or INTEGER_MAX, whichever is smaller
     *
     * @param zimbraMobileMaxMessageSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1596)
    public void setMobileMaxMessageSize(int zimbraMobileMaxMessageSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMaxMessageSize, Integer.toString(zimbraMobileMaxMessageSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum total size of a mail message that can be synced to device
     * without truncation. It cannot be larger than zimbraMTAMaxMessageSize.
     * 0 means zimbraMTAMaxMessageSize or INTEGER_MAX, whichever is smaller
     *
     * @param zimbraMobileMaxMessageSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1596)
    public Map<String,Object> setMobileMaxMessageSize(int zimbraMobileMaxMessageSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMaxMessageSize, Integer.toString(zimbraMobileMaxMessageSize));
        return attrs;
    }

    /**
     * Maximum total size of a mail message that can be synced to device
     * without truncation. It cannot be larger than zimbraMTAMaxMessageSize.
     * 0 means zimbraMTAMaxMessageSize or INTEGER_MAX, whichever is smaller
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1596)
    public void unsetMobileMaxMessageSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMaxMessageSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum total size of a mail message that can be synced to device
     * without truncation. It cannot be larger than zimbraMTAMaxMessageSize.
     * 0 means zimbraMTAMaxMessageSize or INTEGER_MAX, whichever is smaller
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1596)
    public Map<String,Object> unsetMobileMaxMessageSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMaxMessageSize, "");
        return attrs;
    }

    /**
     * Retention policy for stale mobile metadata. Format is
     * &quot;aa:bb:c&quot;, &quot;aa&quot; being the number of days to define
     * stale data. e.g. 180 means if device&#039;s last_used_date is 180 days
     * ago, its metadata need to be removed. &quot;bb&quot; being the days
     * between two retentions are run, e.g. 30 means to run retention every
     * 30 days. &quot;hh&quot; being the hour of day to run retention, from 0
     * to 23. e.g. 1 means to run retention at some time between 1am and 2am.
     *
     * @return zimbraMobileMetadataRetentionPolicy, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1617)
    public String getMobileMetadataRetentionPolicy() {
        return getAttr(Provisioning.A_zimbraMobileMetadataRetentionPolicy, null);
    }

    /**
     * Retention policy for stale mobile metadata. Format is
     * &quot;aa:bb:c&quot;, &quot;aa&quot; being the number of days to define
     * stale data. e.g. 180 means if device&#039;s last_used_date is 180 days
     * ago, its metadata need to be removed. &quot;bb&quot; being the days
     * between two retentions are run, e.g. 30 means to run retention every
     * 30 days. &quot;hh&quot; being the hour of day to run retention, from 0
     * to 23. e.g. 1 means to run retention at some time between 1am and 2am.
     *
     * @param zimbraMobileMetadataRetentionPolicy new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1617)
    public void setMobileMetadataRetentionPolicy(String zimbraMobileMetadataRetentionPolicy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMetadataRetentionPolicy, zimbraMobileMetadataRetentionPolicy);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention policy for stale mobile metadata. Format is
     * &quot;aa:bb:c&quot;, &quot;aa&quot; being the number of days to define
     * stale data. e.g. 180 means if device&#039;s last_used_date is 180 days
     * ago, its metadata need to be removed. &quot;bb&quot; being the days
     * between two retentions are run, e.g. 30 means to run retention every
     * 30 days. &quot;hh&quot; being the hour of day to run retention, from 0
     * to 23. e.g. 1 means to run retention at some time between 1am and 2am.
     *
     * @param zimbraMobileMetadataRetentionPolicy new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1617)
    public Map<String,Object> setMobileMetadataRetentionPolicy(String zimbraMobileMetadataRetentionPolicy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMetadataRetentionPolicy, zimbraMobileMetadataRetentionPolicy);
        return attrs;
    }

    /**
     * Retention policy for stale mobile metadata. Format is
     * &quot;aa:bb:c&quot;, &quot;aa&quot; being the number of days to define
     * stale data. e.g. 180 means if device&#039;s last_used_date is 180 days
     * ago, its metadata need to be removed. &quot;bb&quot; being the days
     * between two retentions are run, e.g. 30 means to run retention every
     * 30 days. &quot;hh&quot; being the hour of day to run retention, from 0
     * to 23. e.g. 1 means to run retention at some time between 1am and 2am.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1617)
    public void unsetMobileMetadataRetentionPolicy() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMetadataRetentionPolicy, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention policy for stale mobile metadata. Format is
     * &quot;aa:bb:c&quot;, &quot;aa&quot; being the number of days to define
     * stale data. e.g. 180 means if device&#039;s last_used_date is 180 days
     * ago, its metadata need to be removed. &quot;bb&quot; being the days
     * between two retentions are run, e.g. 30 means to run retention every
     * 30 days. &quot;hh&quot; being the hour of day to run retention, from 0
     * to 23. e.g. 1 means to run retention at some time between 1am and 2am.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1617)
    public Map<String,Object> unsetMobileMetadataRetentionPolicy(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMetadataRetentionPolicy, "");
        return attrs;
    }

    /**
     * Value for postconf address_verify_negative_refresh_time
     *
     * @return zimbraMtaAddressVerifyNegativeRefreshTime, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1609)
    public String getMtaAddressVerifyNegativeRefreshTime() {
        return getAttr(Provisioning.A_zimbraMtaAddressVerifyNegativeRefreshTime, null);
    }

    /**
     * Value for postconf address_verify_negative_refresh_time
     *
     * @param zimbraMtaAddressVerifyNegativeRefreshTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1609)
    public void setMtaAddressVerifyNegativeRefreshTime(String zimbraMtaAddressVerifyNegativeRefreshTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyNegativeRefreshTime, zimbraMtaAddressVerifyNegativeRefreshTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf address_verify_negative_refresh_time
     *
     * @param zimbraMtaAddressVerifyNegativeRefreshTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1609)
    public Map<String,Object> setMtaAddressVerifyNegativeRefreshTime(String zimbraMtaAddressVerifyNegativeRefreshTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyNegativeRefreshTime, zimbraMtaAddressVerifyNegativeRefreshTime);
        return attrs;
    }

    /**
     * Value for postconf address_verify_negative_refresh_time
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1609)
    public void unsetMtaAddressVerifyNegativeRefreshTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyNegativeRefreshTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf address_verify_negative_refresh_time
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1609)
    public Map<String,Object> unsetMtaAddressVerifyNegativeRefreshTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyNegativeRefreshTime, "");
        return attrs;
    }

    /**
     * Value for postconf address_verify_poll_count
     *
     * @return zimbraMtaAddressVerifyPollCount, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1607)
    public String getMtaAddressVerifyPollCount() {
        return getAttr(Provisioning.A_zimbraMtaAddressVerifyPollCount, null);
    }

    /**
     * Value for postconf address_verify_poll_count
     *
     * @param zimbraMtaAddressVerifyPollCount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1607)
    public void setMtaAddressVerifyPollCount(String zimbraMtaAddressVerifyPollCount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPollCount, zimbraMtaAddressVerifyPollCount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf address_verify_poll_count
     *
     * @param zimbraMtaAddressVerifyPollCount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1607)
    public Map<String,Object> setMtaAddressVerifyPollCount(String zimbraMtaAddressVerifyPollCount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPollCount, zimbraMtaAddressVerifyPollCount);
        return attrs;
    }

    /**
     * Value for postconf address_verify_poll_count
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1607)
    public void unsetMtaAddressVerifyPollCount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPollCount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf address_verify_poll_count
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1607)
    public Map<String,Object> unsetMtaAddressVerifyPollCount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPollCount, "");
        return attrs;
    }

    /**
     * Value for postconf address_verify_poll_delay
     *
     * @return zimbraMtaAddressVerifyPollDelay, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1608)
    public String getMtaAddressVerifyPollDelay() {
        return getAttr(Provisioning.A_zimbraMtaAddressVerifyPollDelay, null);
    }

    /**
     * Value for postconf address_verify_poll_delay
     *
     * @param zimbraMtaAddressVerifyPollDelay new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1608)
    public void setMtaAddressVerifyPollDelay(String zimbraMtaAddressVerifyPollDelay) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPollDelay, zimbraMtaAddressVerifyPollDelay);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf address_verify_poll_delay
     *
     * @param zimbraMtaAddressVerifyPollDelay new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1608)
    public Map<String,Object> setMtaAddressVerifyPollDelay(String zimbraMtaAddressVerifyPollDelay, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPollDelay, zimbraMtaAddressVerifyPollDelay);
        return attrs;
    }

    /**
     * Value for postconf address_verify_poll_delay
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1608)
    public void unsetMtaAddressVerifyPollDelay() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPollDelay, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf address_verify_poll_delay
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1608)
    public Map<String,Object> unsetMtaAddressVerifyPollDelay(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPollDelay, "");
        return attrs;
    }

    /**
     * Value for postconf address_verify_positive_refresh_time
     *
     * @return zimbraMtaAddressVerifyPositiveRefreshTime, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1610)
    public String getMtaAddressVerifyPositiveRefreshTime() {
        return getAttr(Provisioning.A_zimbraMtaAddressVerifyPositiveRefreshTime, null);
    }

    /**
     * Value for postconf address_verify_positive_refresh_time
     *
     * @param zimbraMtaAddressVerifyPositiveRefreshTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1610)
    public void setMtaAddressVerifyPositiveRefreshTime(String zimbraMtaAddressVerifyPositiveRefreshTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPositiveRefreshTime, zimbraMtaAddressVerifyPositiveRefreshTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf address_verify_positive_refresh_time
     *
     * @param zimbraMtaAddressVerifyPositiveRefreshTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1610)
    public Map<String,Object> setMtaAddressVerifyPositiveRefreshTime(String zimbraMtaAddressVerifyPositiveRefreshTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPositiveRefreshTime, zimbraMtaAddressVerifyPositiveRefreshTime);
        return attrs;
    }

    /**
     * Value for postconf address_verify_positive_refresh_time
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1610)
    public void unsetMtaAddressVerifyPositiveRefreshTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPositiveRefreshTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf address_verify_positive_refresh_time
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1610)
    public Map<String,Object> unsetMtaAddressVerifyPositiveRefreshTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPositiveRefreshTime, "");
        return attrs;
    }

    /**
     * Value for postconf alias_maps. Comma separated list.
     *
     * @return zimbraMtaAliasMaps, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1493)
    public String getMtaAliasMaps() {
        return getAttr(Provisioning.A_zimbraMtaAliasMaps, null);
    }

    /**
     * Value for postconf alias_maps. Comma separated list.
     *
     * @param zimbraMtaAliasMaps new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1493)
    public void setMtaAliasMaps(String zimbraMtaAliasMaps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAliasMaps, zimbraMtaAliasMaps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf alias_maps. Comma separated list.
     *
     * @param zimbraMtaAliasMaps new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1493)
    public Map<String,Object> setMtaAliasMaps(String zimbraMtaAliasMaps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAliasMaps, zimbraMtaAliasMaps);
        return attrs;
    }

    /**
     * Value for postconf alias_maps. Comma separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1493)
    public void unsetMtaAliasMaps() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAliasMaps, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf alias_maps. Comma separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1493)
    public Map<String,Object> unsetMtaAliasMaps(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAliasMaps, "");
        return attrs;
    }

    /**
     * Value for postconf always_add_missing_headers
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaAlwaysAddMissingHeaders, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1494)
    public ZAttrProvisioning.MtaAlwaysAddMissingHeaders getMtaAlwaysAddMissingHeaders() {
        try { String v = getAttr(Provisioning.A_zimbraMtaAlwaysAddMissingHeaders); return v == null ? null : ZAttrProvisioning.MtaAlwaysAddMissingHeaders.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf always_add_missing_headers
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaAlwaysAddMissingHeaders, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1494)
    public String getMtaAlwaysAddMissingHeadersAsString() {
        return getAttr(Provisioning.A_zimbraMtaAlwaysAddMissingHeaders, null);
    }

    /**
     * Value for postconf always_add_missing_headers
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaAlwaysAddMissingHeaders new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1494)
    public void setMtaAlwaysAddMissingHeaders(ZAttrProvisioning.MtaAlwaysAddMissingHeaders zimbraMtaAlwaysAddMissingHeaders) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAlwaysAddMissingHeaders, zimbraMtaAlwaysAddMissingHeaders.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf always_add_missing_headers
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaAlwaysAddMissingHeaders new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1494)
    public Map<String,Object> setMtaAlwaysAddMissingHeaders(ZAttrProvisioning.MtaAlwaysAddMissingHeaders zimbraMtaAlwaysAddMissingHeaders, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAlwaysAddMissingHeaders, zimbraMtaAlwaysAddMissingHeaders.toString());
        return attrs;
    }

    /**
     * Value for postconf always_add_missing_headers
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaAlwaysAddMissingHeaders new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1494)
    public void setMtaAlwaysAddMissingHeadersAsString(String zimbraMtaAlwaysAddMissingHeaders) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAlwaysAddMissingHeaders, zimbraMtaAlwaysAddMissingHeaders);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf always_add_missing_headers
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaAlwaysAddMissingHeaders new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1494)
    public Map<String,Object> setMtaAlwaysAddMissingHeadersAsString(String zimbraMtaAlwaysAddMissingHeaders, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAlwaysAddMissingHeaders, zimbraMtaAlwaysAddMissingHeaders);
        return attrs;
    }

    /**
     * Value for postconf always_add_missing_headers
     *
     * <p>Valid values: [no, yes]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1494)
    public void unsetMtaAlwaysAddMissingHeaders() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAlwaysAddMissingHeaders, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf always_add_missing_headers
     *
     * <p>Valid values: [no, yes]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1494)
    public Map<String,Object> unsetMtaAlwaysAddMissingHeaders(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAlwaysAddMissingHeaders, "");
        return attrs;
    }

    /**
     * interface address on which Admin HTTPS connector for MTA Auth should
     * listen; defaults to localhost
     *
     * @return zimbraMtaAuthBindAddress, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1908)
    public String getMtaAuthBindAddress() {
        return getAttr(Provisioning.A_zimbraMtaAuthBindAddress, null);
    }

    /**
     * interface address on which Admin HTTPS connector for MTA Auth should
     * listen; defaults to localhost
     *
     * @param zimbraMtaAuthBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1908)
    public void setMtaAuthBindAddress(String zimbraMtaAuthBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthBindAddress, zimbraMtaAuthBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which Admin HTTPS connector for MTA Auth should
     * listen; defaults to localhost
     *
     * @param zimbraMtaAuthBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1908)
    public Map<String,Object> setMtaAuthBindAddress(String zimbraMtaAuthBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthBindAddress, zimbraMtaAuthBindAddress);
        return attrs;
    }

    /**
     * interface address on which Admin HTTPS connector for MTA Auth should
     * listen; defaults to localhost
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1908)
    public void unsetMtaAuthBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which Admin HTTPS connector for MTA Auth should
     * listen; defaults to localhost
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1908)
    public Map<String,Object> unsetMtaAuthBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthBindAddress, "");
        return attrs;
    }

    /**
     * Internal port used by saslauthd to authenticate over SOAP
     *
     * <p>Use getMtaAuthPortAsString to access value as a string.
     *
     * @see #getMtaAuthPortAsString()
     *
     * @return zimbraMtaAuthPort, or -1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1906)
    public int getMtaAuthPort() {
        return getIntAttr(Provisioning.A_zimbraMtaAuthPort, -1);
    }

    /**
     * Internal port used by saslauthd to authenticate over SOAP
     *
     * @return zimbraMtaAuthPort, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1906)
    public String getMtaAuthPortAsString() {
        return getAttr(Provisioning.A_zimbraMtaAuthPort, null);
    }

    /**
     * Internal port used by saslauthd to authenticate over SOAP
     *
     * @param zimbraMtaAuthPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1906)
    public void setMtaAuthPort(int zimbraMtaAuthPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthPort, Integer.toString(zimbraMtaAuthPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Internal port used by saslauthd to authenticate over SOAP
     *
     * @param zimbraMtaAuthPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1906)
    public Map<String,Object> setMtaAuthPort(int zimbraMtaAuthPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthPort, Integer.toString(zimbraMtaAuthPort));
        return attrs;
    }

    /**
     * Internal port used by saslauthd to authenticate over SOAP
     *
     * @param zimbraMtaAuthPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1906)
    public void setMtaAuthPortAsString(String zimbraMtaAuthPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthPort, zimbraMtaAuthPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Internal port used by saslauthd to authenticate over SOAP
     *
     * @param zimbraMtaAuthPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1906)
    public Map<String,Object> setMtaAuthPortAsString(String zimbraMtaAuthPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthPort, zimbraMtaAuthPort);
        return attrs;
    }

    /**
     * Internal port used by saslauthd to authenticate over SOAP
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1906)
    public void unsetMtaAuthPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Internal port used by saslauthd to authenticate over SOAP
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1906)
    public Map<String,Object> unsetMtaAuthPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthPort, "");
        return attrs;
    }

    /**
     * Value for postconf bounce_notice_recipient
     *
     * @return zimbraMtaBounceNoticeRecipient, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1496)
    public String getMtaBounceNoticeRecipient() {
        return getAttr(Provisioning.A_zimbraMtaBounceNoticeRecipient, null);
    }

    /**
     * Value for postconf bounce_notice_recipient
     *
     * @param zimbraMtaBounceNoticeRecipient new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1496)
    public void setMtaBounceNoticeRecipient(String zimbraMtaBounceNoticeRecipient) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBounceNoticeRecipient, zimbraMtaBounceNoticeRecipient);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf bounce_notice_recipient
     *
     * @param zimbraMtaBounceNoticeRecipient new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1496)
    public Map<String,Object> setMtaBounceNoticeRecipient(String zimbraMtaBounceNoticeRecipient, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBounceNoticeRecipient, zimbraMtaBounceNoticeRecipient);
        return attrs;
    }

    /**
     * Value for postconf bounce_notice_recipient
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1496)
    public void unsetMtaBounceNoticeRecipient() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBounceNoticeRecipient, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf bounce_notice_recipient
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1496)
    public Map<String,Object> unsetMtaBounceNoticeRecipient(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBounceNoticeRecipient, "");
        return attrs;
    }

    /**
     * Value for postconf bounce_queue_lifetime
     *
     * @return zimbraMtaBounceQueueLifetime, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1497)
    public String getMtaBounceQueueLifetime() {
        return getAttr(Provisioning.A_zimbraMtaBounceQueueLifetime, null);
    }

    /**
     * Value for postconf bounce_queue_lifetime
     *
     * @param zimbraMtaBounceQueueLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1497)
    public void setMtaBounceQueueLifetime(String zimbraMtaBounceQueueLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBounceQueueLifetime, zimbraMtaBounceQueueLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf bounce_queue_lifetime
     *
     * @param zimbraMtaBounceQueueLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1497)
    public Map<String,Object> setMtaBounceQueueLifetime(String zimbraMtaBounceQueueLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBounceQueueLifetime, zimbraMtaBounceQueueLifetime);
        return attrs;
    }

    /**
     * Value for postconf bounce_queue_lifetime
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1497)
    public void unsetMtaBounceQueueLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBounceQueueLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf bounce_queue_lifetime
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1497)
    public Map<String,Object> unsetMtaBounceQueueLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBounceQueueLifetime, "");
        return attrs;
    }

    /**
     * Value for postconf broken_sasl_auth_clients
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaBrokenSaslAuthClients, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1495)
    public ZAttrProvisioning.MtaBrokenSaslAuthClients getMtaBrokenSaslAuthClients() {
        try { String v = getAttr(Provisioning.A_zimbraMtaBrokenSaslAuthClients); return v == null ? null : ZAttrProvisioning.MtaBrokenSaslAuthClients.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf broken_sasl_auth_clients
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaBrokenSaslAuthClients, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1495)
    public String getMtaBrokenSaslAuthClientsAsString() {
        return getAttr(Provisioning.A_zimbraMtaBrokenSaslAuthClients, null);
    }

    /**
     * Value for postconf broken_sasl_auth_clients
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaBrokenSaslAuthClients new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1495)
    public void setMtaBrokenSaslAuthClients(ZAttrProvisioning.MtaBrokenSaslAuthClients zimbraMtaBrokenSaslAuthClients) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBrokenSaslAuthClients, zimbraMtaBrokenSaslAuthClients.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf broken_sasl_auth_clients
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaBrokenSaslAuthClients new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1495)
    public Map<String,Object> setMtaBrokenSaslAuthClients(ZAttrProvisioning.MtaBrokenSaslAuthClients zimbraMtaBrokenSaslAuthClients, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBrokenSaslAuthClients, zimbraMtaBrokenSaslAuthClients.toString());
        return attrs;
    }

    /**
     * Value for postconf broken_sasl_auth_clients
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaBrokenSaslAuthClients new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1495)
    public void setMtaBrokenSaslAuthClientsAsString(String zimbraMtaBrokenSaslAuthClients) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBrokenSaslAuthClients, zimbraMtaBrokenSaslAuthClients);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf broken_sasl_auth_clients
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaBrokenSaslAuthClients new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1495)
    public Map<String,Object> setMtaBrokenSaslAuthClientsAsString(String zimbraMtaBrokenSaslAuthClients, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBrokenSaslAuthClients, zimbraMtaBrokenSaslAuthClients);
        return attrs;
    }

    /**
     * Value for postconf broken_sasl_auth_clients
     *
     * <p>Valid values: [no, yes]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1495)
    public void unsetMtaBrokenSaslAuthClients() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBrokenSaslAuthClients, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf broken_sasl_auth_clients
     *
     * <p>Valid values: [no, yes]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1495)
    public Map<String,Object> unsetMtaBrokenSaslAuthClients(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBrokenSaslAuthClients, "");
        return attrs;
    }

    /**
     * Value for postconf command_directory
     *
     * @return zimbraMtaCommandDirectory, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1498)
    public String getMtaCommandDirectory() {
        return getAttr(Provisioning.A_zimbraMtaCommandDirectory, null);
    }

    /**
     * Value for postconf command_directory
     *
     * @param zimbraMtaCommandDirectory new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1498)
    public void setMtaCommandDirectory(String zimbraMtaCommandDirectory) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaCommandDirectory, zimbraMtaCommandDirectory);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf command_directory
     *
     * @param zimbraMtaCommandDirectory new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1498)
    public Map<String,Object> setMtaCommandDirectory(String zimbraMtaCommandDirectory, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaCommandDirectory, zimbraMtaCommandDirectory);
        return attrs;
    }

    /**
     * Value for postconf command_directory
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1498)
    public void unsetMtaCommandDirectory() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaCommandDirectory, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf command_directory
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1498)
    public Map<String,Object> unsetMtaCommandDirectory(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaCommandDirectory, "");
        return attrs;
    }

    /**
     * Value for postconf daemon_directory
     *
     * @return zimbraMtaDaemonDirectory, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1499)
    public String getMtaDaemonDirectory() {
        return getAttr(Provisioning.A_zimbraMtaDaemonDirectory, null);
    }

    /**
     * Value for postconf daemon_directory
     *
     * @param zimbraMtaDaemonDirectory new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1499)
    public void setMtaDaemonDirectory(String zimbraMtaDaemonDirectory) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDaemonDirectory, zimbraMtaDaemonDirectory);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf daemon_directory
     *
     * @param zimbraMtaDaemonDirectory new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1499)
    public Map<String,Object> setMtaDaemonDirectory(String zimbraMtaDaemonDirectory, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDaemonDirectory, zimbraMtaDaemonDirectory);
        return attrs;
    }

    /**
     * Value for postconf daemon_directory
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1499)
    public void unsetMtaDaemonDirectory() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDaemonDirectory, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf daemon_directory
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1499)
    public Map<String,Object> unsetMtaDaemonDirectory(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDaemonDirectory, "");
        return attrs;
    }

    /**
     * Value for postconf default_process_limit
     *
     * @return zimbraMtaDefaultProcessLimit, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1501)
    public String getMtaDefaultProcessLimit() {
        return getAttr(Provisioning.A_zimbraMtaDefaultProcessLimit, null);
    }

    /**
     * Value for postconf default_process_limit
     *
     * @param zimbraMtaDefaultProcessLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1501)
    public void setMtaDefaultProcessLimit(String zimbraMtaDefaultProcessLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDefaultProcessLimit, zimbraMtaDefaultProcessLimit);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf default_process_limit
     *
     * @param zimbraMtaDefaultProcessLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1501)
    public Map<String,Object> setMtaDefaultProcessLimit(String zimbraMtaDefaultProcessLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDefaultProcessLimit, zimbraMtaDefaultProcessLimit);
        return attrs;
    }

    /**
     * Value for postconf default_process_limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1501)
    public void unsetMtaDefaultProcessLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDefaultProcessLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf default_process_limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1501)
    public Map<String,Object> unsetMtaDefaultProcessLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDefaultProcessLimit, "");
        return attrs;
    }

    /**
     * Value for postconf delay_warning_time
     *
     * @return zimbraMtaDelayWarningTime, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1500)
    public String getMtaDelayWarningTime() {
        return getAttr(Provisioning.A_zimbraMtaDelayWarningTime, null);
    }

    /**
     * Value for postconf delay_warning_time
     *
     * @param zimbraMtaDelayWarningTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1500)
    public void setMtaDelayWarningTime(String zimbraMtaDelayWarningTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDelayWarningTime, zimbraMtaDelayWarningTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf delay_warning_time
     *
     * @param zimbraMtaDelayWarningTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1500)
    public Map<String,Object> setMtaDelayWarningTime(String zimbraMtaDelayWarningTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDelayWarningTime, zimbraMtaDelayWarningTime);
        return attrs;
    }

    /**
     * Value for postconf delay_warning_time
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1500)
    public void unsetMtaDelayWarningTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDelayWarningTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf delay_warning_time
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1500)
    public Map<String,Object> unsetMtaDelayWarningTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDelayWarningTime, "");
        return attrs;
    }

    /**
     * Value for postconf disable_dns_lookups (note enable v. disable)
     *
     * @return zimbraMtaDnsLookupsEnabled, or false if unset
     */
    @ZAttr(id=197)
    public boolean isMtaDnsLookupsEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMtaDnsLookupsEnabled, false);
    }

    /**
     * Value for postconf disable_dns_lookups (note enable v. disable)
     *
     * @param zimbraMtaDnsLookupsEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=197)
    public void setMtaDnsLookupsEnabled(boolean zimbraMtaDnsLookupsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDnsLookupsEnabled, zimbraMtaDnsLookupsEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf disable_dns_lookups (note enable v. disable)
     *
     * @param zimbraMtaDnsLookupsEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=197)
    public Map<String,Object> setMtaDnsLookupsEnabled(boolean zimbraMtaDnsLookupsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDnsLookupsEnabled, zimbraMtaDnsLookupsEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Value for postconf disable_dns_lookups (note enable v. disable)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=197)
    public void unsetMtaDnsLookupsEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDnsLookupsEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf disable_dns_lookups (note enable v. disable)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=197)
    public Map<String,Object> unsetMtaDnsLookupsEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDnsLookupsEnabled, "");
        return attrs;
    }

    /**
     * Whether or not to enable zmpostfixpolicyd with MTA. Defaults to FALSE
     *
     * @return zimbraMtaEnableSmtpdPolicyd, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1466)
    public boolean isMtaEnableSmtpdPolicyd() {
        return getBooleanAttr(Provisioning.A_zimbraMtaEnableSmtpdPolicyd, false);
    }

    /**
     * Whether or not to enable zmpostfixpolicyd with MTA. Defaults to FALSE
     *
     * @param zimbraMtaEnableSmtpdPolicyd new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1466)
    public void setMtaEnableSmtpdPolicyd(boolean zimbraMtaEnableSmtpdPolicyd) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaEnableSmtpdPolicyd, zimbraMtaEnableSmtpdPolicyd ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable zmpostfixpolicyd with MTA. Defaults to FALSE
     *
     * @param zimbraMtaEnableSmtpdPolicyd new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1466)
    public Map<String,Object> setMtaEnableSmtpdPolicyd(boolean zimbraMtaEnableSmtpdPolicyd, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaEnableSmtpdPolicyd, zimbraMtaEnableSmtpdPolicyd ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether or not to enable zmpostfixpolicyd with MTA. Defaults to FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1466)
    public void unsetMtaEnableSmtpdPolicyd() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaEnableSmtpdPolicyd, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable zmpostfixpolicyd with MTA. Defaults to FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1466)
    public Map<String,Object> unsetMtaEnableSmtpdPolicyd(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaEnableSmtpdPolicyd, "");
        return attrs;
    }

    /**
     * Fallback value for postconf relayhost.
     *
     * @return zimbraMtaFallbackRelayHost, or null if unset
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1435)
    public String getMtaFallbackRelayHost() {
        return getAttr(Provisioning.A_zimbraMtaFallbackRelayHost, null);
    }

    /**
     * Fallback value for postconf relayhost.
     *
     * @param zimbraMtaFallbackRelayHost new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1435)
    public void setMtaFallbackRelayHost(String zimbraMtaFallbackRelayHost) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaFallbackRelayHost, zimbraMtaFallbackRelayHost);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Fallback value for postconf relayhost.
     *
     * @param zimbraMtaFallbackRelayHost new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1435)
    public Map<String,Object> setMtaFallbackRelayHost(String zimbraMtaFallbackRelayHost, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaFallbackRelayHost, zimbraMtaFallbackRelayHost);
        return attrs;
    }

    /**
     * Fallback value for postconf relayhost.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1435)
    public void unsetMtaFallbackRelayHost() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaFallbackRelayHost, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Fallback value for postconf relayhost.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1435)
    public Map<String,Object> unsetMtaFallbackRelayHost(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaFallbackRelayHost, "");
        return attrs;
    }

    /**
     * Value for postconf header_checks
     *
     * @return zimbraMtaHeaderChecks, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1502)
    public String[] getMtaHeaderChecks() {
        return getMultiAttr(Provisioning.A_zimbraMtaHeaderChecks);
    }

    /**
     * Value for postconf header_checks
     *
     * @param zimbraMtaHeaderChecks new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1502)
    public void setMtaHeaderChecks(String[] zimbraMtaHeaderChecks) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaHeaderChecks, zimbraMtaHeaderChecks);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf header_checks
     *
     * @param zimbraMtaHeaderChecks new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1502)
    public Map<String,Object> setMtaHeaderChecks(String[] zimbraMtaHeaderChecks, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaHeaderChecks, zimbraMtaHeaderChecks);
        return attrs;
    }

    /**
     * Value for postconf header_checks
     *
     * @param zimbraMtaHeaderChecks new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1502)
    public void addMtaHeaderChecks(String zimbraMtaHeaderChecks) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaHeaderChecks, zimbraMtaHeaderChecks);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf header_checks
     *
     * @param zimbraMtaHeaderChecks new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1502)
    public Map<String,Object> addMtaHeaderChecks(String zimbraMtaHeaderChecks, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaHeaderChecks, zimbraMtaHeaderChecks);
        return attrs;
    }

    /**
     * Value for postconf header_checks
     *
     * @param zimbraMtaHeaderChecks existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1502)
    public void removeMtaHeaderChecks(String zimbraMtaHeaderChecks) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaHeaderChecks, zimbraMtaHeaderChecks);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf header_checks
     *
     * @param zimbraMtaHeaderChecks existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1502)
    public Map<String,Object> removeMtaHeaderChecks(String zimbraMtaHeaderChecks, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaHeaderChecks, zimbraMtaHeaderChecks);
        return attrs;
    }

    /**
     * Value for postconf header_checks
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1502)
    public void unsetMtaHeaderChecks() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaHeaderChecks, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf header_checks
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1502)
    public Map<String,Object> unsetMtaHeaderChecks(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaHeaderChecks, "");
        return attrs;
    }

    /**
     * Value for postconf hopcount_limit
     *
     * @return zimbraMtaHopcountLimit, or -1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1835)
    public int getMtaHopcountLimit() {
        return getIntAttr(Provisioning.A_zimbraMtaHopcountLimit, -1);
    }

    /**
     * Value for postconf hopcount_limit
     *
     * @param zimbraMtaHopcountLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1835)
    public void setMtaHopcountLimit(int zimbraMtaHopcountLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaHopcountLimit, Integer.toString(zimbraMtaHopcountLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf hopcount_limit
     *
     * @param zimbraMtaHopcountLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1835)
    public Map<String,Object> setMtaHopcountLimit(int zimbraMtaHopcountLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaHopcountLimit, Integer.toString(zimbraMtaHopcountLimit));
        return attrs;
    }

    /**
     * Value for postconf hopcount_limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1835)
    public void unsetMtaHopcountLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaHopcountLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf hopcount_limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1835)
    public Map<String,Object> unsetMtaHopcountLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaHopcountLimit, "");
        return attrs;
    }

    /**
     * Value for postconf import_environment
     *
     * @return zimbraMtaImportEnvironment, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1503)
    public String[] getMtaImportEnvironment() {
        return getMultiAttr(Provisioning.A_zimbraMtaImportEnvironment);
    }

    /**
     * Value for postconf import_environment
     *
     * @param zimbraMtaImportEnvironment new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1503)
    public void setMtaImportEnvironment(String[] zimbraMtaImportEnvironment) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaImportEnvironment, zimbraMtaImportEnvironment);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf import_environment
     *
     * @param zimbraMtaImportEnvironment new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1503)
    public Map<String,Object> setMtaImportEnvironment(String[] zimbraMtaImportEnvironment, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaImportEnvironment, zimbraMtaImportEnvironment);
        return attrs;
    }

    /**
     * Value for postconf import_environment
     *
     * @param zimbraMtaImportEnvironment new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1503)
    public void addMtaImportEnvironment(String zimbraMtaImportEnvironment) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaImportEnvironment, zimbraMtaImportEnvironment);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf import_environment
     *
     * @param zimbraMtaImportEnvironment new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1503)
    public Map<String,Object> addMtaImportEnvironment(String zimbraMtaImportEnvironment, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaImportEnvironment, zimbraMtaImportEnvironment);
        return attrs;
    }

    /**
     * Value for postconf import_environment
     *
     * @param zimbraMtaImportEnvironment existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1503)
    public void removeMtaImportEnvironment(String zimbraMtaImportEnvironment) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaImportEnvironment, zimbraMtaImportEnvironment);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf import_environment
     *
     * @param zimbraMtaImportEnvironment existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1503)
    public Map<String,Object> removeMtaImportEnvironment(String zimbraMtaImportEnvironment, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaImportEnvironment, zimbraMtaImportEnvironment);
        return attrs;
    }

    /**
     * Value for postconf import_environment
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1503)
    public void unsetMtaImportEnvironment() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaImportEnvironment, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf import_environment
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1503)
    public Map<String,Object> unsetMtaImportEnvironment(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaImportEnvironment, "");
        return attrs;
    }

    /**
     * Value for postconf in_flow_delay
     *
     * @return zimbraMtaInFlowDelay, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1504)
    public String getMtaInFlowDelay() {
        return getAttr(Provisioning.A_zimbraMtaInFlowDelay, null);
    }

    /**
     * Value for postconf in_flow_delay
     *
     * @param zimbraMtaInFlowDelay new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1504)
    public void setMtaInFlowDelay(String zimbraMtaInFlowDelay) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaInFlowDelay, zimbraMtaInFlowDelay);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf in_flow_delay
     *
     * @param zimbraMtaInFlowDelay new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1504)
    public Map<String,Object> setMtaInFlowDelay(String zimbraMtaInFlowDelay, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaInFlowDelay, zimbraMtaInFlowDelay);
        return attrs;
    }

    /**
     * Value for postconf in_flow_delay
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1504)
    public void unsetMtaInFlowDelay() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaInFlowDelay, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf in_flow_delay
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1504)
    public Map<String,Object> unsetMtaInFlowDelay(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaInFlowDelay, "");
        return attrs;
    }

    /**
     * Maximum Map size for MTA LMDB dbs. Defaults to 16777216 (16MB).
     * Databases will not grow beyond this point.
     *
     * @return zimbraMtaLmdbMapSize, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1489)
    public int getMtaLmdbMapSize() {
        return getIntAttr(Provisioning.A_zimbraMtaLmdbMapSize, -1);
    }

    /**
     * Maximum Map size for MTA LMDB dbs. Defaults to 16777216 (16MB).
     * Databases will not grow beyond this point.
     *
     * @param zimbraMtaLmdbMapSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1489)
    public void setMtaLmdbMapSize(int zimbraMtaLmdbMapSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmdbMapSize, Integer.toString(zimbraMtaLmdbMapSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum Map size for MTA LMDB dbs. Defaults to 16777216 (16MB).
     * Databases will not grow beyond this point.
     *
     * @param zimbraMtaLmdbMapSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1489)
    public Map<String,Object> setMtaLmdbMapSize(int zimbraMtaLmdbMapSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmdbMapSize, Integer.toString(zimbraMtaLmdbMapSize));
        return attrs;
    }

    /**
     * Maximum Map size for MTA LMDB dbs. Defaults to 16777216 (16MB).
     * Databases will not grow beyond this point.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1489)
    public void unsetMtaLmdbMapSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmdbMapSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum Map size for MTA LMDB dbs. Defaults to 16777216 (16MB).
     * Databases will not grow beyond this point.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1489)
    public Map<String,Object> unsetMtaLmdbMapSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmdbMapSize, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_connection_cache_destinations
     *
     * @return zimbraMtaLmtpConnectionCacheDestinations, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1505)
    public String[] getMtaLmtpConnectionCacheDestinations() {
        return getMultiAttr(Provisioning.A_zimbraMtaLmtpConnectionCacheDestinations);
    }

    /**
     * Value for postconf lmtp_connection_cache_destinations
     *
     * @param zimbraMtaLmtpConnectionCacheDestinations new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1505)
    public void setMtaLmtpConnectionCacheDestinations(String[] zimbraMtaLmtpConnectionCacheDestinations) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpConnectionCacheDestinations, zimbraMtaLmtpConnectionCacheDestinations);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_connection_cache_destinations
     *
     * @param zimbraMtaLmtpConnectionCacheDestinations new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1505)
    public Map<String,Object> setMtaLmtpConnectionCacheDestinations(String[] zimbraMtaLmtpConnectionCacheDestinations, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpConnectionCacheDestinations, zimbraMtaLmtpConnectionCacheDestinations);
        return attrs;
    }

    /**
     * Value for postconf lmtp_connection_cache_destinations
     *
     * @param zimbraMtaLmtpConnectionCacheDestinations new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1505)
    public void addMtaLmtpConnectionCacheDestinations(String zimbraMtaLmtpConnectionCacheDestinations) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaLmtpConnectionCacheDestinations, zimbraMtaLmtpConnectionCacheDestinations);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_connection_cache_destinations
     *
     * @param zimbraMtaLmtpConnectionCacheDestinations new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1505)
    public Map<String,Object> addMtaLmtpConnectionCacheDestinations(String zimbraMtaLmtpConnectionCacheDestinations, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaLmtpConnectionCacheDestinations, zimbraMtaLmtpConnectionCacheDestinations);
        return attrs;
    }

    /**
     * Value for postconf lmtp_connection_cache_destinations
     *
     * @param zimbraMtaLmtpConnectionCacheDestinations existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1505)
    public void removeMtaLmtpConnectionCacheDestinations(String zimbraMtaLmtpConnectionCacheDestinations) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaLmtpConnectionCacheDestinations, zimbraMtaLmtpConnectionCacheDestinations);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_connection_cache_destinations
     *
     * @param zimbraMtaLmtpConnectionCacheDestinations existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1505)
    public Map<String,Object> removeMtaLmtpConnectionCacheDestinations(String zimbraMtaLmtpConnectionCacheDestinations, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaLmtpConnectionCacheDestinations, zimbraMtaLmtpConnectionCacheDestinations);
        return attrs;
    }

    /**
     * Value for postconf lmtp_connection_cache_destinations
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1505)
    public void unsetMtaLmtpConnectionCacheDestinations() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpConnectionCacheDestinations, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_connection_cache_destinations
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1505)
    public Map<String,Object> unsetMtaLmtpConnectionCacheDestinations(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpConnectionCacheDestinations, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_connection_cache_time_limit
     *
     * @return zimbraMtaLmtpConnectionCacheTimeLimit, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1506)
    public String getMtaLmtpConnectionCacheTimeLimit() {
        return getAttr(Provisioning.A_zimbraMtaLmtpConnectionCacheTimeLimit, null);
    }

    /**
     * Value for postconf lmtp_connection_cache_time_limit
     *
     * @param zimbraMtaLmtpConnectionCacheTimeLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1506)
    public void setMtaLmtpConnectionCacheTimeLimit(String zimbraMtaLmtpConnectionCacheTimeLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpConnectionCacheTimeLimit, zimbraMtaLmtpConnectionCacheTimeLimit);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_connection_cache_time_limit
     *
     * @param zimbraMtaLmtpConnectionCacheTimeLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1506)
    public Map<String,Object> setMtaLmtpConnectionCacheTimeLimit(String zimbraMtaLmtpConnectionCacheTimeLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpConnectionCacheTimeLimit, zimbraMtaLmtpConnectionCacheTimeLimit);
        return attrs;
    }

    /**
     * Value for postconf lmtp_connection_cache_time_limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1506)
    public void unsetMtaLmtpConnectionCacheTimeLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpConnectionCacheTimeLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_connection_cache_time_limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1506)
    public Map<String,Object> unsetMtaLmtpConnectionCacheTimeLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpConnectionCacheTimeLimit, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_host_lookup
     *
     * <p>Valid values: [dns, native]
     *
     * @return zimbraMtaLmtpHostLookup, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1507)
    public String[] getMtaLmtpHostLookupAsString() {
        return getMultiAttr(Provisioning.A_zimbraMtaLmtpHostLookup);
    }

    /**
     * Value for postconf lmtp_host_lookup
     *
     * <p>Valid values: [dns, native]
     *
     * @param zimbraMtaLmtpHostLookup new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1507)
    public void setMtaLmtpHostLookup(ZAttrProvisioning.MtaLmtpHostLookup zimbraMtaLmtpHostLookup) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpHostLookup, zimbraMtaLmtpHostLookup.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_host_lookup
     *
     * <p>Valid values: [dns, native]
     *
     * @param zimbraMtaLmtpHostLookup new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1507)
    public Map<String,Object> setMtaLmtpHostLookup(ZAttrProvisioning.MtaLmtpHostLookup zimbraMtaLmtpHostLookup, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpHostLookup, zimbraMtaLmtpHostLookup.toString());
        return attrs;
    }

    /**
     * Value for postconf lmtp_host_lookup
     *
     * <p>Valid values: [dns, native]
     *
     * @param zimbraMtaLmtpHostLookup new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1507)
    public void setMtaLmtpHostLookupAsString(String[] zimbraMtaLmtpHostLookup) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpHostLookup, zimbraMtaLmtpHostLookup);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_host_lookup
     *
     * <p>Valid values: [dns, native]
     *
     * @param zimbraMtaLmtpHostLookup new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1507)
    public Map<String,Object> setMtaLmtpHostLookupAsString(String[] zimbraMtaLmtpHostLookup, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpHostLookup, zimbraMtaLmtpHostLookup);
        return attrs;
    }

    /**
     * Value for postconf lmtp_host_lookup
     *
     * <p>Valid values: [dns, native]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1507)
    public void unsetMtaLmtpHostLookup() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpHostLookup, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_host_lookup
     *
     * <p>Valid values: [dns, native]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1507)
    public Map<String,Object> unsetMtaLmtpHostLookup(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpHostLookup, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_CAfile
     *
     * @return zimbraMtaLmtpTlsCAfile, or null if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1663)
    public String getMtaLmtpTlsCAfile() {
        return getAttr(Provisioning.A_zimbraMtaLmtpTlsCAfile, null);
    }

    /**
     * Value for postconf lmtp_tls_CAfile
     *
     * @param zimbraMtaLmtpTlsCAfile new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1663)
    public void setMtaLmtpTlsCAfile(String zimbraMtaLmtpTlsCAfile) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCAfile, zimbraMtaLmtpTlsCAfile);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_CAfile
     *
     * @param zimbraMtaLmtpTlsCAfile new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1663)
    public Map<String,Object> setMtaLmtpTlsCAfile(String zimbraMtaLmtpTlsCAfile, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCAfile, zimbraMtaLmtpTlsCAfile);
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_CAfile
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1663)
    public void unsetMtaLmtpTlsCAfile() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCAfile, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_CAfile
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1663)
    public Map<String,Object> unsetMtaLmtpTlsCAfile(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCAfile, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_CApath
     *
     * @return zimbraMtaLmtpTlsCApath, or null if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1664)
    public String getMtaLmtpTlsCApath() {
        return getAttr(Provisioning.A_zimbraMtaLmtpTlsCApath, null);
    }

    /**
     * Value for postconf lmtp_tls_CApath
     *
     * @param zimbraMtaLmtpTlsCApath new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1664)
    public void setMtaLmtpTlsCApath(String zimbraMtaLmtpTlsCApath) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCApath, zimbraMtaLmtpTlsCApath);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_CApath
     *
     * @param zimbraMtaLmtpTlsCApath new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1664)
    public Map<String,Object> setMtaLmtpTlsCApath(String zimbraMtaLmtpTlsCApath, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCApath, zimbraMtaLmtpTlsCApath);
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_CApath
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1664)
    public void unsetMtaLmtpTlsCApath() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCApath, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_CApath
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1664)
    public Map<String,Object> unsetMtaLmtpTlsCApath(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCApath, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @return zimbraMtaLmtpTlsCiphers, or null if unset and/or has invalid value
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1661)
    public ZAttrProvisioning.MtaLmtpTlsCiphers getMtaLmtpTlsCiphers() {
        try { String v = getAttr(Provisioning.A_zimbraMtaLmtpTlsCiphers); return v == null ? null : ZAttrProvisioning.MtaLmtpTlsCiphers.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf lmtp_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @return zimbraMtaLmtpTlsCiphers, or null if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1661)
    public String getMtaLmtpTlsCiphersAsString() {
        return getAttr(Provisioning.A_zimbraMtaLmtpTlsCiphers, null);
    }

    /**
     * Value for postconf lmtp_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaLmtpTlsCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1661)
    public void setMtaLmtpTlsCiphers(ZAttrProvisioning.MtaLmtpTlsCiphers zimbraMtaLmtpTlsCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCiphers, zimbraMtaLmtpTlsCiphers.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaLmtpTlsCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1661)
    public Map<String,Object> setMtaLmtpTlsCiphers(ZAttrProvisioning.MtaLmtpTlsCiphers zimbraMtaLmtpTlsCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCiphers, zimbraMtaLmtpTlsCiphers.toString());
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaLmtpTlsCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1661)
    public void setMtaLmtpTlsCiphersAsString(String zimbraMtaLmtpTlsCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCiphers, zimbraMtaLmtpTlsCiphers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaLmtpTlsCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1661)
    public Map<String,Object> setMtaLmtpTlsCiphersAsString(String zimbraMtaLmtpTlsCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCiphers, zimbraMtaLmtpTlsCiphers);
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1661)
    public void unsetMtaLmtpTlsCiphers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCiphers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1661)
    public Map<String,Object> unsetMtaLmtpTlsCiphers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCiphers, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_exclude_ciphers
     *
     * @return zimbraMtaLmtpTlsExcludeCiphers, or null if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1659)
    public String getMtaLmtpTlsExcludeCiphers() {
        return getAttr(Provisioning.A_zimbraMtaLmtpTlsExcludeCiphers, null);
    }

    /**
     * Value for postconf lmtp_tls_exclude_ciphers
     *
     * @param zimbraMtaLmtpTlsExcludeCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1659)
    public void setMtaLmtpTlsExcludeCiphers(String zimbraMtaLmtpTlsExcludeCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsExcludeCiphers, zimbraMtaLmtpTlsExcludeCiphers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_exclude_ciphers
     *
     * @param zimbraMtaLmtpTlsExcludeCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1659)
    public Map<String,Object> setMtaLmtpTlsExcludeCiphers(String zimbraMtaLmtpTlsExcludeCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsExcludeCiphers, zimbraMtaLmtpTlsExcludeCiphers);
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_exclude_ciphers
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1659)
    public void unsetMtaLmtpTlsExcludeCiphers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsExcludeCiphers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_exclude_ciphers
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1659)
    public Map<String,Object> unsetMtaLmtpTlsExcludeCiphers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsExcludeCiphers, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @return zimbraMtaLmtpTlsLoglevel, or -1 if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1665)
    public int getMtaLmtpTlsLoglevel() {
        return getIntAttr(Provisioning.A_zimbraMtaLmtpTlsLoglevel, -1);
    }

    /**
     * Value for postconf lmtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @param zimbraMtaLmtpTlsLoglevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1665)
    public void setMtaLmtpTlsLoglevel(int zimbraMtaLmtpTlsLoglevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsLoglevel, Integer.toString(zimbraMtaLmtpTlsLoglevel));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @param zimbraMtaLmtpTlsLoglevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1665)
    public Map<String,Object> setMtaLmtpTlsLoglevel(int zimbraMtaLmtpTlsLoglevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsLoglevel, Integer.toString(zimbraMtaLmtpTlsLoglevel));
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1665)
    public void unsetMtaLmtpTlsLoglevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsLoglevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1665)
    public Map<String,Object> unsetMtaLmtpTlsLoglevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsLoglevel, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @return zimbraMtaLmtpTlsMandatoryCiphers, or null if unset and/or has invalid value
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1662)
    public ZAttrProvisioning.MtaLmtpTlsMandatoryCiphers getMtaLmtpTlsMandatoryCiphers() {
        try { String v = getAttr(Provisioning.A_zimbraMtaLmtpTlsMandatoryCiphers); return v == null ? null : ZAttrProvisioning.MtaLmtpTlsMandatoryCiphers.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf lmtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @return zimbraMtaLmtpTlsMandatoryCiphers, or null if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1662)
    public String getMtaLmtpTlsMandatoryCiphersAsString() {
        return getAttr(Provisioning.A_zimbraMtaLmtpTlsMandatoryCiphers, null);
    }

    /**
     * Value for postconf lmtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaLmtpTlsMandatoryCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1662)
    public void setMtaLmtpTlsMandatoryCiphers(ZAttrProvisioning.MtaLmtpTlsMandatoryCiphers zimbraMtaLmtpTlsMandatoryCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryCiphers, zimbraMtaLmtpTlsMandatoryCiphers.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaLmtpTlsMandatoryCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1662)
    public Map<String,Object> setMtaLmtpTlsMandatoryCiphers(ZAttrProvisioning.MtaLmtpTlsMandatoryCiphers zimbraMtaLmtpTlsMandatoryCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryCiphers, zimbraMtaLmtpTlsMandatoryCiphers.toString());
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaLmtpTlsMandatoryCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1662)
    public void setMtaLmtpTlsMandatoryCiphersAsString(String zimbraMtaLmtpTlsMandatoryCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryCiphers, zimbraMtaLmtpTlsMandatoryCiphers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaLmtpTlsMandatoryCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1662)
    public Map<String,Object> setMtaLmtpTlsMandatoryCiphersAsString(String zimbraMtaLmtpTlsMandatoryCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryCiphers, zimbraMtaLmtpTlsMandatoryCiphers);
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1662)
    public void unsetMtaLmtpTlsMandatoryCiphers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryCiphers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1662)
    public Map<String,Object> unsetMtaLmtpTlsMandatoryCiphers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryCiphers, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_mandatory_protocols
     *
     * @return zimbraMtaLmtpTlsMandatoryProtocols, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1784)
    public String getMtaLmtpTlsMandatoryProtocols() {
        return getAttr(Provisioning.A_zimbraMtaLmtpTlsMandatoryProtocols, null);
    }

    /**
     * Value for postconf lmtp_tls_mandatory_protocols
     *
     * @param zimbraMtaLmtpTlsMandatoryProtocols new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1784)
    public void setMtaLmtpTlsMandatoryProtocols(String zimbraMtaLmtpTlsMandatoryProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryProtocols, zimbraMtaLmtpTlsMandatoryProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_mandatory_protocols
     *
     * @param zimbraMtaLmtpTlsMandatoryProtocols new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1784)
    public Map<String,Object> setMtaLmtpTlsMandatoryProtocols(String zimbraMtaLmtpTlsMandatoryProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryProtocols, zimbraMtaLmtpTlsMandatoryProtocols);
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_mandatory_protocols
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1784)
    public void unsetMtaLmtpTlsMandatoryProtocols() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryProtocols, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_mandatory_protocols
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1784)
    public Map<String,Object> unsetMtaLmtpTlsMandatoryProtocols(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryProtocols, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_protocols
     *
     * @return zimbraMtaLmtpTlsProtocols, or null if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1658)
    public String getMtaLmtpTlsProtocols() {
        return getAttr(Provisioning.A_zimbraMtaLmtpTlsProtocols, null);
    }

    /**
     * Value for postconf lmtp_tls_protocols
     *
     * @param zimbraMtaLmtpTlsProtocols new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1658)
    public void setMtaLmtpTlsProtocols(String zimbraMtaLmtpTlsProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsProtocols, zimbraMtaLmtpTlsProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_protocols
     *
     * @param zimbraMtaLmtpTlsProtocols new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1658)
    public Map<String,Object> setMtaLmtpTlsProtocols(String zimbraMtaLmtpTlsProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsProtocols, zimbraMtaLmtpTlsProtocols);
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_protocols
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1658)
    public void unsetMtaLmtpTlsProtocols() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsProtocols, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_protocols
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1658)
    public Map<String,Object> unsetMtaLmtpTlsProtocols(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsProtocols, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_security_level
     *
     * <p>Valid values: [may, encrypt, dane-only, fingerprint, verify, dane, none, secure]
     *
     * @return zimbraMtaLmtpTlsSecurityLevel, or null if unset and/or has invalid value
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1660)
    public ZAttrProvisioning.MtaLmtpTlsSecurityLevel getMtaLmtpTlsSecurityLevel() {
        try { String v = getAttr(Provisioning.A_zimbraMtaLmtpTlsSecurityLevel); return v == null ? null : ZAttrProvisioning.MtaLmtpTlsSecurityLevel.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf lmtp_tls_security_level
     *
     * <p>Valid values: [may, encrypt, dane-only, fingerprint, verify, dane, none, secure]
     *
     * @return zimbraMtaLmtpTlsSecurityLevel, or null if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1660)
    public String getMtaLmtpTlsSecurityLevelAsString() {
        return getAttr(Provisioning.A_zimbraMtaLmtpTlsSecurityLevel, null);
    }

    /**
     * Value for postconf lmtp_tls_security_level
     *
     * <p>Valid values: [may, encrypt, dane-only, fingerprint, verify, dane, none, secure]
     *
     * @param zimbraMtaLmtpTlsSecurityLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1660)
    public void setMtaLmtpTlsSecurityLevel(ZAttrProvisioning.MtaLmtpTlsSecurityLevel zimbraMtaLmtpTlsSecurityLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsSecurityLevel, zimbraMtaLmtpTlsSecurityLevel.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_security_level
     *
     * <p>Valid values: [may, encrypt, dane-only, fingerprint, verify, dane, none, secure]
     *
     * @param zimbraMtaLmtpTlsSecurityLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1660)
    public Map<String,Object> setMtaLmtpTlsSecurityLevel(ZAttrProvisioning.MtaLmtpTlsSecurityLevel zimbraMtaLmtpTlsSecurityLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsSecurityLevel, zimbraMtaLmtpTlsSecurityLevel.toString());
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_security_level
     *
     * <p>Valid values: [may, encrypt, dane-only, fingerprint, verify, dane, none, secure]
     *
     * @param zimbraMtaLmtpTlsSecurityLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1660)
    public void setMtaLmtpTlsSecurityLevelAsString(String zimbraMtaLmtpTlsSecurityLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsSecurityLevel, zimbraMtaLmtpTlsSecurityLevel);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_security_level
     *
     * <p>Valid values: [may, encrypt, dane-only, fingerprint, verify, dane, none, secure]
     *
     * @param zimbraMtaLmtpTlsSecurityLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1660)
    public Map<String,Object> setMtaLmtpTlsSecurityLevelAsString(String zimbraMtaLmtpTlsSecurityLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsSecurityLevel, zimbraMtaLmtpTlsSecurityLevel);
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_security_level
     *
     * <p>Valid values: [may, encrypt, dane-only, fingerprint, verify, dane, none, secure]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1660)
    public void unsetMtaLmtpTlsSecurityLevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsSecurityLevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_security_level
     *
     * <p>Valid values: [may, encrypt, dane-only, fingerprint, verify, dane, none, secure]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1660)
    public Map<String,Object> unsetMtaLmtpTlsSecurityLevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsSecurityLevel, "");
        return attrs;
    }

    /**
     * Value for postconf mailq_path
     *
     * @return zimbraMtaMailqPath, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1508)
    public String getMtaMailqPath() {
        return getAttr(Provisioning.A_zimbraMtaMailqPath, null);
    }

    /**
     * Value for postconf mailq_path
     *
     * @param zimbraMtaMailqPath new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1508)
    public void setMtaMailqPath(String zimbraMtaMailqPath) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMailqPath, zimbraMtaMailqPath);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf mailq_path
     *
     * @param zimbraMtaMailqPath new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1508)
    public Map<String,Object> setMtaMailqPath(String zimbraMtaMailqPath, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMailqPath, zimbraMtaMailqPath);
        return attrs;
    }

    /**
     * Value for postconf mailq_path
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1508)
    public void unsetMtaMailqPath() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMailqPath, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf mailq_path
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1508)
    public Map<String,Object> unsetMtaMailqPath(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMailqPath, "");
        return attrs;
    }

    /**
     * Value for postconf manpage_directory
     *
     * @return zimbraMtaManpageDirectory, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1509)
    public String getMtaManpageDirectory() {
        return getAttr(Provisioning.A_zimbraMtaManpageDirectory, null);
    }

    /**
     * Value for postconf manpage_directory
     *
     * @param zimbraMtaManpageDirectory new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1509)
    public void setMtaManpageDirectory(String zimbraMtaManpageDirectory) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaManpageDirectory, zimbraMtaManpageDirectory);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf manpage_directory
     *
     * @param zimbraMtaManpageDirectory new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1509)
    public Map<String,Object> setMtaManpageDirectory(String zimbraMtaManpageDirectory, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaManpageDirectory, zimbraMtaManpageDirectory);
        return attrs;
    }

    /**
     * Value for postconf manpage_directory
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1509)
    public void unsetMtaManpageDirectory() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaManpageDirectory, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf manpage_directory
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1509)
    public Map<String,Object> unsetMtaManpageDirectory(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaManpageDirectory, "");
        return attrs;
    }

    /**
     * Value for postconf max_use
     *
     * @return zimbraMtaMaxUse, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1531)
    public int getMtaMaxUse() {
        return getIntAttr(Provisioning.A_zimbraMtaMaxUse, -1);
    }

    /**
     * Value for postconf max_use
     *
     * @param zimbraMtaMaxUse new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1531)
    public void setMtaMaxUse(int zimbraMtaMaxUse) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaxUse, Integer.toString(zimbraMtaMaxUse));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf max_use
     *
     * @param zimbraMtaMaxUse new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1531)
    public Map<String,Object> setMtaMaxUse(int zimbraMtaMaxUse, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaxUse, Integer.toString(zimbraMtaMaxUse));
        return attrs;
    }

    /**
     * Value for postconf max_use
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1531)
    public void unsetMtaMaxUse() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaxUse, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf max_use
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1531)
    public Map<String,Object> unsetMtaMaxUse(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaxUse, "");
        return attrs;
    }

    /**
     * Value for postconf maximal_backoff_time
     *
     * @return zimbraMtaMaximalBackoffTime, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1517)
    public String getMtaMaximalBackoffTime() {
        return getAttr(Provisioning.A_zimbraMtaMaximalBackoffTime, null);
    }

    /**
     * Value for postconf maximal_backoff_time
     *
     * @param zimbraMtaMaximalBackoffTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1517)
    public void setMtaMaximalBackoffTime(String zimbraMtaMaximalBackoffTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaximalBackoffTime, zimbraMtaMaximalBackoffTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf maximal_backoff_time
     *
     * @param zimbraMtaMaximalBackoffTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1517)
    public Map<String,Object> setMtaMaximalBackoffTime(String zimbraMtaMaximalBackoffTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaximalBackoffTime, zimbraMtaMaximalBackoffTime);
        return attrs;
    }

    /**
     * Value for postconf maximal_backoff_time
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1517)
    public void unsetMtaMaximalBackoffTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaximalBackoffTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf maximal_backoff_time
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1517)
    public Map<String,Object> unsetMtaMaximalBackoffTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaximalBackoffTime, "");
        return attrs;
    }

    /**
     * Value for postconf milter_command_timeout
     *
     * @return zimbraMtaMilterCommandTimeout, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1521)
    public String getMtaMilterCommandTimeout() {
        return getAttr(Provisioning.A_zimbraMtaMilterCommandTimeout, null);
    }

    /**
     * Value for postconf milter_command_timeout
     *
     * @param zimbraMtaMilterCommandTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1521)
    public void setMtaMilterCommandTimeout(String zimbraMtaMilterCommandTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterCommandTimeout, zimbraMtaMilterCommandTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf milter_command_timeout
     *
     * @param zimbraMtaMilterCommandTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1521)
    public Map<String,Object> setMtaMilterCommandTimeout(String zimbraMtaMilterCommandTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterCommandTimeout, zimbraMtaMilterCommandTimeout);
        return attrs;
    }

    /**
     * Value for postconf milter_command_timeout
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1521)
    public void unsetMtaMilterCommandTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterCommandTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf milter_command_timeout
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1521)
    public Map<String,Object> unsetMtaMilterCommandTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterCommandTimeout, "");
        return attrs;
    }

    /**
     * Value for postconf milter_connect_timeout
     *
     * @return zimbraMtaMilterConnectTimeout, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1520)
    public String getMtaMilterConnectTimeout() {
        return getAttr(Provisioning.A_zimbraMtaMilterConnectTimeout, null);
    }

    /**
     * Value for postconf milter_connect_timeout
     *
     * @param zimbraMtaMilterConnectTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1520)
    public void setMtaMilterConnectTimeout(String zimbraMtaMilterConnectTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterConnectTimeout, zimbraMtaMilterConnectTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf milter_connect_timeout
     *
     * @param zimbraMtaMilterConnectTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1520)
    public Map<String,Object> setMtaMilterConnectTimeout(String zimbraMtaMilterConnectTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterConnectTimeout, zimbraMtaMilterConnectTimeout);
        return attrs;
    }

    /**
     * Value for postconf milter_connect_timeout
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1520)
    public void unsetMtaMilterConnectTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterConnectTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf milter_connect_timeout
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1520)
    public Map<String,Object> unsetMtaMilterConnectTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterConnectTimeout, "");
        return attrs;
    }

    /**
     * Value for postconf milter_content_timeout
     *
     * @return zimbraMtaMilterContentTimeout, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1522)
    public String getMtaMilterContentTimeout() {
        return getAttr(Provisioning.A_zimbraMtaMilterContentTimeout, null);
    }

    /**
     * Value for postconf milter_content_timeout
     *
     * @param zimbraMtaMilterContentTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1522)
    public void setMtaMilterContentTimeout(String zimbraMtaMilterContentTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterContentTimeout, zimbraMtaMilterContentTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf milter_content_timeout
     *
     * @param zimbraMtaMilterContentTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1522)
    public Map<String,Object> setMtaMilterContentTimeout(String zimbraMtaMilterContentTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterContentTimeout, zimbraMtaMilterContentTimeout);
        return attrs;
    }

    /**
     * Value for postconf milter_content_timeout
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1522)
    public void unsetMtaMilterContentTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterContentTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf milter_content_timeout
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1522)
    public Map<String,Object> unsetMtaMilterContentTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterContentTimeout, "");
        return attrs;
    }

    /**
     * Value for postconf milter_default_action
     *
     * <p>Valid values: [tempfail, quarantine, reject, accept]
     *
     * @return zimbraMtaMilterDefaultAction, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1523)
    public ZAttrProvisioning.MtaMilterDefaultAction getMtaMilterDefaultAction() {
        try { String v = getAttr(Provisioning.A_zimbraMtaMilterDefaultAction); return v == null ? null : ZAttrProvisioning.MtaMilterDefaultAction.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf milter_default_action
     *
     * <p>Valid values: [tempfail, quarantine, reject, accept]
     *
     * @return zimbraMtaMilterDefaultAction, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1523)
    public String getMtaMilterDefaultActionAsString() {
        return getAttr(Provisioning.A_zimbraMtaMilterDefaultAction, null);
    }

    /**
     * Value for postconf milter_default_action
     *
     * <p>Valid values: [tempfail, quarantine, reject, accept]
     *
     * @param zimbraMtaMilterDefaultAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1523)
    public void setMtaMilterDefaultAction(ZAttrProvisioning.MtaMilterDefaultAction zimbraMtaMilterDefaultAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterDefaultAction, zimbraMtaMilterDefaultAction.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf milter_default_action
     *
     * <p>Valid values: [tempfail, quarantine, reject, accept]
     *
     * @param zimbraMtaMilterDefaultAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1523)
    public Map<String,Object> setMtaMilterDefaultAction(ZAttrProvisioning.MtaMilterDefaultAction zimbraMtaMilterDefaultAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterDefaultAction, zimbraMtaMilterDefaultAction.toString());
        return attrs;
    }

    /**
     * Value for postconf milter_default_action
     *
     * <p>Valid values: [tempfail, quarantine, reject, accept]
     *
     * @param zimbraMtaMilterDefaultAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1523)
    public void setMtaMilterDefaultActionAsString(String zimbraMtaMilterDefaultAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterDefaultAction, zimbraMtaMilterDefaultAction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf milter_default_action
     *
     * <p>Valid values: [tempfail, quarantine, reject, accept]
     *
     * @param zimbraMtaMilterDefaultAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1523)
    public Map<String,Object> setMtaMilterDefaultActionAsString(String zimbraMtaMilterDefaultAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterDefaultAction, zimbraMtaMilterDefaultAction);
        return attrs;
    }

    /**
     * Value for postconf milter_default_action
     *
     * <p>Valid values: [tempfail, quarantine, reject, accept]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1523)
    public void unsetMtaMilterDefaultAction() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterDefaultAction, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf milter_default_action
     *
     * <p>Valid values: [tempfail, quarantine, reject, accept]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1523)
    public Map<String,Object> unsetMtaMilterDefaultAction(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterDefaultAction, "");
        return attrs;
    }

    /**
     * Value for postconf minimal_backoff_time
     *
     * @return zimbraMtaMinimalBackoffTime, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1518)
    public String getMtaMinimalBackoffTime() {
        return getAttr(Provisioning.A_zimbraMtaMinimalBackoffTime, null);
    }

    /**
     * Value for postconf minimal_backoff_time
     *
     * @param zimbraMtaMinimalBackoffTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1518)
    public void setMtaMinimalBackoffTime(String zimbraMtaMinimalBackoffTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMinimalBackoffTime, zimbraMtaMinimalBackoffTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf minimal_backoff_time
     *
     * @param zimbraMtaMinimalBackoffTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1518)
    public Map<String,Object> setMtaMinimalBackoffTime(String zimbraMtaMinimalBackoffTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMinimalBackoffTime, zimbraMtaMinimalBackoffTime);
        return attrs;
    }

    /**
     * Value for postconf minimal_backoff_time
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1518)
    public void unsetMtaMinimalBackoffTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMinimalBackoffTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf minimal_backoff_time
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1518)
    public Map<String,Object> unsetMtaMinimalBackoffTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMinimalBackoffTime, "");
        return attrs;
    }

    /**
     * value of postfix mydestination
     *
     * @return zimbraMtaMyDestination, or null if unset
     */
    @ZAttr(id=524)
    public String getMtaMyDestination() {
        return getAttr(Provisioning.A_zimbraMtaMyDestination, null);
    }

    /**
     * value of postfix mydestination
     *
     * @param zimbraMtaMyDestination new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=524)
    public void setMtaMyDestination(String zimbraMtaMyDestination) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyDestination, zimbraMtaMyDestination);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix mydestination
     *
     * @param zimbraMtaMyDestination new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=524)
    public Map<String,Object> setMtaMyDestination(String zimbraMtaMyDestination, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyDestination, zimbraMtaMyDestination);
        return attrs;
    }

    /**
     * value of postfix mydestination
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=524)
    public void unsetMtaMyDestination() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyDestination, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix mydestination
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=524)
    public Map<String,Object> unsetMtaMyDestination(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyDestination, "");
        return attrs;
    }

    /**
     * value of postfix myhostname
     *
     * @return zimbraMtaMyHostname, or null if unset
     */
    @ZAttr(id=509)
    public String getMtaMyHostname() {
        return getAttr(Provisioning.A_zimbraMtaMyHostname, null);
    }

    /**
     * value of postfix myhostname
     *
     * @param zimbraMtaMyHostname new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=509)
    public void setMtaMyHostname(String zimbraMtaMyHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyHostname, zimbraMtaMyHostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix myhostname
     *
     * @param zimbraMtaMyHostname new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=509)
    public Map<String,Object> setMtaMyHostname(String zimbraMtaMyHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyHostname, zimbraMtaMyHostname);
        return attrs;
    }

    /**
     * value of postfix myhostname
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=509)
    public void unsetMtaMyHostname() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyHostname, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix myhostname
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=509)
    public Map<String,Object> unsetMtaMyHostname(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyHostname, "");
        return attrs;
    }

    /**
     * value of postfix mynetworks
     *
     * @return zimbraMtaMyNetworks, or empty array if unset
     */
    @ZAttr(id=311)
    public String[] getMtaMyNetworks() {
        return getMultiAttr(Provisioning.A_zimbraMtaMyNetworks);
    }

    /**
     * value of postfix mynetworks
     *
     * @param zimbraMtaMyNetworks new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=311)
    public void setMtaMyNetworks(String[] zimbraMtaMyNetworks) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyNetworks, zimbraMtaMyNetworks);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix mynetworks
     *
     * @param zimbraMtaMyNetworks new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=311)
    public Map<String,Object> setMtaMyNetworks(String[] zimbraMtaMyNetworks, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyNetworks, zimbraMtaMyNetworks);
        return attrs;
    }

    /**
     * value of postfix mynetworks
     *
     * @param zimbraMtaMyNetworks new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=311)
    public void addMtaMyNetworks(String zimbraMtaMyNetworks) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaMyNetworks, zimbraMtaMyNetworks);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix mynetworks
     *
     * @param zimbraMtaMyNetworks new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=311)
    public Map<String,Object> addMtaMyNetworks(String zimbraMtaMyNetworks, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaMyNetworks, zimbraMtaMyNetworks);
        return attrs;
    }

    /**
     * value of postfix mynetworks
     *
     * @param zimbraMtaMyNetworks existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=311)
    public void removeMtaMyNetworks(String zimbraMtaMyNetworks) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaMyNetworks, zimbraMtaMyNetworks);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix mynetworks
     *
     * @param zimbraMtaMyNetworks existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=311)
    public Map<String,Object> removeMtaMyNetworks(String zimbraMtaMyNetworks, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaMyNetworks, zimbraMtaMyNetworks);
        return attrs;
    }

    /**
     * value of postfix mynetworks
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=311)
    public void unsetMtaMyNetworks() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyNetworks, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix mynetworks
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=311)
    public Map<String,Object> unsetMtaMyNetworks(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyNetworks, "");
        return attrs;
    }

    /**
     * value of postfix myorigin
     *
     * @return zimbraMtaMyOrigin, or null if unset
     */
    @ZAttr(id=510)
    public String getMtaMyOrigin() {
        return getAttr(Provisioning.A_zimbraMtaMyOrigin, null);
    }

    /**
     * value of postfix myorigin
     *
     * @param zimbraMtaMyOrigin new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=510)
    public void setMtaMyOrigin(String zimbraMtaMyOrigin) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyOrigin, zimbraMtaMyOrigin);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix myorigin
     *
     * @param zimbraMtaMyOrigin new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=510)
    public Map<String,Object> setMtaMyOrigin(String zimbraMtaMyOrigin, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyOrigin, zimbraMtaMyOrigin);
        return attrs;
    }

    /**
     * value of postfix myorigin
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=510)
    public void unsetMtaMyOrigin() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyOrigin, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix myorigin
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=510)
    public Map<String,Object> unsetMtaMyOrigin(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyOrigin, "");
        return attrs;
    }

    /**
     * Value for postconf newaliases_path
     *
     * @return zimbraMtaNewaliasesPath, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1510)
    public String getMtaNewaliasesPath() {
        return getAttr(Provisioning.A_zimbraMtaNewaliasesPath, null);
    }

    /**
     * Value for postconf newaliases_path
     *
     * @param zimbraMtaNewaliasesPath new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1510)
    public void setMtaNewaliasesPath(String zimbraMtaNewaliasesPath) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNewaliasesPath, zimbraMtaNewaliasesPath);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf newaliases_path
     *
     * @param zimbraMtaNewaliasesPath new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1510)
    public Map<String,Object> setMtaNewaliasesPath(String zimbraMtaNewaliasesPath, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNewaliasesPath, zimbraMtaNewaliasesPath);
        return attrs;
    }

    /**
     * Value for postconf newaliases_path
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1510)
    public void unsetMtaNewaliasesPath() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNewaliasesPath, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf newaliases_path
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1510)
    public Map<String,Object> unsetMtaNewaliasesPath(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNewaliasesPath, "");
        return attrs;
    }

    /**
     * value for postfix non_smtpd_milters
     *
     * @return zimbraMtaNonSmtpdMilters, or null if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=673)
    public String getMtaNonSmtpdMilters() {
        return getAttr(Provisioning.A_zimbraMtaNonSmtpdMilters, null);
    }

    /**
     * value for postfix non_smtpd_milters
     *
     * @param zimbraMtaNonSmtpdMilters new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=673)
    public void setMtaNonSmtpdMilters(String zimbraMtaNonSmtpdMilters) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNonSmtpdMilters, zimbraMtaNonSmtpdMilters);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value for postfix non_smtpd_milters
     *
     * @param zimbraMtaNonSmtpdMilters new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=673)
    public Map<String,Object> setMtaNonSmtpdMilters(String zimbraMtaNonSmtpdMilters, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNonSmtpdMilters, zimbraMtaNonSmtpdMilters);
        return attrs;
    }

    /**
     * value for postfix non_smtpd_milters
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=673)
    public void unsetMtaNonSmtpdMilters() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNonSmtpdMilters, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value for postfix non_smtpd_milters
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=673)
    public Map<String,Object> unsetMtaNonSmtpdMilters(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNonSmtpdMilters, "");
        return attrs;
    }

    /**
     * Value for postconf notify_classes
     *
     * <p>Valid values: [protocol, delay, data, software, bounce, resource, 2bounce, policy]
     *
     * @return zimbraMtaNotifyClasses, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1546)
    public String[] getMtaNotifyClassesAsString() {
        return getMultiAttr(Provisioning.A_zimbraMtaNotifyClasses);
    }

    /**
     * Value for postconf notify_classes
     *
     * <p>Valid values: [protocol, delay, data, software, bounce, resource, 2bounce, policy]
     *
     * @param zimbraMtaNotifyClasses new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1546)
    public void setMtaNotifyClasses(ZAttrProvisioning.MtaNotifyClasses zimbraMtaNotifyClasses) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNotifyClasses, zimbraMtaNotifyClasses.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf notify_classes
     *
     * <p>Valid values: [protocol, delay, data, software, bounce, resource, 2bounce, policy]
     *
     * @param zimbraMtaNotifyClasses new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1546)
    public Map<String,Object> setMtaNotifyClasses(ZAttrProvisioning.MtaNotifyClasses zimbraMtaNotifyClasses, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNotifyClasses, zimbraMtaNotifyClasses.toString());
        return attrs;
    }

    /**
     * Value for postconf notify_classes
     *
     * <p>Valid values: [protocol, delay, data, software, bounce, resource, 2bounce, policy]
     *
     * @param zimbraMtaNotifyClasses new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1546)
    public void setMtaNotifyClassesAsString(String[] zimbraMtaNotifyClasses) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNotifyClasses, zimbraMtaNotifyClasses);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf notify_classes
     *
     * <p>Valid values: [protocol, delay, data, software, bounce, resource, 2bounce, policy]
     *
     * @param zimbraMtaNotifyClasses new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1546)
    public Map<String,Object> setMtaNotifyClassesAsString(String[] zimbraMtaNotifyClasses, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNotifyClasses, zimbraMtaNotifyClasses);
        return attrs;
    }

    /**
     * Value for postconf notify_classes
     *
     * <p>Valid values: [protocol, delay, data, software, bounce, resource, 2bounce, policy]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1546)
    public void unsetMtaNotifyClasses() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNotifyClasses, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf notify_classes
     *
     * <p>Valid values: [protocol, delay, data, software, bounce, resource, 2bounce, policy]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1546)
    public Map<String,Object> unsetMtaNotifyClasses(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNotifyClasses, "");
        return attrs;
    }

    /**
     * Value for postconf policy_time_limit
     *
     * @return zimbraMtaPolicyTimeLimit, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1530)
    public int getMtaPolicyTimeLimit() {
        return getIntAttr(Provisioning.A_zimbraMtaPolicyTimeLimit, -1);
    }

    /**
     * Value for postconf policy_time_limit
     *
     * @param zimbraMtaPolicyTimeLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1530)
    public void setMtaPolicyTimeLimit(int zimbraMtaPolicyTimeLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPolicyTimeLimit, Integer.toString(zimbraMtaPolicyTimeLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf policy_time_limit
     *
     * @param zimbraMtaPolicyTimeLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1530)
    public Map<String,Object> setMtaPolicyTimeLimit(int zimbraMtaPolicyTimeLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPolicyTimeLimit, Integer.toString(zimbraMtaPolicyTimeLimit));
        return attrs;
    }

    /**
     * Value for postconf policy_time_limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1530)
    public void unsetMtaPolicyTimeLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPolicyTimeLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf policy_time_limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1530)
    public Map<String,Object> unsetMtaPolicyTimeLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPolicyTimeLimit, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_access_list. Single valued, commas
     * separated list.
     *
     * @return zimbraMtaPostscreenAccessList, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1917)
    public String getMtaPostscreenAccessList() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenAccessList, null);
    }

    /**
     * Value for postconf postscreen_access_list. Single valued, commas
     * separated list.
     *
     * @param zimbraMtaPostscreenAccessList new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1917)
    public void setMtaPostscreenAccessList(String zimbraMtaPostscreenAccessList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenAccessList, zimbraMtaPostscreenAccessList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_access_list. Single valued, commas
     * separated list.
     *
     * @param zimbraMtaPostscreenAccessList new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1917)
    public Map<String,Object> setMtaPostscreenAccessList(String zimbraMtaPostscreenAccessList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenAccessList, zimbraMtaPostscreenAccessList);
        return attrs;
    }

    /**
     * Value for postconf postscreen_access_list. Single valued, commas
     * separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1917)
    public void unsetMtaPostscreenAccessList() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenAccessList, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_access_list. Single valued, commas
     * separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1917)
    public Map<String,Object> unsetMtaPostscreenAccessList(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenAccessList, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_bare_newline_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @return zimbraMtaPostscreenBareNewlineAction, or null if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1918)
    public ZAttrProvisioning.MtaPostscreenBareNewlineAction getMtaPostscreenBareNewlineAction() {
        try { String v = getAttr(Provisioning.A_zimbraMtaPostscreenBareNewlineAction); return v == null ? null : ZAttrProvisioning.MtaPostscreenBareNewlineAction.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf postscreen_bare_newline_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @return zimbraMtaPostscreenBareNewlineAction, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1918)
    public String getMtaPostscreenBareNewlineActionAsString() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenBareNewlineAction, null);
    }

    /**
     * Value for postconf postscreen_bare_newline_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenBareNewlineAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1918)
    public void setMtaPostscreenBareNewlineAction(ZAttrProvisioning.MtaPostscreenBareNewlineAction zimbraMtaPostscreenBareNewlineAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineAction, zimbraMtaPostscreenBareNewlineAction.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_bare_newline_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenBareNewlineAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1918)
    public Map<String,Object> setMtaPostscreenBareNewlineAction(ZAttrProvisioning.MtaPostscreenBareNewlineAction zimbraMtaPostscreenBareNewlineAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineAction, zimbraMtaPostscreenBareNewlineAction.toString());
        return attrs;
    }

    /**
     * Value for postconf postscreen_bare_newline_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenBareNewlineAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1918)
    public void setMtaPostscreenBareNewlineActionAsString(String zimbraMtaPostscreenBareNewlineAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineAction, zimbraMtaPostscreenBareNewlineAction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_bare_newline_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenBareNewlineAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1918)
    public Map<String,Object> setMtaPostscreenBareNewlineActionAsString(String zimbraMtaPostscreenBareNewlineAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineAction, zimbraMtaPostscreenBareNewlineAction);
        return attrs;
    }

    /**
     * Value for postconf postscreen_bare_newline_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1918)
    public void unsetMtaPostscreenBareNewlineAction() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineAction, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_bare_newline_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1918)
    public Map<String,Object> unsetMtaPostscreenBareNewlineAction(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineAction, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_bare_newline_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaPostscreenBareNewlineEnable, or null if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1919)
    public ZAttrProvisioning.MtaPostscreenBareNewlineEnable getMtaPostscreenBareNewlineEnable() {
        try { String v = getAttr(Provisioning.A_zimbraMtaPostscreenBareNewlineEnable); return v == null ? null : ZAttrProvisioning.MtaPostscreenBareNewlineEnable.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf postscreen_bare_newline_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaPostscreenBareNewlineEnable, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1919)
    public String getMtaPostscreenBareNewlineEnableAsString() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenBareNewlineEnable, null);
    }

    /**
     * Value for postconf postscreen_bare_newline_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaPostscreenBareNewlineEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1919)
    public void setMtaPostscreenBareNewlineEnable(ZAttrProvisioning.MtaPostscreenBareNewlineEnable zimbraMtaPostscreenBareNewlineEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineEnable, zimbraMtaPostscreenBareNewlineEnable.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_bare_newline_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaPostscreenBareNewlineEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1919)
    public Map<String,Object> setMtaPostscreenBareNewlineEnable(ZAttrProvisioning.MtaPostscreenBareNewlineEnable zimbraMtaPostscreenBareNewlineEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineEnable, zimbraMtaPostscreenBareNewlineEnable.toString());
        return attrs;
    }

    /**
     * Value for postconf postscreen_bare_newline_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaPostscreenBareNewlineEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1919)
    public void setMtaPostscreenBareNewlineEnableAsString(String zimbraMtaPostscreenBareNewlineEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineEnable, zimbraMtaPostscreenBareNewlineEnable);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_bare_newline_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaPostscreenBareNewlineEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1919)
    public Map<String,Object> setMtaPostscreenBareNewlineEnableAsString(String zimbraMtaPostscreenBareNewlineEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineEnable, zimbraMtaPostscreenBareNewlineEnable);
        return attrs;
    }

    /**
     * Value for postconf postscreen_bare_newline_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1919)
    public void unsetMtaPostscreenBareNewlineEnable() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineEnable, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_bare_newline_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1919)
    public Map<String,Object> unsetMtaPostscreenBareNewlineEnable(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineEnable, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_bare_newline_ttl.
     *
     * @return zimbraMtaPostscreenBareNewlineTTL, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1920)
    public String getMtaPostscreenBareNewlineTTL() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenBareNewlineTTL, null);
    }

    /**
     * Value for postconf postscreen_bare_newline_ttl.
     *
     * @param zimbraMtaPostscreenBareNewlineTTL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1920)
    public void setMtaPostscreenBareNewlineTTL(String zimbraMtaPostscreenBareNewlineTTL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineTTL, zimbraMtaPostscreenBareNewlineTTL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_bare_newline_ttl.
     *
     * @param zimbraMtaPostscreenBareNewlineTTL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1920)
    public Map<String,Object> setMtaPostscreenBareNewlineTTL(String zimbraMtaPostscreenBareNewlineTTL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineTTL, zimbraMtaPostscreenBareNewlineTTL);
        return attrs;
    }

    /**
     * Value for postconf postscreen_bare_newline_ttl.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1920)
    public void unsetMtaPostscreenBareNewlineTTL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineTTL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_bare_newline_ttl.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1920)
    public Map<String,Object> unsetMtaPostscreenBareNewlineTTL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineTTL, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_cache_cleanup_interval.
     *
     * @return zimbraMtaPostscreenCacheCleanupInterval, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1922)
    public String getMtaPostscreenCacheCleanupInterval() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenCacheCleanupInterval, null);
    }

    /**
     * Value for postconf postscreen_cache_cleanup_interval.
     *
     * @param zimbraMtaPostscreenCacheCleanupInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1922)
    public void setMtaPostscreenCacheCleanupInterval(String zimbraMtaPostscreenCacheCleanupInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCacheCleanupInterval, zimbraMtaPostscreenCacheCleanupInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_cache_cleanup_interval.
     *
     * @param zimbraMtaPostscreenCacheCleanupInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1922)
    public Map<String,Object> setMtaPostscreenCacheCleanupInterval(String zimbraMtaPostscreenCacheCleanupInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCacheCleanupInterval, zimbraMtaPostscreenCacheCleanupInterval);
        return attrs;
    }

    /**
     * Value for postconf postscreen_cache_cleanup_interval.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1922)
    public void unsetMtaPostscreenCacheCleanupInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCacheCleanupInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_cache_cleanup_interval.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1922)
    public Map<String,Object> unsetMtaPostscreenCacheCleanupInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCacheCleanupInterval, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_cache_retention_time.
     *
     * @return zimbraMtaPostscreenCacheRetentionTime, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1923)
    public String getMtaPostscreenCacheRetentionTime() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenCacheRetentionTime, null);
    }

    /**
     * Value for postconf postscreen_cache_retention_time.
     *
     * @param zimbraMtaPostscreenCacheRetentionTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1923)
    public void setMtaPostscreenCacheRetentionTime(String zimbraMtaPostscreenCacheRetentionTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCacheRetentionTime, zimbraMtaPostscreenCacheRetentionTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_cache_retention_time.
     *
     * @param zimbraMtaPostscreenCacheRetentionTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1923)
    public Map<String,Object> setMtaPostscreenCacheRetentionTime(String zimbraMtaPostscreenCacheRetentionTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCacheRetentionTime, zimbraMtaPostscreenCacheRetentionTime);
        return attrs;
    }

    /**
     * Value for postconf postscreen_cache_retention_time.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1923)
    public void unsetMtaPostscreenCacheRetentionTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCacheRetentionTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_cache_retention_time.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1923)
    public Map<String,Object> unsetMtaPostscreenCacheRetentionTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCacheRetentionTime, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_command_count_limit.
     *
     * @return zimbraMtaPostscreenCommandCountLimit, or -1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1924)
    public int getMtaPostscreenCommandCountLimit() {
        return getIntAttr(Provisioning.A_zimbraMtaPostscreenCommandCountLimit, -1);
    }

    /**
     * Value for postconf postscreen_command_count_limit.
     *
     * @param zimbraMtaPostscreenCommandCountLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1924)
    public void setMtaPostscreenCommandCountLimit(int zimbraMtaPostscreenCommandCountLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCommandCountLimit, Integer.toString(zimbraMtaPostscreenCommandCountLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_command_count_limit.
     *
     * @param zimbraMtaPostscreenCommandCountLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1924)
    public Map<String,Object> setMtaPostscreenCommandCountLimit(int zimbraMtaPostscreenCommandCountLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCommandCountLimit, Integer.toString(zimbraMtaPostscreenCommandCountLimit));
        return attrs;
    }

    /**
     * Value for postconf postscreen_command_count_limit.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1924)
    public void unsetMtaPostscreenCommandCountLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCommandCountLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_command_count_limit.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1924)
    public Map<String,Object> unsetMtaPostscreenCommandCountLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCommandCountLimit, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @return zimbraMtaPostscreenDnsblAction, or null if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1925)
    public ZAttrProvisioning.MtaPostscreenDnsblAction getMtaPostscreenDnsblAction() {
        try { String v = getAttr(Provisioning.A_zimbraMtaPostscreenDnsblAction); return v == null ? null : ZAttrProvisioning.MtaPostscreenDnsblAction.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf postscreen_dnsbl_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @return zimbraMtaPostscreenDnsblAction, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1925)
    public String getMtaPostscreenDnsblActionAsString() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenDnsblAction, null);
    }

    /**
     * Value for postconf postscreen_dnsbl_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenDnsblAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1925)
    public void setMtaPostscreenDnsblAction(ZAttrProvisioning.MtaPostscreenDnsblAction zimbraMtaPostscreenDnsblAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblAction, zimbraMtaPostscreenDnsblAction.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenDnsblAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1925)
    public Map<String,Object> setMtaPostscreenDnsblAction(ZAttrProvisioning.MtaPostscreenDnsblAction zimbraMtaPostscreenDnsblAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblAction, zimbraMtaPostscreenDnsblAction.toString());
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenDnsblAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1925)
    public void setMtaPostscreenDnsblActionAsString(String zimbraMtaPostscreenDnsblAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblAction, zimbraMtaPostscreenDnsblAction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenDnsblAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1925)
    public Map<String,Object> setMtaPostscreenDnsblActionAsString(String zimbraMtaPostscreenDnsblAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblAction, zimbraMtaPostscreenDnsblAction);
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1925)
    public void unsetMtaPostscreenDnsblAction() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblAction, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1925)
    public Map<String,Object> unsetMtaPostscreenDnsblAction(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblAction, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_reply_map. Single valued, comma
     * separated list.
     *
     * @return zimbraMtaPostscreenDnsblReplyMap, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1941)
    public String getMtaPostscreenDnsblReplyMap() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenDnsblReplyMap, null);
    }

    /**
     * Value for postconf postscreen_dnsbl_reply_map. Single valued, comma
     * separated list.
     *
     * @param zimbraMtaPostscreenDnsblReplyMap new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1941)
    public void setMtaPostscreenDnsblReplyMap(String zimbraMtaPostscreenDnsblReplyMap) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblReplyMap, zimbraMtaPostscreenDnsblReplyMap);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_reply_map. Single valued, comma
     * separated list.
     *
     * @param zimbraMtaPostscreenDnsblReplyMap new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1941)
    public Map<String,Object> setMtaPostscreenDnsblReplyMap(String zimbraMtaPostscreenDnsblReplyMap, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblReplyMap, zimbraMtaPostscreenDnsblReplyMap);
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_reply_map. Single valued, comma
     * separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1941)
    public void unsetMtaPostscreenDnsblReplyMap() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblReplyMap, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_reply_map. Single valued, comma
     * separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1941)
    public Map<String,Object> unsetMtaPostscreenDnsblReplyMap(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblReplyMap, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_sites. Multi valued, one DNSBL
     * value pair per attribute value.
     *
     * @return zimbraMtaPostscreenDnsblSites, or empty array if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1926)
    public String[] getMtaPostscreenDnsblSites() {
        return getMultiAttr(Provisioning.A_zimbraMtaPostscreenDnsblSites);
    }

    /**
     * Value for postconf postscreen_dnsbl_sites. Multi valued, one DNSBL
     * value pair per attribute value.
     *
     * @param zimbraMtaPostscreenDnsblSites new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1926)
    public void setMtaPostscreenDnsblSites(String[] zimbraMtaPostscreenDnsblSites) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblSites, zimbraMtaPostscreenDnsblSites);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_sites. Multi valued, one DNSBL
     * value pair per attribute value.
     *
     * @param zimbraMtaPostscreenDnsblSites new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1926)
    public Map<String,Object> setMtaPostscreenDnsblSites(String[] zimbraMtaPostscreenDnsblSites, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblSites, zimbraMtaPostscreenDnsblSites);
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_sites. Multi valued, one DNSBL
     * value pair per attribute value.
     *
     * @param zimbraMtaPostscreenDnsblSites new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1926)
    public void addMtaPostscreenDnsblSites(String zimbraMtaPostscreenDnsblSites) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaPostscreenDnsblSites, zimbraMtaPostscreenDnsblSites);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_sites. Multi valued, one DNSBL
     * value pair per attribute value.
     *
     * @param zimbraMtaPostscreenDnsblSites new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1926)
    public Map<String,Object> addMtaPostscreenDnsblSites(String zimbraMtaPostscreenDnsblSites, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaPostscreenDnsblSites, zimbraMtaPostscreenDnsblSites);
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_sites. Multi valued, one DNSBL
     * value pair per attribute value.
     *
     * @param zimbraMtaPostscreenDnsblSites existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1926)
    public void removeMtaPostscreenDnsblSites(String zimbraMtaPostscreenDnsblSites) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaPostscreenDnsblSites, zimbraMtaPostscreenDnsblSites);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_sites. Multi valued, one DNSBL
     * value pair per attribute value.
     *
     * @param zimbraMtaPostscreenDnsblSites existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1926)
    public Map<String,Object> removeMtaPostscreenDnsblSites(String zimbraMtaPostscreenDnsblSites, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaPostscreenDnsblSites, zimbraMtaPostscreenDnsblSites);
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_sites. Multi valued, one DNSBL
     * value pair per attribute value.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1926)
    public void unsetMtaPostscreenDnsblSites() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblSites, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_sites. Multi valued, one DNSBL
     * value pair per attribute value.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1926)
    public Map<String,Object> unsetMtaPostscreenDnsblSites(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblSites, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_ttl.
     *
     * @return zimbraMtaPostscreenDnsblTTL, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1929)
    public String getMtaPostscreenDnsblTTL() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenDnsblTTL, null);
    }

    /**
     * Value for postconf postscreen_dnsbl_ttl.
     *
     * @param zimbraMtaPostscreenDnsblTTL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1929)
    public void setMtaPostscreenDnsblTTL(String zimbraMtaPostscreenDnsblTTL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblTTL, zimbraMtaPostscreenDnsblTTL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_ttl.
     *
     * @param zimbraMtaPostscreenDnsblTTL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1929)
    public Map<String,Object> setMtaPostscreenDnsblTTL(String zimbraMtaPostscreenDnsblTTL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblTTL, zimbraMtaPostscreenDnsblTTL);
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_ttl.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1929)
    public void unsetMtaPostscreenDnsblTTL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblTTL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_ttl.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1929)
    public Map<String,Object> unsetMtaPostscreenDnsblTTL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblTTL, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_threshold.
     *
     * @return zimbraMtaPostscreenDnsblThreshold, or -1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1927)
    public int getMtaPostscreenDnsblThreshold() {
        return getIntAttr(Provisioning.A_zimbraMtaPostscreenDnsblThreshold, -1);
    }

    /**
     * Value for postconf postscreen_dnsbl_threshold.
     *
     * @param zimbraMtaPostscreenDnsblThreshold new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1927)
    public void setMtaPostscreenDnsblThreshold(int zimbraMtaPostscreenDnsblThreshold) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblThreshold, Integer.toString(zimbraMtaPostscreenDnsblThreshold));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_threshold.
     *
     * @param zimbraMtaPostscreenDnsblThreshold new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1927)
    public Map<String,Object> setMtaPostscreenDnsblThreshold(int zimbraMtaPostscreenDnsblThreshold, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblThreshold, Integer.toString(zimbraMtaPostscreenDnsblThreshold));
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_threshold.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1927)
    public void unsetMtaPostscreenDnsblThreshold() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblThreshold, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_threshold.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1927)
    public Map<String,Object> unsetMtaPostscreenDnsblThreshold(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblThreshold, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_timeout.
     *
     * @return zimbraMtaPostscreenDnsblTimeout, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1928)
    public String getMtaPostscreenDnsblTimeout() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenDnsblTimeout, null);
    }

    /**
     * Value for postconf postscreen_dnsbl_timeout.
     *
     * @param zimbraMtaPostscreenDnsblTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1928)
    public void setMtaPostscreenDnsblTimeout(String zimbraMtaPostscreenDnsblTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblTimeout, zimbraMtaPostscreenDnsblTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_timeout.
     *
     * @param zimbraMtaPostscreenDnsblTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1928)
    public Map<String,Object> setMtaPostscreenDnsblTimeout(String zimbraMtaPostscreenDnsblTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblTimeout, zimbraMtaPostscreenDnsblTimeout);
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_timeout.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1928)
    public void unsetMtaPostscreenDnsblTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_timeout.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1928)
    public Map<String,Object> unsetMtaPostscreenDnsblTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblTimeout, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_whitelist_threshold.
     *
     * @return zimbraMtaPostscreenDnsblWhitelistThreshold, or -1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1930)
    public int getMtaPostscreenDnsblWhitelistThreshold() {
        return getIntAttr(Provisioning.A_zimbraMtaPostscreenDnsblWhitelistThreshold, -1);
    }

    /**
     * Value for postconf postscreen_dnsbl_whitelist_threshold.
     *
     * @param zimbraMtaPostscreenDnsblWhitelistThreshold new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1930)
    public void setMtaPostscreenDnsblWhitelistThreshold(int zimbraMtaPostscreenDnsblWhitelistThreshold) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblWhitelistThreshold, Integer.toString(zimbraMtaPostscreenDnsblWhitelistThreshold));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_whitelist_threshold.
     *
     * @param zimbraMtaPostscreenDnsblWhitelistThreshold new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1930)
    public Map<String,Object> setMtaPostscreenDnsblWhitelistThreshold(int zimbraMtaPostscreenDnsblWhitelistThreshold, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblWhitelistThreshold, Integer.toString(zimbraMtaPostscreenDnsblWhitelistThreshold));
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_whitelist_threshold.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1930)
    public void unsetMtaPostscreenDnsblWhitelistThreshold() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblWhitelistThreshold, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_whitelist_threshold.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1930)
    public Map<String,Object> unsetMtaPostscreenDnsblWhitelistThreshold(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblWhitelistThreshold, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_greet_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @return zimbraMtaPostscreenGreetAction, or null if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1931)
    public ZAttrProvisioning.MtaPostscreenGreetAction getMtaPostscreenGreetAction() {
        try { String v = getAttr(Provisioning.A_zimbraMtaPostscreenGreetAction); return v == null ? null : ZAttrProvisioning.MtaPostscreenGreetAction.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf postscreen_greet_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @return zimbraMtaPostscreenGreetAction, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1931)
    public String getMtaPostscreenGreetActionAsString() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenGreetAction, null);
    }

    /**
     * Value for postconf postscreen_greet_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenGreetAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1931)
    public void setMtaPostscreenGreetAction(ZAttrProvisioning.MtaPostscreenGreetAction zimbraMtaPostscreenGreetAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetAction, zimbraMtaPostscreenGreetAction.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_greet_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenGreetAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1931)
    public Map<String,Object> setMtaPostscreenGreetAction(ZAttrProvisioning.MtaPostscreenGreetAction zimbraMtaPostscreenGreetAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetAction, zimbraMtaPostscreenGreetAction.toString());
        return attrs;
    }

    /**
     * Value for postconf postscreen_greet_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenGreetAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1931)
    public void setMtaPostscreenGreetActionAsString(String zimbraMtaPostscreenGreetAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetAction, zimbraMtaPostscreenGreetAction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_greet_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenGreetAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1931)
    public Map<String,Object> setMtaPostscreenGreetActionAsString(String zimbraMtaPostscreenGreetAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetAction, zimbraMtaPostscreenGreetAction);
        return attrs;
    }

    /**
     * Value for postconf postscreen_greet_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1931)
    public void unsetMtaPostscreenGreetAction() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetAction, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_greet_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1931)
    public Map<String,Object> unsetMtaPostscreenGreetAction(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetAction, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_greet_ttl.
     *
     * @return zimbraMtaPostscreenGreetTTL, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1932)
    public String getMtaPostscreenGreetTTL() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenGreetTTL, null);
    }

    /**
     * Value for postconf postscreen_greet_ttl.
     *
     * @param zimbraMtaPostscreenGreetTTL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1932)
    public void setMtaPostscreenGreetTTL(String zimbraMtaPostscreenGreetTTL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetTTL, zimbraMtaPostscreenGreetTTL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_greet_ttl.
     *
     * @param zimbraMtaPostscreenGreetTTL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1932)
    public Map<String,Object> setMtaPostscreenGreetTTL(String zimbraMtaPostscreenGreetTTL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetTTL, zimbraMtaPostscreenGreetTTL);
        return attrs;
    }

    /**
     * Value for postconf postscreen_greet_ttl.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1932)
    public void unsetMtaPostscreenGreetTTL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetTTL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_greet_ttl.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1932)
    public Map<String,Object> unsetMtaPostscreenGreetTTL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetTTL, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_non_smtp_command_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @return zimbraMtaPostscreenNonSmtpCommandAction, or null if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1933)
    public ZAttrProvisioning.MtaPostscreenNonSmtpCommandAction getMtaPostscreenNonSmtpCommandAction() {
        try { String v = getAttr(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandAction); return v == null ? null : ZAttrProvisioning.MtaPostscreenNonSmtpCommandAction.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf postscreen_non_smtp_command_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @return zimbraMtaPostscreenNonSmtpCommandAction, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1933)
    public String getMtaPostscreenNonSmtpCommandActionAsString() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandAction, null);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenNonSmtpCommandAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1933)
    public void setMtaPostscreenNonSmtpCommandAction(ZAttrProvisioning.MtaPostscreenNonSmtpCommandAction zimbraMtaPostscreenNonSmtpCommandAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandAction, zimbraMtaPostscreenNonSmtpCommandAction.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenNonSmtpCommandAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1933)
    public Map<String,Object> setMtaPostscreenNonSmtpCommandAction(ZAttrProvisioning.MtaPostscreenNonSmtpCommandAction zimbraMtaPostscreenNonSmtpCommandAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandAction, zimbraMtaPostscreenNonSmtpCommandAction.toString());
        return attrs;
    }

    /**
     * Value for postconf postscreen_non_smtp_command_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenNonSmtpCommandAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1933)
    public void setMtaPostscreenNonSmtpCommandActionAsString(String zimbraMtaPostscreenNonSmtpCommandAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandAction, zimbraMtaPostscreenNonSmtpCommandAction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenNonSmtpCommandAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1933)
    public Map<String,Object> setMtaPostscreenNonSmtpCommandActionAsString(String zimbraMtaPostscreenNonSmtpCommandAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandAction, zimbraMtaPostscreenNonSmtpCommandAction);
        return attrs;
    }

    /**
     * Value for postconf postscreen_non_smtp_command_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1933)
    public void unsetMtaPostscreenNonSmtpCommandAction() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandAction, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1933)
    public Map<String,Object> unsetMtaPostscreenNonSmtpCommandAction(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandAction, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_non_smtp_command_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaPostscreenNonSmtpCommandEnable, or null if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1934)
    public ZAttrProvisioning.MtaPostscreenNonSmtpCommandEnable getMtaPostscreenNonSmtpCommandEnable() {
        try { String v = getAttr(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandEnable); return v == null ? null : ZAttrProvisioning.MtaPostscreenNonSmtpCommandEnable.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf postscreen_non_smtp_command_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaPostscreenNonSmtpCommandEnable, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1934)
    public String getMtaPostscreenNonSmtpCommandEnableAsString() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandEnable, null);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaPostscreenNonSmtpCommandEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1934)
    public void setMtaPostscreenNonSmtpCommandEnable(ZAttrProvisioning.MtaPostscreenNonSmtpCommandEnable zimbraMtaPostscreenNonSmtpCommandEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandEnable, zimbraMtaPostscreenNonSmtpCommandEnable.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaPostscreenNonSmtpCommandEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1934)
    public Map<String,Object> setMtaPostscreenNonSmtpCommandEnable(ZAttrProvisioning.MtaPostscreenNonSmtpCommandEnable zimbraMtaPostscreenNonSmtpCommandEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandEnable, zimbraMtaPostscreenNonSmtpCommandEnable.toString());
        return attrs;
    }

    /**
     * Value for postconf postscreen_non_smtp_command_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaPostscreenNonSmtpCommandEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1934)
    public void setMtaPostscreenNonSmtpCommandEnableAsString(String zimbraMtaPostscreenNonSmtpCommandEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandEnable, zimbraMtaPostscreenNonSmtpCommandEnable);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaPostscreenNonSmtpCommandEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1934)
    public Map<String,Object> setMtaPostscreenNonSmtpCommandEnableAsString(String zimbraMtaPostscreenNonSmtpCommandEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandEnable, zimbraMtaPostscreenNonSmtpCommandEnable);
        return attrs;
    }

    /**
     * Value for postconf postscreen_non_smtp_command_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1934)
    public void unsetMtaPostscreenNonSmtpCommandEnable() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandEnable, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1934)
    public Map<String,Object> unsetMtaPostscreenNonSmtpCommandEnable(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandEnable, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_non_smtp_command_ttl.
     *
     * @return zimbraMtaPostscreenNonSmtpCommandTTL, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1935)
    public String getMtaPostscreenNonSmtpCommandTTL() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandTTL, null);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_ttl.
     *
     * @param zimbraMtaPostscreenNonSmtpCommandTTL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1935)
    public void setMtaPostscreenNonSmtpCommandTTL(String zimbraMtaPostscreenNonSmtpCommandTTL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandTTL, zimbraMtaPostscreenNonSmtpCommandTTL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_ttl.
     *
     * @param zimbraMtaPostscreenNonSmtpCommandTTL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1935)
    public Map<String,Object> setMtaPostscreenNonSmtpCommandTTL(String zimbraMtaPostscreenNonSmtpCommandTTL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandTTL, zimbraMtaPostscreenNonSmtpCommandTTL);
        return attrs;
    }

    /**
     * Value for postconf postscreen_non_smtp_command_ttl.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1935)
    public void unsetMtaPostscreenNonSmtpCommandTTL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandTTL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_ttl.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1935)
    public Map<String,Object> unsetMtaPostscreenNonSmtpCommandTTL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandTTL, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_pipelining_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @return zimbraMtaPostscreenPipeliningAction, or null if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1936)
    public ZAttrProvisioning.MtaPostscreenPipeliningAction getMtaPostscreenPipeliningAction() {
        try { String v = getAttr(Provisioning.A_zimbraMtaPostscreenPipeliningAction); return v == null ? null : ZAttrProvisioning.MtaPostscreenPipeliningAction.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf postscreen_pipelining_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @return zimbraMtaPostscreenPipeliningAction, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1936)
    public String getMtaPostscreenPipeliningActionAsString() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenPipeliningAction, null);
    }

    /**
     * Value for postconf postscreen_pipelining_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenPipeliningAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1936)
    public void setMtaPostscreenPipeliningAction(ZAttrProvisioning.MtaPostscreenPipeliningAction zimbraMtaPostscreenPipeliningAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningAction, zimbraMtaPostscreenPipeliningAction.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_pipelining_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenPipeliningAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1936)
    public Map<String,Object> setMtaPostscreenPipeliningAction(ZAttrProvisioning.MtaPostscreenPipeliningAction zimbraMtaPostscreenPipeliningAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningAction, zimbraMtaPostscreenPipeliningAction.toString());
        return attrs;
    }

    /**
     * Value for postconf postscreen_pipelining_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenPipeliningAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1936)
    public void setMtaPostscreenPipeliningActionAsString(String zimbraMtaPostscreenPipeliningAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningAction, zimbraMtaPostscreenPipeliningAction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_pipelining_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param zimbraMtaPostscreenPipeliningAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1936)
    public Map<String,Object> setMtaPostscreenPipeliningActionAsString(String zimbraMtaPostscreenPipeliningAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningAction, zimbraMtaPostscreenPipeliningAction);
        return attrs;
    }

    /**
     * Value for postconf postscreen_pipelining_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1936)
    public void unsetMtaPostscreenPipeliningAction() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningAction, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_pipelining_action.
     *
     * <p>Valid values: [drop, ignore, enforce]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1936)
    public Map<String,Object> unsetMtaPostscreenPipeliningAction(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningAction, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_pipelining_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaPostscreenPipeliningEnable, or null if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1937)
    public ZAttrProvisioning.MtaPostscreenPipeliningEnable getMtaPostscreenPipeliningEnable() {
        try { String v = getAttr(Provisioning.A_zimbraMtaPostscreenPipeliningEnable); return v == null ? null : ZAttrProvisioning.MtaPostscreenPipeliningEnable.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf postscreen_pipelining_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaPostscreenPipeliningEnable, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1937)
    public String getMtaPostscreenPipeliningEnableAsString() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenPipeliningEnable, null);
    }

    /**
     * Value for postconf postscreen_pipelining_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaPostscreenPipeliningEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1937)
    public void setMtaPostscreenPipeliningEnable(ZAttrProvisioning.MtaPostscreenPipeliningEnable zimbraMtaPostscreenPipeliningEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningEnable, zimbraMtaPostscreenPipeliningEnable.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_pipelining_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaPostscreenPipeliningEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1937)
    public Map<String,Object> setMtaPostscreenPipeliningEnable(ZAttrProvisioning.MtaPostscreenPipeliningEnable zimbraMtaPostscreenPipeliningEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningEnable, zimbraMtaPostscreenPipeliningEnable.toString());
        return attrs;
    }

    /**
     * Value for postconf postscreen_pipelining_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaPostscreenPipeliningEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1937)
    public void setMtaPostscreenPipeliningEnableAsString(String zimbraMtaPostscreenPipeliningEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningEnable, zimbraMtaPostscreenPipeliningEnable);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_pipelining_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaPostscreenPipeliningEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1937)
    public Map<String,Object> setMtaPostscreenPipeliningEnableAsString(String zimbraMtaPostscreenPipeliningEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningEnable, zimbraMtaPostscreenPipeliningEnable);
        return attrs;
    }

    /**
     * Value for postconf postscreen_pipelining_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1937)
    public void unsetMtaPostscreenPipeliningEnable() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningEnable, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_pipelining_enable.
     *
     * <p>Valid values: [no, yes]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1937)
    public Map<String,Object> unsetMtaPostscreenPipeliningEnable(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningEnable, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_pipelining_ttl.
     *
     * @return zimbraMtaPostscreenPipeliningTTL, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1938)
    public String getMtaPostscreenPipeliningTTL() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenPipeliningTTL, null);
    }

    /**
     * Value for postconf postscreen_pipelining_ttl.
     *
     * @param zimbraMtaPostscreenPipeliningTTL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1938)
    public void setMtaPostscreenPipeliningTTL(String zimbraMtaPostscreenPipeliningTTL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningTTL, zimbraMtaPostscreenPipeliningTTL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_pipelining_ttl.
     *
     * @param zimbraMtaPostscreenPipeliningTTL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1938)
    public Map<String,Object> setMtaPostscreenPipeliningTTL(String zimbraMtaPostscreenPipeliningTTL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningTTL, zimbraMtaPostscreenPipeliningTTL);
        return attrs;
    }

    /**
     * Value for postconf postscreen_pipelining_ttl.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1938)
    public void unsetMtaPostscreenPipeliningTTL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningTTL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_pipelining_ttl.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1938)
    public Map<String,Object> unsetMtaPostscreenPipeliningTTL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningTTL, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_watchdog_timeout.
     *
     * @return zimbraMtaPostscreenWatchdogTimeout, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1939)
    public String getMtaPostscreenWatchdogTimeout() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenWatchdogTimeout, null);
    }

    /**
     * Value for postconf postscreen_watchdog_timeout.
     *
     * @param zimbraMtaPostscreenWatchdogTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1939)
    public void setMtaPostscreenWatchdogTimeout(String zimbraMtaPostscreenWatchdogTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenWatchdogTimeout, zimbraMtaPostscreenWatchdogTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_watchdog_timeout.
     *
     * @param zimbraMtaPostscreenWatchdogTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1939)
    public Map<String,Object> setMtaPostscreenWatchdogTimeout(String zimbraMtaPostscreenWatchdogTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenWatchdogTimeout, zimbraMtaPostscreenWatchdogTimeout);
        return attrs;
    }

    /**
     * Value for postconf postscreen_watchdog_timeout.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1939)
    public void unsetMtaPostscreenWatchdogTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenWatchdogTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_watchdog_timeout.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1939)
    public Map<String,Object> unsetMtaPostscreenWatchdogTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenWatchdogTimeout, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_whitelist_interfaces. Single valued,
     * comma separated list.
     *
     * @return zimbraMtaPostscreenWhitelistInterfaces, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1940)
    public String getMtaPostscreenWhitelistInterfaces() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenWhitelistInterfaces, null);
    }

    /**
     * Value for postconf postscreen_whitelist_interfaces. Single valued,
     * comma separated list.
     *
     * @param zimbraMtaPostscreenWhitelistInterfaces new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1940)
    public void setMtaPostscreenWhitelistInterfaces(String zimbraMtaPostscreenWhitelistInterfaces) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenWhitelistInterfaces, zimbraMtaPostscreenWhitelistInterfaces);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_whitelist_interfaces. Single valued,
     * comma separated list.
     *
     * @param zimbraMtaPostscreenWhitelistInterfaces new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1940)
    public Map<String,Object> setMtaPostscreenWhitelistInterfaces(String zimbraMtaPostscreenWhitelistInterfaces, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenWhitelistInterfaces, zimbraMtaPostscreenWhitelistInterfaces);
        return attrs;
    }

    /**
     * Value for postconf postscreen_whitelist_interfaces. Single valued,
     * comma separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1940)
    public void unsetMtaPostscreenWhitelistInterfaces() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenWhitelistInterfaces, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_whitelist_interfaces. Single valued,
     * comma separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1940)
    public Map<String,Object> unsetMtaPostscreenWhitelistInterfaces(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenWhitelistInterfaces, "");
        return attrs;
    }

    /**
     * Value for postconf propagate_unmatched_extensions
     *
     * <p>Valid values: [alias, include, virtual, canonical, forward, generic]
     *
     * @return zimbraMtaPropagateUnmatchedExtensions, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1547)
    public String[] getMtaPropagateUnmatchedExtensionsAsString() {
        return getMultiAttr(Provisioning.A_zimbraMtaPropagateUnmatchedExtensions);
    }

    /**
     * Value for postconf propagate_unmatched_extensions
     *
     * <p>Valid values: [alias, include, virtual, canonical, forward, generic]
     *
     * @param zimbraMtaPropagateUnmatchedExtensions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1547)
    public void setMtaPropagateUnmatchedExtensions(ZAttrProvisioning.MtaPropagateUnmatchedExtensions zimbraMtaPropagateUnmatchedExtensions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPropagateUnmatchedExtensions, zimbraMtaPropagateUnmatchedExtensions.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf propagate_unmatched_extensions
     *
     * <p>Valid values: [alias, include, virtual, canonical, forward, generic]
     *
     * @param zimbraMtaPropagateUnmatchedExtensions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1547)
    public Map<String,Object> setMtaPropagateUnmatchedExtensions(ZAttrProvisioning.MtaPropagateUnmatchedExtensions zimbraMtaPropagateUnmatchedExtensions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPropagateUnmatchedExtensions, zimbraMtaPropagateUnmatchedExtensions.toString());
        return attrs;
    }

    /**
     * Value for postconf propagate_unmatched_extensions
     *
     * <p>Valid values: [alias, include, virtual, canonical, forward, generic]
     *
     * @param zimbraMtaPropagateUnmatchedExtensions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1547)
    public void setMtaPropagateUnmatchedExtensionsAsString(String[] zimbraMtaPropagateUnmatchedExtensions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPropagateUnmatchedExtensions, zimbraMtaPropagateUnmatchedExtensions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf propagate_unmatched_extensions
     *
     * <p>Valid values: [alias, include, virtual, canonical, forward, generic]
     *
     * @param zimbraMtaPropagateUnmatchedExtensions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1547)
    public Map<String,Object> setMtaPropagateUnmatchedExtensionsAsString(String[] zimbraMtaPropagateUnmatchedExtensions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPropagateUnmatchedExtensions, zimbraMtaPropagateUnmatchedExtensions);
        return attrs;
    }

    /**
     * Value for postconf propagate_unmatched_extensions
     *
     * <p>Valid values: [alias, include, virtual, canonical, forward, generic]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1547)
    public void unsetMtaPropagateUnmatchedExtensions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPropagateUnmatchedExtensions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf propagate_unmatched_extensions
     *
     * <p>Valid values: [alias, include, virtual, canonical, forward, generic]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1547)
    public Map<String,Object> unsetMtaPropagateUnmatchedExtensions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPropagateUnmatchedExtensions, "");
        return attrs;
    }

    /**
     * Value for postconf queue_directory
     *
     * @return zimbraMtaQueueDirectory, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1511)
    public String getMtaQueueDirectory() {
        return getAttr(Provisioning.A_zimbraMtaQueueDirectory, null);
    }

    /**
     * Value for postconf queue_directory
     *
     * @param zimbraMtaQueueDirectory new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1511)
    public void setMtaQueueDirectory(String zimbraMtaQueueDirectory) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaQueueDirectory, zimbraMtaQueueDirectory);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf queue_directory
     *
     * @param zimbraMtaQueueDirectory new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1511)
    public Map<String,Object> setMtaQueueDirectory(String zimbraMtaQueueDirectory, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaQueueDirectory, zimbraMtaQueueDirectory);
        return attrs;
    }

    /**
     * Value for postconf queue_directory
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1511)
    public void unsetMtaQueueDirectory() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaQueueDirectory, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf queue_directory
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1511)
    public Map<String,Object> unsetMtaQueueDirectory(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaQueueDirectory, "");
        return attrs;
    }

    /**
     * Value for postconf queue_run_delay
     *
     * @return zimbraMtaQueueRunDelay, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1519)
    public String getMtaQueueRunDelay() {
        return getAttr(Provisioning.A_zimbraMtaQueueRunDelay, null);
    }

    /**
     * Value for postconf queue_run_delay
     *
     * @param zimbraMtaQueueRunDelay new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1519)
    public void setMtaQueueRunDelay(String zimbraMtaQueueRunDelay) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaQueueRunDelay, zimbraMtaQueueRunDelay);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf queue_run_delay
     *
     * @param zimbraMtaQueueRunDelay new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1519)
    public Map<String,Object> setMtaQueueRunDelay(String zimbraMtaQueueRunDelay, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaQueueRunDelay, zimbraMtaQueueRunDelay);
        return attrs;
    }

    /**
     * Value for postconf queue_run_delay
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1519)
    public void unsetMtaQueueRunDelay() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaQueueRunDelay, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf queue_run_delay
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1519)
    public Map<String,Object> unsetMtaQueueRunDelay(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaQueueRunDelay, "");
        return attrs;
    }

    /**
     * Value for postconf relayhost. Note: there can be only one value on
     * this attribute, see bug 50697.
     *
     * @return zimbraMtaRelayHost, or empty array if unset
     */
    @ZAttr(id=199)
    public String[] getMtaRelayHost() {
        return getMultiAttr(Provisioning.A_zimbraMtaRelayHost);
    }

    /**
     * Value for postconf relayhost. Note: there can be only one value on
     * this attribute, see bug 50697.
     *
     * @param zimbraMtaRelayHost new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=199)
    public void setMtaRelayHost(String[] zimbraMtaRelayHost) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRelayHost, zimbraMtaRelayHost);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf relayhost. Note: there can be only one value on
     * this attribute, see bug 50697.
     *
     * @param zimbraMtaRelayHost new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=199)
    public Map<String,Object> setMtaRelayHost(String[] zimbraMtaRelayHost, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRelayHost, zimbraMtaRelayHost);
        return attrs;
    }

    /**
     * Value for postconf relayhost. Note: there can be only one value on
     * this attribute, see bug 50697.
     *
     * @param zimbraMtaRelayHost new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=199)
    public void addMtaRelayHost(String zimbraMtaRelayHost) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaRelayHost, zimbraMtaRelayHost);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf relayhost. Note: there can be only one value on
     * this attribute, see bug 50697.
     *
     * @param zimbraMtaRelayHost new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=199)
    public Map<String,Object> addMtaRelayHost(String zimbraMtaRelayHost, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaRelayHost, zimbraMtaRelayHost);
        return attrs;
    }

    /**
     * Value for postconf relayhost. Note: there can be only one value on
     * this attribute, see bug 50697.
     *
     * @param zimbraMtaRelayHost existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=199)
    public void removeMtaRelayHost(String zimbraMtaRelayHost) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaRelayHost, zimbraMtaRelayHost);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf relayhost. Note: there can be only one value on
     * this attribute, see bug 50697.
     *
     * @param zimbraMtaRelayHost existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=199)
    public Map<String,Object> removeMtaRelayHost(String zimbraMtaRelayHost, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaRelayHost, zimbraMtaRelayHost);
        return attrs;
    }

    /**
     * Value for postconf relayhost. Note: there can be only one value on
     * this attribute, see bug 50697.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=199)
    public void unsetMtaRelayHost() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRelayHost, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf relayhost. Note: there can be only one value on
     * this attribute, see bug 50697.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=199)
    public Map<String,Object> unsetMtaRelayHost(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRelayHost, "");
        return attrs;
    }

    /**
     * smtpd_recipient_restrictions used to reject email in various scenarios
     *
     * @return zimbraMtaRestriction, or empty array if unset
     */
    @ZAttr(id=226)
    public String[] getMtaRestriction() {
        return getMultiAttr(Provisioning.A_zimbraMtaRestriction);
    }

    /**
     * smtpd_recipient_restrictions used to reject email in various scenarios
     *
     * @param zimbraMtaRestriction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=226)
    public void setMtaRestriction(String[] zimbraMtaRestriction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRestriction, zimbraMtaRestriction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * smtpd_recipient_restrictions used to reject email in various scenarios
     *
     * @param zimbraMtaRestriction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=226)
    public Map<String,Object> setMtaRestriction(String[] zimbraMtaRestriction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRestriction, zimbraMtaRestriction);
        return attrs;
    }

    /**
     * smtpd_recipient_restrictions used to reject email in various scenarios
     *
     * @param zimbraMtaRestriction new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=226)
    public void addMtaRestriction(String zimbraMtaRestriction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaRestriction, zimbraMtaRestriction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * smtpd_recipient_restrictions used to reject email in various scenarios
     *
     * @param zimbraMtaRestriction new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=226)
    public Map<String,Object> addMtaRestriction(String zimbraMtaRestriction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaRestriction, zimbraMtaRestriction);
        return attrs;
    }

    /**
     * smtpd_recipient_restrictions used to reject email in various scenarios
     *
     * @param zimbraMtaRestriction existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=226)
    public void removeMtaRestriction(String zimbraMtaRestriction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaRestriction, zimbraMtaRestriction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * smtpd_recipient_restrictions used to reject email in various scenarios
     *
     * @param zimbraMtaRestriction existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=226)
    public Map<String,Object> removeMtaRestriction(String zimbraMtaRestriction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaRestriction, zimbraMtaRestriction);
        return attrs;
    }

    /**
     * smtpd_recipient_restrictions used to reject email in various scenarios
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=226)
    public void unsetMtaRestriction() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRestriction, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * smtpd_recipient_restrictions used to reject email in various scenarios
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=226)
    public Map<String,Object> unsetMtaRestriction(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRestriction, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_auth_enable
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaSaslAuthEnable, or null if unset and/or has invalid value
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=796)
    public ZAttrProvisioning.MtaSaslAuthEnable getMtaSaslAuthEnable() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSaslAuthEnable); return v == null ? null : ZAttrProvisioning.MtaSaslAuthEnable.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf smtpd_sasl_auth_enable
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaSaslAuthEnable, or null if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=796)
    public String getMtaSaslAuthEnableAsString() {
        return getAttr(Provisioning.A_zimbraMtaSaslAuthEnable, null);
    }

    /**
     * Value for postconf smtpd_sasl_auth_enable
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSaslAuthEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=796)
    public void setMtaSaslAuthEnable(ZAttrProvisioning.MtaSaslAuthEnable zimbraMtaSaslAuthEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslAuthEnable, zimbraMtaSaslAuthEnable.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_auth_enable
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSaslAuthEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=796)
    public Map<String,Object> setMtaSaslAuthEnable(ZAttrProvisioning.MtaSaslAuthEnable zimbraMtaSaslAuthEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslAuthEnable, zimbraMtaSaslAuthEnable.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_auth_enable
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSaslAuthEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=796)
    public void setMtaSaslAuthEnableAsString(String zimbraMtaSaslAuthEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslAuthEnable, zimbraMtaSaslAuthEnable);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_auth_enable
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSaslAuthEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=796)
    public Map<String,Object> setMtaSaslAuthEnableAsString(String zimbraMtaSaslAuthEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslAuthEnable, zimbraMtaSaslAuthEnable);
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_auth_enable
     *
     * <p>Valid values: [no, yes]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=796)
    public void unsetMtaSaslAuthEnable() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslAuthEnable, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_auth_enable
     *
     * <p>Valid values: [no, yes]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=796)
    public Map<String,Object> unsetMtaSaslAuthEnable(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslAuthEnable, "");
        return attrs;
    }

    /**
     * Supported SASL mechanisms for use with the MTA. One attribute value
     * per mechanism.
     *
     * @return zimbraMtaSaslSmtpdMechList, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1560)
    public String[] getMtaSaslSmtpdMechList() {
        return getMultiAttr(Provisioning.A_zimbraMtaSaslSmtpdMechList);
    }

    /**
     * Supported SASL mechanisms for use with the MTA. One attribute value
     * per mechanism.
     *
     * @param zimbraMtaSaslSmtpdMechList new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1560)
    public void setMtaSaslSmtpdMechList(String[] zimbraMtaSaslSmtpdMechList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslSmtpdMechList, zimbraMtaSaslSmtpdMechList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Supported SASL mechanisms for use with the MTA. One attribute value
     * per mechanism.
     *
     * @param zimbraMtaSaslSmtpdMechList new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1560)
    public Map<String,Object> setMtaSaslSmtpdMechList(String[] zimbraMtaSaslSmtpdMechList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslSmtpdMechList, zimbraMtaSaslSmtpdMechList);
        return attrs;
    }

    /**
     * Supported SASL mechanisms for use with the MTA. One attribute value
     * per mechanism.
     *
     * @param zimbraMtaSaslSmtpdMechList new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1560)
    public void addMtaSaslSmtpdMechList(String zimbraMtaSaslSmtpdMechList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaSaslSmtpdMechList, zimbraMtaSaslSmtpdMechList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Supported SASL mechanisms for use with the MTA. One attribute value
     * per mechanism.
     *
     * @param zimbraMtaSaslSmtpdMechList new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1560)
    public Map<String,Object> addMtaSaslSmtpdMechList(String zimbraMtaSaslSmtpdMechList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaSaslSmtpdMechList, zimbraMtaSaslSmtpdMechList);
        return attrs;
    }

    /**
     * Supported SASL mechanisms for use with the MTA. One attribute value
     * per mechanism.
     *
     * @param zimbraMtaSaslSmtpdMechList existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1560)
    public void removeMtaSaslSmtpdMechList(String zimbraMtaSaslSmtpdMechList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaSaslSmtpdMechList, zimbraMtaSaslSmtpdMechList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Supported SASL mechanisms for use with the MTA. One attribute value
     * per mechanism.
     *
     * @param zimbraMtaSaslSmtpdMechList existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1560)
    public Map<String,Object> removeMtaSaslSmtpdMechList(String zimbraMtaSaslSmtpdMechList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaSaslSmtpdMechList, zimbraMtaSaslSmtpdMechList);
        return attrs;
    }

    /**
     * Supported SASL mechanisms for use with the MTA. One attribute value
     * per mechanism.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1560)
    public void unsetMtaSaslSmtpdMechList() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslSmtpdMechList, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Supported SASL mechanisms for use with the MTA. One attribute value
     * per mechanism.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1560)
    public Map<String,Object> unsetMtaSaslSmtpdMechList(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslSmtpdMechList, "");
        return attrs;
    }

    /**
     * Value for postconf sender_canonical_maps. Comma separated list.
     *
     * @return zimbraMtaSenderCanonicalMaps, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1548)
    public String getMtaSenderCanonicalMaps() {
        return getAttr(Provisioning.A_zimbraMtaSenderCanonicalMaps, null);
    }

    /**
     * Value for postconf sender_canonical_maps. Comma separated list.
     *
     * @param zimbraMtaSenderCanonicalMaps new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1548)
    public void setMtaSenderCanonicalMaps(String zimbraMtaSenderCanonicalMaps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSenderCanonicalMaps, zimbraMtaSenderCanonicalMaps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf sender_canonical_maps. Comma separated list.
     *
     * @param zimbraMtaSenderCanonicalMaps new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1548)
    public Map<String,Object> setMtaSenderCanonicalMaps(String zimbraMtaSenderCanonicalMaps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSenderCanonicalMaps, zimbraMtaSenderCanonicalMaps);
        return attrs;
    }

    /**
     * Value for postconf sender_canonical_maps. Comma separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1548)
    public void unsetMtaSenderCanonicalMaps() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSenderCanonicalMaps, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf sender_canonical_maps. Comma separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1548)
    public Map<String,Object> unsetMtaSenderCanonicalMaps(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSenderCanonicalMaps, "");
        return attrs;
    }

    /**
     * Value for postconf sendmail_path
     *
     * @return zimbraMtaSendmailPath, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1512)
    public String getMtaSendmailPath() {
        return getAttr(Provisioning.A_zimbraMtaSendmailPath, null);
    }

    /**
     * Value for postconf sendmail_path
     *
     * @param zimbraMtaSendmailPath new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1512)
    public void setMtaSendmailPath(String zimbraMtaSendmailPath) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSendmailPath, zimbraMtaSendmailPath);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf sendmail_path
     *
     * @param zimbraMtaSendmailPath new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1512)
    public Map<String,Object> setMtaSendmailPath(String zimbraMtaSendmailPath, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSendmailPath, zimbraMtaSendmailPath);
        return attrs;
    }

    /**
     * Value for postconf sendmail_path
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1512)
    public void unsetMtaSendmailPath() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSendmailPath, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf sendmail_path
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1512)
    public Map<String,Object> unsetMtaSendmailPath(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSendmailPath, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_cname_overrides_servername
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaSmtpCnameOverridesServername, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1524)
    public ZAttrProvisioning.MtaSmtpCnameOverridesServername getMtaSmtpCnameOverridesServername() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpCnameOverridesServername); return v == null ? null : ZAttrProvisioning.MtaSmtpCnameOverridesServername.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf smtp_cname_overrides_servername
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaSmtpCnameOverridesServername, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1524)
    public String getMtaSmtpCnameOverridesServernameAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpCnameOverridesServername, null);
    }

    /**
     * Value for postconf smtp_cname_overrides_servername
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpCnameOverridesServername new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1524)
    public void setMtaSmtpCnameOverridesServername(ZAttrProvisioning.MtaSmtpCnameOverridesServername zimbraMtaSmtpCnameOverridesServername) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpCnameOverridesServername, zimbraMtaSmtpCnameOverridesServername.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_cname_overrides_servername
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpCnameOverridesServername new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1524)
    public Map<String,Object> setMtaSmtpCnameOverridesServername(ZAttrProvisioning.MtaSmtpCnameOverridesServername zimbraMtaSmtpCnameOverridesServername, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpCnameOverridesServername, zimbraMtaSmtpCnameOverridesServername.toString());
        return attrs;
    }

    /**
     * Value for postconf smtp_cname_overrides_servername
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpCnameOverridesServername new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1524)
    public void setMtaSmtpCnameOverridesServernameAsString(String zimbraMtaSmtpCnameOverridesServername) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpCnameOverridesServername, zimbraMtaSmtpCnameOverridesServername);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_cname_overrides_servername
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpCnameOverridesServername new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1524)
    public Map<String,Object> setMtaSmtpCnameOverridesServernameAsString(String zimbraMtaSmtpCnameOverridesServername, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpCnameOverridesServername, zimbraMtaSmtpCnameOverridesServername);
        return attrs;
    }

    /**
     * Value for postconf smtp_cname_overrides_servername
     *
     * <p>Valid values: [no, yes]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1524)
    public void unsetMtaSmtpCnameOverridesServername() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpCnameOverridesServername, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_cname_overrides_servername
     *
     * <p>Valid values: [no, yes]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1524)
    public Map<String,Object> unsetMtaSmtpCnameOverridesServername(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpCnameOverridesServername, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_generic_maps
     *
     * @return zimbraMtaSmtpGenericMaps, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1645)
    public String getMtaSmtpGenericMaps() {
        return getAttr(Provisioning.A_zimbraMtaSmtpGenericMaps, null);
    }

    /**
     * Value for postconf smtp_generic_maps
     *
     * @param zimbraMtaSmtpGenericMaps new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1645)
    public void setMtaSmtpGenericMaps(String zimbraMtaSmtpGenericMaps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpGenericMaps, zimbraMtaSmtpGenericMaps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_generic_maps
     *
     * @param zimbraMtaSmtpGenericMaps new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1645)
    public Map<String,Object> setMtaSmtpGenericMaps(String zimbraMtaSmtpGenericMaps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpGenericMaps, zimbraMtaSmtpGenericMaps);
        return attrs;
    }

    /**
     * Value for postconf smtp_generic_maps
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1645)
    public void unsetMtaSmtpGenericMaps() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpGenericMaps, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_generic_maps
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1645)
    public Map<String,Object> unsetMtaSmtpGenericMaps(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpGenericMaps, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_helo_name
     *
     * @return zimbraMtaSmtpHeloName, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1525)
    public String getMtaSmtpHeloName() {
        return getAttr(Provisioning.A_zimbraMtaSmtpHeloName, null);
    }

    /**
     * Value for postconf smtp_helo_name
     *
     * @param zimbraMtaSmtpHeloName new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1525)
    public void setMtaSmtpHeloName(String zimbraMtaSmtpHeloName) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpHeloName, zimbraMtaSmtpHeloName);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_helo_name
     *
     * @param zimbraMtaSmtpHeloName new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1525)
    public Map<String,Object> setMtaSmtpHeloName(String zimbraMtaSmtpHeloName, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpHeloName, zimbraMtaSmtpHeloName);
        return attrs;
    }

    /**
     * Value for postconf smtp_helo_name
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1525)
    public void unsetMtaSmtpHeloName() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpHeloName, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_helo_name
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1525)
    public Map<String,Object> unsetMtaSmtpHeloName(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpHeloName, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_auth_enable
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaSmtpSaslAuthEnable, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1526)
    public ZAttrProvisioning.MtaSmtpSaslAuthEnable getMtaSmtpSaslAuthEnable() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpSaslAuthEnable); return v == null ? null : ZAttrProvisioning.MtaSmtpSaslAuthEnable.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf smtp_sasl_auth_enable
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaSmtpSaslAuthEnable, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1526)
    public String getMtaSmtpSaslAuthEnableAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpSaslAuthEnable, null);
    }

    /**
     * Value for postconf smtp_sasl_auth_enable
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpSaslAuthEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1526)
    public void setMtaSmtpSaslAuthEnable(ZAttrProvisioning.MtaSmtpSaslAuthEnable zimbraMtaSmtpSaslAuthEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslAuthEnable, zimbraMtaSmtpSaslAuthEnable.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_auth_enable
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpSaslAuthEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1526)
    public Map<String,Object> setMtaSmtpSaslAuthEnable(ZAttrProvisioning.MtaSmtpSaslAuthEnable zimbraMtaSmtpSaslAuthEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslAuthEnable, zimbraMtaSmtpSaslAuthEnable.toString());
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_auth_enable
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpSaslAuthEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1526)
    public void setMtaSmtpSaslAuthEnableAsString(String zimbraMtaSmtpSaslAuthEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslAuthEnable, zimbraMtaSmtpSaslAuthEnable);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_auth_enable
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpSaslAuthEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1526)
    public Map<String,Object> setMtaSmtpSaslAuthEnableAsString(String zimbraMtaSmtpSaslAuthEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslAuthEnable, zimbraMtaSmtpSaslAuthEnable);
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_auth_enable
     *
     * <p>Valid values: [no, yes]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1526)
    public void unsetMtaSmtpSaslAuthEnable() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslAuthEnable, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_auth_enable
     *
     * <p>Valid values: [no, yes]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1526)
    public Map<String,Object> unsetMtaSmtpSaslAuthEnable(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslAuthEnable, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_mechanism_filter
     *
     * @return zimbraMtaSmtpSaslMechanismFilter, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1528)
    public String[] getMtaSmtpSaslMechanismFilter() {
        return getMultiAttr(Provisioning.A_zimbraMtaSmtpSaslMechanismFilter);
    }

    /**
     * Value for postconf smtp_sasl_mechanism_filter
     *
     * @param zimbraMtaSmtpSaslMechanismFilter new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1528)
    public void setMtaSmtpSaslMechanismFilter(String[] zimbraMtaSmtpSaslMechanismFilter) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslMechanismFilter, zimbraMtaSmtpSaslMechanismFilter);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_mechanism_filter
     *
     * @param zimbraMtaSmtpSaslMechanismFilter new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1528)
    public Map<String,Object> setMtaSmtpSaslMechanismFilter(String[] zimbraMtaSmtpSaslMechanismFilter, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslMechanismFilter, zimbraMtaSmtpSaslMechanismFilter);
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_mechanism_filter
     *
     * @param zimbraMtaSmtpSaslMechanismFilter new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1528)
    public void addMtaSmtpSaslMechanismFilter(String zimbraMtaSmtpSaslMechanismFilter) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaSmtpSaslMechanismFilter, zimbraMtaSmtpSaslMechanismFilter);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_mechanism_filter
     *
     * @param zimbraMtaSmtpSaslMechanismFilter new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1528)
    public Map<String,Object> addMtaSmtpSaslMechanismFilter(String zimbraMtaSmtpSaslMechanismFilter, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaSmtpSaslMechanismFilter, zimbraMtaSmtpSaslMechanismFilter);
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_mechanism_filter
     *
     * @param zimbraMtaSmtpSaslMechanismFilter existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1528)
    public void removeMtaSmtpSaslMechanismFilter(String zimbraMtaSmtpSaslMechanismFilter) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaSmtpSaslMechanismFilter, zimbraMtaSmtpSaslMechanismFilter);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_mechanism_filter
     *
     * @param zimbraMtaSmtpSaslMechanismFilter existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1528)
    public Map<String,Object> removeMtaSmtpSaslMechanismFilter(String zimbraMtaSmtpSaslMechanismFilter, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaSmtpSaslMechanismFilter, zimbraMtaSmtpSaslMechanismFilter);
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_mechanism_filter
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1528)
    public void unsetMtaSmtpSaslMechanismFilter() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslMechanismFilter, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_mechanism_filter
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1528)
    public Map<String,Object> unsetMtaSmtpSaslMechanismFilter(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslMechanismFilter, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_password_maps. Comma separated list.
     *
     * @return zimbraMtaSmtpSaslPasswordMaps, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1529)
    public String getMtaSmtpSaslPasswordMaps() {
        return getAttr(Provisioning.A_zimbraMtaSmtpSaslPasswordMaps, null);
    }

    /**
     * Value for postconf smtp_sasl_password_maps. Comma separated list.
     *
     * @param zimbraMtaSmtpSaslPasswordMaps new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1529)
    public void setMtaSmtpSaslPasswordMaps(String zimbraMtaSmtpSaslPasswordMaps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslPasswordMaps, zimbraMtaSmtpSaslPasswordMaps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_password_maps. Comma separated list.
     *
     * @param zimbraMtaSmtpSaslPasswordMaps new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1529)
    public Map<String,Object> setMtaSmtpSaslPasswordMaps(String zimbraMtaSmtpSaslPasswordMaps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslPasswordMaps, zimbraMtaSmtpSaslPasswordMaps);
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_password_maps. Comma separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1529)
    public void unsetMtaSmtpSaslPasswordMaps() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslPasswordMaps, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_password_maps. Comma separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1529)
    public Map<String,Object> unsetMtaSmtpSaslPasswordMaps(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslPasswordMaps, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_security_options
     *
     * <p>Valid values: [noactive, nodictionary, noplaintext, noanonymous, mutual_auth]
     *
     * @return zimbraMtaSmtpSaslSecurityOptions, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1549)
    public String[] getMtaSmtpSaslSecurityOptionsAsString() {
        return getMultiAttr(Provisioning.A_zimbraMtaSmtpSaslSecurityOptions);
    }

    /**
     * Value for postconf smtp_sasl_security_options
     *
     * <p>Valid values: [noactive, nodictionary, noplaintext, noanonymous, mutual_auth]
     *
     * @param zimbraMtaSmtpSaslSecurityOptions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1549)
    public void setMtaSmtpSaslSecurityOptions(ZAttrProvisioning.MtaSmtpSaslSecurityOptions zimbraMtaSmtpSaslSecurityOptions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslSecurityOptions, zimbraMtaSmtpSaslSecurityOptions.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_security_options
     *
     * <p>Valid values: [noactive, nodictionary, noplaintext, noanonymous, mutual_auth]
     *
     * @param zimbraMtaSmtpSaslSecurityOptions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1549)
    public Map<String,Object> setMtaSmtpSaslSecurityOptions(ZAttrProvisioning.MtaSmtpSaslSecurityOptions zimbraMtaSmtpSaslSecurityOptions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslSecurityOptions, zimbraMtaSmtpSaslSecurityOptions.toString());
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_security_options
     *
     * <p>Valid values: [noactive, nodictionary, noplaintext, noanonymous, mutual_auth]
     *
     * @param zimbraMtaSmtpSaslSecurityOptions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1549)
    public void setMtaSmtpSaslSecurityOptionsAsString(String[] zimbraMtaSmtpSaslSecurityOptions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslSecurityOptions, zimbraMtaSmtpSaslSecurityOptions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_security_options
     *
     * <p>Valid values: [noactive, nodictionary, noplaintext, noanonymous, mutual_auth]
     *
     * @param zimbraMtaSmtpSaslSecurityOptions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1549)
    public Map<String,Object> setMtaSmtpSaslSecurityOptionsAsString(String[] zimbraMtaSmtpSaslSecurityOptions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslSecurityOptions, zimbraMtaSmtpSaslSecurityOptions);
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_security_options
     *
     * <p>Valid values: [noactive, nodictionary, noplaintext, noanonymous, mutual_auth]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1549)
    public void unsetMtaSmtpSaslSecurityOptions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslSecurityOptions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_security_options
     *
     * <p>Valid values: [noactive, nodictionary, noplaintext, noanonymous, mutual_auth]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1549)
    public Map<String,Object> unsetMtaSmtpSaslSecurityOptions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslSecurityOptions, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_CAfile
     *
     * @return zimbraMtaSmtpTlsCAfile, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1565)
    public String getMtaSmtpTlsCAfile() {
        return getAttr(Provisioning.A_zimbraMtaSmtpTlsCAfile, null);
    }

    /**
     * Value for postconf smtp_tls_CAfile
     *
     * @param zimbraMtaSmtpTlsCAfile new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1565)
    public void setMtaSmtpTlsCAfile(String zimbraMtaSmtpTlsCAfile) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCAfile, zimbraMtaSmtpTlsCAfile);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_CAfile
     *
     * @param zimbraMtaSmtpTlsCAfile new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1565)
    public Map<String,Object> setMtaSmtpTlsCAfile(String zimbraMtaSmtpTlsCAfile, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCAfile, zimbraMtaSmtpTlsCAfile);
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_CAfile
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1565)
    public void unsetMtaSmtpTlsCAfile() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCAfile, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_CAfile
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1565)
    public Map<String,Object> unsetMtaSmtpTlsCAfile(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCAfile, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_CApath
     *
     * @return zimbraMtaSmtpTlsCApath, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1566)
    public String getMtaSmtpTlsCApath() {
        return getAttr(Provisioning.A_zimbraMtaSmtpTlsCApath, null);
    }

    /**
     * Value for postconf smtp_tls_CApath
     *
     * @param zimbraMtaSmtpTlsCApath new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1566)
    public void setMtaSmtpTlsCApath(String zimbraMtaSmtpTlsCApath) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCApath, zimbraMtaSmtpTlsCApath);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_CApath
     *
     * @param zimbraMtaSmtpTlsCApath new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1566)
    public Map<String,Object> setMtaSmtpTlsCApath(String zimbraMtaSmtpTlsCApath, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCApath, zimbraMtaSmtpTlsCApath);
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_CApath
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1566)
    public void unsetMtaSmtpTlsCApath() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCApath, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_CApath
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1566)
    public Map<String,Object> unsetMtaSmtpTlsCApath(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCApath, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @return zimbraMtaSmtpTlsCiphers, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1513)
    public ZAttrProvisioning.MtaSmtpTlsCiphers getMtaSmtpTlsCiphers() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpTlsCiphers); return v == null ? null : ZAttrProvisioning.MtaSmtpTlsCiphers.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf smtp_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @return zimbraMtaSmtpTlsCiphers, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1513)
    public String getMtaSmtpTlsCiphersAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpTlsCiphers, null);
    }

    /**
     * Value for postconf smtp_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaSmtpTlsCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1513)
    public void setMtaSmtpTlsCiphers(ZAttrProvisioning.MtaSmtpTlsCiphers zimbraMtaSmtpTlsCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCiphers, zimbraMtaSmtpTlsCiphers.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaSmtpTlsCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1513)
    public Map<String,Object> setMtaSmtpTlsCiphers(ZAttrProvisioning.MtaSmtpTlsCiphers zimbraMtaSmtpTlsCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCiphers, zimbraMtaSmtpTlsCiphers.toString());
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaSmtpTlsCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1513)
    public void setMtaSmtpTlsCiphersAsString(String zimbraMtaSmtpTlsCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCiphers, zimbraMtaSmtpTlsCiphers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaSmtpTlsCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1513)
    public Map<String,Object> setMtaSmtpTlsCiphersAsString(String zimbraMtaSmtpTlsCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCiphers, zimbraMtaSmtpTlsCiphers);
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1513)
    public void unsetMtaSmtpTlsCiphers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCiphers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1513)
    public Map<String,Object> unsetMtaSmtpTlsCiphers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCiphers, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @return zimbraMtaSmtpTlsLoglevel, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1568)
    public int getMtaSmtpTlsLoglevel() {
        return getIntAttr(Provisioning.A_zimbraMtaSmtpTlsLoglevel, -1);
    }

    /**
     * Value for postconf smtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @param zimbraMtaSmtpTlsLoglevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1568)
    public void setMtaSmtpTlsLoglevel(int zimbraMtaSmtpTlsLoglevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsLoglevel, Integer.toString(zimbraMtaSmtpTlsLoglevel));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @param zimbraMtaSmtpTlsLoglevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1568)
    public Map<String,Object> setMtaSmtpTlsLoglevel(int zimbraMtaSmtpTlsLoglevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsLoglevel, Integer.toString(zimbraMtaSmtpTlsLoglevel));
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1568)
    public void unsetMtaSmtpTlsLoglevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsLoglevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1568)
    public Map<String,Object> unsetMtaSmtpTlsLoglevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsLoglevel, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @return zimbraMtaSmtpTlsMandatoryCiphers, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1514)
    public ZAttrProvisioning.MtaSmtpTlsMandatoryCiphers getMtaSmtpTlsMandatoryCiphers() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpTlsMandatoryCiphers); return v == null ? null : ZAttrProvisioning.MtaSmtpTlsMandatoryCiphers.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf smtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @return zimbraMtaSmtpTlsMandatoryCiphers, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1514)
    public String getMtaSmtpTlsMandatoryCiphersAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpTlsMandatoryCiphers, null);
    }

    /**
     * Value for postconf smtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaSmtpTlsMandatoryCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1514)
    public void setMtaSmtpTlsMandatoryCiphers(ZAttrProvisioning.MtaSmtpTlsMandatoryCiphers zimbraMtaSmtpTlsMandatoryCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryCiphers, zimbraMtaSmtpTlsMandatoryCiphers.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaSmtpTlsMandatoryCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1514)
    public Map<String,Object> setMtaSmtpTlsMandatoryCiphers(ZAttrProvisioning.MtaSmtpTlsMandatoryCiphers zimbraMtaSmtpTlsMandatoryCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryCiphers, zimbraMtaSmtpTlsMandatoryCiphers.toString());
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaSmtpTlsMandatoryCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1514)
    public void setMtaSmtpTlsMandatoryCiphersAsString(String zimbraMtaSmtpTlsMandatoryCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryCiphers, zimbraMtaSmtpTlsMandatoryCiphers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaSmtpTlsMandatoryCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1514)
    public Map<String,Object> setMtaSmtpTlsMandatoryCiphersAsString(String zimbraMtaSmtpTlsMandatoryCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryCiphers, zimbraMtaSmtpTlsMandatoryCiphers);
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1514)
    public void unsetMtaSmtpTlsMandatoryCiphers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryCiphers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1514)
    public Map<String,Object> unsetMtaSmtpTlsMandatoryCiphers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryCiphers, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_mandatory_protocols
     *
     * @return zimbraMtaSmtpTlsMandatoryProtocols, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1782)
    public String getMtaSmtpTlsMandatoryProtocols() {
        return getAttr(Provisioning.A_zimbraMtaSmtpTlsMandatoryProtocols, null);
    }

    /**
     * Value for postconf smtp_tls_mandatory_protocols
     *
     * @param zimbraMtaSmtpTlsMandatoryProtocols new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1782)
    public void setMtaSmtpTlsMandatoryProtocols(String zimbraMtaSmtpTlsMandatoryProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryProtocols, zimbraMtaSmtpTlsMandatoryProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_mandatory_protocols
     *
     * @param zimbraMtaSmtpTlsMandatoryProtocols new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1782)
    public Map<String,Object> setMtaSmtpTlsMandatoryProtocols(String zimbraMtaSmtpTlsMandatoryProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryProtocols, zimbraMtaSmtpTlsMandatoryProtocols);
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_mandatory_protocols
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1782)
    public void unsetMtaSmtpTlsMandatoryProtocols() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryProtocols, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_mandatory_protocols
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1782)
    public Map<String,Object> unsetMtaSmtpTlsMandatoryProtocols(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryProtocols, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_protocols
     *
     * @return zimbraMtaSmtpTlsProtocols, or null if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1670)
    public String getMtaSmtpTlsProtocols() {
        return getAttr(Provisioning.A_zimbraMtaSmtpTlsProtocols, null);
    }

    /**
     * Value for postconf smtp_tls_protocols
     *
     * @param zimbraMtaSmtpTlsProtocols new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1670)
    public void setMtaSmtpTlsProtocols(String zimbraMtaSmtpTlsProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsProtocols, zimbraMtaSmtpTlsProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_protocols
     *
     * @param zimbraMtaSmtpTlsProtocols new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1670)
    public Map<String,Object> setMtaSmtpTlsProtocols(String zimbraMtaSmtpTlsProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsProtocols, zimbraMtaSmtpTlsProtocols);
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_protocols
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1670)
    public void unsetMtaSmtpTlsProtocols() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsProtocols, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_protocols
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1670)
    public Map<String,Object> unsetMtaSmtpTlsProtocols(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsProtocols, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_security_level
     *
     * <p>Valid values: [may, encrypt, dane-only, fingerprint, verify, dane, none, secure]
     *
     * @return zimbraMtaSmtpTlsSecurityLevel, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1527)
    public ZAttrProvisioning.MtaSmtpTlsSecurityLevel getMtaSmtpTlsSecurityLevel() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpTlsSecurityLevel); return v == null ? null : ZAttrProvisioning.MtaSmtpTlsSecurityLevel.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf smtp_tls_security_level
     *
     * <p>Valid values: [may, encrypt, dane-only, fingerprint, verify, dane, none, secure]
     *
     * @return zimbraMtaSmtpTlsSecurityLevel, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1527)
    public String getMtaSmtpTlsSecurityLevelAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpTlsSecurityLevel, null);
    }

    /**
     * Value for postconf smtp_tls_security_level
     *
     * <p>Valid values: [may, encrypt, dane-only, fingerprint, verify, dane, none, secure]
     *
     * @param zimbraMtaSmtpTlsSecurityLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1527)
    public void setMtaSmtpTlsSecurityLevel(ZAttrProvisioning.MtaSmtpTlsSecurityLevel zimbraMtaSmtpTlsSecurityLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsSecurityLevel, zimbraMtaSmtpTlsSecurityLevel.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_security_level
     *
     * <p>Valid values: [may, encrypt, dane-only, fingerprint, verify, dane, none, secure]
     *
     * @param zimbraMtaSmtpTlsSecurityLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1527)
    public Map<String,Object> setMtaSmtpTlsSecurityLevel(ZAttrProvisioning.MtaSmtpTlsSecurityLevel zimbraMtaSmtpTlsSecurityLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsSecurityLevel, zimbraMtaSmtpTlsSecurityLevel.toString());
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_security_level
     *
     * <p>Valid values: [may, encrypt, dane-only, fingerprint, verify, dane, none, secure]
     *
     * @param zimbraMtaSmtpTlsSecurityLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1527)
    public void setMtaSmtpTlsSecurityLevelAsString(String zimbraMtaSmtpTlsSecurityLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsSecurityLevel, zimbraMtaSmtpTlsSecurityLevel);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_security_level
     *
     * <p>Valid values: [may, encrypt, dane-only, fingerprint, verify, dane, none, secure]
     *
     * @param zimbraMtaSmtpTlsSecurityLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1527)
    public Map<String,Object> setMtaSmtpTlsSecurityLevelAsString(String zimbraMtaSmtpTlsSecurityLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsSecurityLevel, zimbraMtaSmtpTlsSecurityLevel);
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_security_level
     *
     * <p>Valid values: [may, encrypt, dane-only, fingerprint, verify, dane, none, secure]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1527)
    public void unsetMtaSmtpTlsSecurityLevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsSecurityLevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_security_level
     *
     * <p>Valid values: [may, encrypt, dane-only, fingerprint, verify, dane, none, secure]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1527)
    public Map<String,Object> unsetMtaSmtpTlsSecurityLevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsSecurityLevel, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_banner
     *
     * @return zimbraMtaSmtpdBanner, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1532)
    public String getMtaSmtpdBanner() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdBanner, null);
    }

    /**
     * Value for postconf smtpd_banner
     *
     * @param zimbraMtaSmtpdBanner new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1532)
    public void setMtaSmtpdBanner(String zimbraMtaSmtpdBanner) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdBanner, zimbraMtaSmtpdBanner);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_banner
     *
     * @param zimbraMtaSmtpdBanner new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1532)
    public Map<String,Object> setMtaSmtpdBanner(String zimbraMtaSmtpdBanner, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdBanner, zimbraMtaSmtpdBanner);
        return attrs;
    }

    /**
     * Value for postconf smtpd_banner
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1532)
    public void unsetMtaSmtpdBanner() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdBanner, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_banner
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1532)
    public Map<String,Object> unsetMtaSmtpdBanner(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdBanner, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_client_port_logging. Defaults to no
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaSmtpdClientPortLogging, or null if unset and/or has invalid value
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1588)
    public ZAttrProvisioning.MtaSmtpdClientPortLogging getMtaSmtpdClientPortLogging() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpdClientPortLogging); return v == null ? null : ZAttrProvisioning.MtaSmtpdClientPortLogging.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf smtpd_client_port_logging. Defaults to no
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaSmtpdClientPortLogging, or null if unset
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1588)
    public String getMtaSmtpdClientPortLoggingAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdClientPortLogging, null);
    }

    /**
     * Value for postconf smtpd_client_port_logging. Defaults to no
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdClientPortLogging new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1588)
    public void setMtaSmtpdClientPortLogging(ZAttrProvisioning.MtaSmtpdClientPortLogging zimbraMtaSmtpdClientPortLogging) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientPortLogging, zimbraMtaSmtpdClientPortLogging.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_client_port_logging. Defaults to no
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdClientPortLogging new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1588)
    public Map<String,Object> setMtaSmtpdClientPortLogging(ZAttrProvisioning.MtaSmtpdClientPortLogging zimbraMtaSmtpdClientPortLogging, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientPortLogging, zimbraMtaSmtpdClientPortLogging.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_client_port_logging. Defaults to no
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdClientPortLogging new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1588)
    public void setMtaSmtpdClientPortLoggingAsString(String zimbraMtaSmtpdClientPortLogging) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientPortLogging, zimbraMtaSmtpdClientPortLogging);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_client_port_logging. Defaults to no
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdClientPortLogging new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1588)
    public Map<String,Object> setMtaSmtpdClientPortLoggingAsString(String zimbraMtaSmtpdClientPortLogging, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientPortLogging, zimbraMtaSmtpdClientPortLogging);
        return attrs;
    }

    /**
     * Value for postconf smtpd_client_port_logging. Defaults to no
     *
     * <p>Valid values: [no, yes]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1588)
    public void unsetMtaSmtpdClientPortLogging() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientPortLogging, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_client_port_logging. Defaults to no
     *
     * <p>Valid values: [no, yes]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1588)
    public Map<String,Object> unsetMtaSmtpdClientPortLogging(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientPortLogging, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_client_restrictions
     *
     * @return zimbraMtaSmtpdClientRestrictions, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1553)
    public String getMtaSmtpdClientRestrictions() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdClientRestrictions, null);
    }

    /**
     * Value for postconf smtpd_client_restrictions
     *
     * @param zimbraMtaSmtpdClientRestrictions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1553)
    public void setMtaSmtpdClientRestrictions(String zimbraMtaSmtpdClientRestrictions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientRestrictions, zimbraMtaSmtpdClientRestrictions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_client_restrictions
     *
     * @param zimbraMtaSmtpdClientRestrictions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1553)
    public Map<String,Object> setMtaSmtpdClientRestrictions(String zimbraMtaSmtpdClientRestrictions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientRestrictions, zimbraMtaSmtpdClientRestrictions);
        return attrs;
    }

    /**
     * Value for postconf smtpd_client_restrictions
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1553)
    public void unsetMtaSmtpdClientRestrictions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientRestrictions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_client_restrictions
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1553)
    public Map<String,Object> unsetMtaSmtpdClientRestrictions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientRestrictions, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_data_restrictions
     *
     * @return zimbraMtaSmtpdDataRestrictions, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1554)
    public String getMtaSmtpdDataRestrictions() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdDataRestrictions, null);
    }

    /**
     * Value for postconf smtpd_data_restrictions
     *
     * @param zimbraMtaSmtpdDataRestrictions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1554)
    public void setMtaSmtpdDataRestrictions(String zimbraMtaSmtpdDataRestrictions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdDataRestrictions, zimbraMtaSmtpdDataRestrictions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_data_restrictions
     *
     * @param zimbraMtaSmtpdDataRestrictions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1554)
    public Map<String,Object> setMtaSmtpdDataRestrictions(String zimbraMtaSmtpdDataRestrictions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdDataRestrictions, zimbraMtaSmtpdDataRestrictions);
        return attrs;
    }

    /**
     * Value for postconf smtpd_data_restrictions
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1554)
    public void unsetMtaSmtpdDataRestrictions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdDataRestrictions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_data_restrictions
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1554)
    public Map<String,Object> unsetMtaSmtpdDataRestrictions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdDataRestrictions, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_error_sleep_time
     *
     * @return zimbraMtaSmtpdErrorSleepTime, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1539)
    public String getMtaSmtpdErrorSleepTime() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdErrorSleepTime, null);
    }

    /**
     * Value for postconf smtpd_error_sleep_time
     *
     * @param zimbraMtaSmtpdErrorSleepTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1539)
    public void setMtaSmtpdErrorSleepTime(String zimbraMtaSmtpdErrorSleepTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdErrorSleepTime, zimbraMtaSmtpdErrorSleepTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_error_sleep_time
     *
     * @param zimbraMtaSmtpdErrorSleepTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1539)
    public Map<String,Object> setMtaSmtpdErrorSleepTime(String zimbraMtaSmtpdErrorSleepTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdErrorSleepTime, zimbraMtaSmtpdErrorSleepTime);
        return attrs;
    }

    /**
     * Value for postconf smtpd_error_sleep_time
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1539)
    public void unsetMtaSmtpdErrorSleepTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdErrorSleepTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_error_sleep_time
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1539)
    public Map<String,Object> unsetMtaSmtpdErrorSleepTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdErrorSleepTime, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_hard_error_limit
     *
     * @return zimbraMtaSmtpdHardErrorLimit, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1537)
    public int getMtaSmtpdHardErrorLimit() {
        return getIntAttr(Provisioning.A_zimbraMtaSmtpdHardErrorLimit, -1);
    }

    /**
     * Value for postconf smtpd_hard_error_limit
     *
     * @param zimbraMtaSmtpdHardErrorLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1537)
    public void setMtaSmtpdHardErrorLimit(int zimbraMtaSmtpdHardErrorLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHardErrorLimit, Integer.toString(zimbraMtaSmtpdHardErrorLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_hard_error_limit
     *
     * @param zimbraMtaSmtpdHardErrorLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1537)
    public Map<String,Object> setMtaSmtpdHardErrorLimit(int zimbraMtaSmtpdHardErrorLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHardErrorLimit, Integer.toString(zimbraMtaSmtpdHardErrorLimit));
        return attrs;
    }

    /**
     * Value for postconf smtpd_hard_error_limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1537)
    public void unsetMtaSmtpdHardErrorLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHardErrorLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_hard_error_limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1537)
    public Map<String,Object> unsetMtaSmtpdHardErrorLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHardErrorLimit, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_helo_required
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaSmtpdHeloRequired, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1540)
    public ZAttrProvisioning.MtaSmtpdHeloRequired getMtaSmtpdHeloRequired() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpdHeloRequired); return v == null ? null : ZAttrProvisioning.MtaSmtpdHeloRequired.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf smtpd_helo_required
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaSmtpdHeloRequired, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1540)
    public String getMtaSmtpdHeloRequiredAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdHeloRequired, null);
    }

    /**
     * Value for postconf smtpd_helo_required
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdHeloRequired new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1540)
    public void setMtaSmtpdHeloRequired(ZAttrProvisioning.MtaSmtpdHeloRequired zimbraMtaSmtpdHeloRequired) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHeloRequired, zimbraMtaSmtpdHeloRequired.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_helo_required
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdHeloRequired new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1540)
    public Map<String,Object> setMtaSmtpdHeloRequired(ZAttrProvisioning.MtaSmtpdHeloRequired zimbraMtaSmtpdHeloRequired, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHeloRequired, zimbraMtaSmtpdHeloRequired.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_helo_required
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdHeloRequired new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1540)
    public void setMtaSmtpdHeloRequiredAsString(String zimbraMtaSmtpdHeloRequired) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHeloRequired, zimbraMtaSmtpdHeloRequired);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_helo_required
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdHeloRequired new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1540)
    public Map<String,Object> setMtaSmtpdHeloRequiredAsString(String zimbraMtaSmtpdHeloRequired, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHeloRequired, zimbraMtaSmtpdHeloRequired);
        return attrs;
    }

    /**
     * Value for postconf smtpd_helo_required
     *
     * <p>Valid values: [no, yes]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1540)
    public void unsetMtaSmtpdHeloRequired() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHeloRequired, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_helo_required
     *
     * <p>Valid values: [no, yes]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1540)
    public Map<String,Object> unsetMtaSmtpdHeloRequired(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHeloRequired, "");
        return attrs;
    }

    /**
     * value for postfix smtpd_milters
     *
     * @return zimbraMtaSmtpdMilters, or null if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=672)
    public String getMtaSmtpdMilters() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdMilters, null);
    }

    /**
     * value for postfix smtpd_milters
     *
     * @param zimbraMtaSmtpdMilters new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=672)
    public void setMtaSmtpdMilters(String zimbraMtaSmtpdMilters) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdMilters, zimbraMtaSmtpdMilters);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value for postfix smtpd_milters
     *
     * @param zimbraMtaSmtpdMilters new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=672)
    public Map<String,Object> setMtaSmtpdMilters(String zimbraMtaSmtpdMilters, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdMilters, zimbraMtaSmtpdMilters);
        return attrs;
    }

    /**
     * value for postfix smtpd_milters
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=672)
    public void unsetMtaSmtpdMilters() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdMilters, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value for postfix smtpd_milters
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=672)
    public Map<String,Object> unsetMtaSmtpdMilters(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdMilters, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_proxy_timeout
     *
     * @return zimbraMtaSmtpdProxyTimeout, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1533)
    public String getMtaSmtpdProxyTimeout() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdProxyTimeout, null);
    }

    /**
     * Value for postconf smtpd_proxy_timeout
     *
     * @param zimbraMtaSmtpdProxyTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1533)
    public void setMtaSmtpdProxyTimeout(String zimbraMtaSmtpdProxyTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdProxyTimeout, zimbraMtaSmtpdProxyTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_proxy_timeout
     *
     * @param zimbraMtaSmtpdProxyTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1533)
    public Map<String,Object> setMtaSmtpdProxyTimeout(String zimbraMtaSmtpdProxyTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdProxyTimeout, zimbraMtaSmtpdProxyTimeout);
        return attrs;
    }

    /**
     * Value for postconf smtpd_proxy_timeout
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1533)
    public void unsetMtaSmtpdProxyTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdProxyTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_proxy_timeout
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1533)
    public Map<String,Object> unsetMtaSmtpdProxyTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdProxyTimeout, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_reject_unlisted_recipient
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaSmtpdRejectUnlistedRecipient, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1534)
    public ZAttrProvisioning.MtaSmtpdRejectUnlistedRecipient getMtaSmtpdRejectUnlistedRecipient() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpdRejectUnlistedRecipient); return v == null ? null : ZAttrProvisioning.MtaSmtpdRejectUnlistedRecipient.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf smtpd_reject_unlisted_recipient
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaSmtpdRejectUnlistedRecipient, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1534)
    public String getMtaSmtpdRejectUnlistedRecipientAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdRejectUnlistedRecipient, null);
    }

    /**
     * Value for postconf smtpd_reject_unlisted_recipient
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdRejectUnlistedRecipient new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1534)
    public void setMtaSmtpdRejectUnlistedRecipient(ZAttrProvisioning.MtaSmtpdRejectUnlistedRecipient zimbraMtaSmtpdRejectUnlistedRecipient) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedRecipient, zimbraMtaSmtpdRejectUnlistedRecipient.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_reject_unlisted_recipient
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdRejectUnlistedRecipient new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1534)
    public Map<String,Object> setMtaSmtpdRejectUnlistedRecipient(ZAttrProvisioning.MtaSmtpdRejectUnlistedRecipient zimbraMtaSmtpdRejectUnlistedRecipient, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedRecipient, zimbraMtaSmtpdRejectUnlistedRecipient.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_reject_unlisted_recipient
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdRejectUnlistedRecipient new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1534)
    public void setMtaSmtpdRejectUnlistedRecipientAsString(String zimbraMtaSmtpdRejectUnlistedRecipient) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedRecipient, zimbraMtaSmtpdRejectUnlistedRecipient);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_reject_unlisted_recipient
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdRejectUnlistedRecipient new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1534)
    public Map<String,Object> setMtaSmtpdRejectUnlistedRecipientAsString(String zimbraMtaSmtpdRejectUnlistedRecipient, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedRecipient, zimbraMtaSmtpdRejectUnlistedRecipient);
        return attrs;
    }

    /**
     * Value for postconf smtpd_reject_unlisted_recipient
     *
     * <p>Valid values: [no, yes]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1534)
    public void unsetMtaSmtpdRejectUnlistedRecipient() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedRecipient, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_reject_unlisted_recipient
     *
     * <p>Valid values: [no, yes]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1534)
    public Map<String,Object> unsetMtaSmtpdRejectUnlistedRecipient(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedRecipient, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_reject_unlisted_sender
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaSmtpdRejectUnlistedSender, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1535)
    public ZAttrProvisioning.MtaSmtpdRejectUnlistedSender getMtaSmtpdRejectUnlistedSender() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpdRejectUnlistedSender); return v == null ? null : ZAttrProvisioning.MtaSmtpdRejectUnlistedSender.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf smtpd_reject_unlisted_sender
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaSmtpdRejectUnlistedSender, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1535)
    public String getMtaSmtpdRejectUnlistedSenderAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdRejectUnlistedSender, null);
    }

    /**
     * Value for postconf smtpd_reject_unlisted_sender
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdRejectUnlistedSender new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1535)
    public void setMtaSmtpdRejectUnlistedSender(ZAttrProvisioning.MtaSmtpdRejectUnlistedSender zimbraMtaSmtpdRejectUnlistedSender) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedSender, zimbraMtaSmtpdRejectUnlistedSender.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_reject_unlisted_sender
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdRejectUnlistedSender new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1535)
    public Map<String,Object> setMtaSmtpdRejectUnlistedSender(ZAttrProvisioning.MtaSmtpdRejectUnlistedSender zimbraMtaSmtpdRejectUnlistedSender, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedSender, zimbraMtaSmtpdRejectUnlistedSender.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_reject_unlisted_sender
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdRejectUnlistedSender new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1535)
    public void setMtaSmtpdRejectUnlistedSenderAsString(String zimbraMtaSmtpdRejectUnlistedSender) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedSender, zimbraMtaSmtpdRejectUnlistedSender);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_reject_unlisted_sender
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdRejectUnlistedSender new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1535)
    public Map<String,Object> setMtaSmtpdRejectUnlistedSenderAsString(String zimbraMtaSmtpdRejectUnlistedSender, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedSender, zimbraMtaSmtpdRejectUnlistedSender);
        return attrs;
    }

    /**
     * Value for postconf smtpd_reject_unlisted_sender
     *
     * <p>Valid values: [no, yes]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1535)
    public void unsetMtaSmtpdRejectUnlistedSender() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedSender, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_reject_unlisted_sender
     *
     * <p>Valid values: [no, yes]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1535)
    public Map<String,Object> unsetMtaSmtpdRejectUnlistedSender(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedSender, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_authenticated_header
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaSmtpdSaslAuthenticatedHeader, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1536)
    public ZAttrProvisioning.MtaSmtpdSaslAuthenticatedHeader getMtaSmtpdSaslAuthenticatedHeader() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpdSaslAuthenticatedHeader); return v == null ? null : ZAttrProvisioning.MtaSmtpdSaslAuthenticatedHeader.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf smtpd_sasl_authenticated_header
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaSmtpdSaslAuthenticatedHeader, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1536)
    public String getMtaSmtpdSaslAuthenticatedHeaderAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdSaslAuthenticatedHeader, null);
    }

    /**
     * Value for postconf smtpd_sasl_authenticated_header
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdSaslAuthenticatedHeader new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1536)
    public void setMtaSmtpdSaslAuthenticatedHeader(ZAttrProvisioning.MtaSmtpdSaslAuthenticatedHeader zimbraMtaSmtpdSaslAuthenticatedHeader) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslAuthenticatedHeader, zimbraMtaSmtpdSaslAuthenticatedHeader.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_authenticated_header
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdSaslAuthenticatedHeader new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1536)
    public Map<String,Object> setMtaSmtpdSaslAuthenticatedHeader(ZAttrProvisioning.MtaSmtpdSaslAuthenticatedHeader zimbraMtaSmtpdSaslAuthenticatedHeader, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslAuthenticatedHeader, zimbraMtaSmtpdSaslAuthenticatedHeader.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_authenticated_header
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdSaslAuthenticatedHeader new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1536)
    public void setMtaSmtpdSaslAuthenticatedHeaderAsString(String zimbraMtaSmtpdSaslAuthenticatedHeader) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslAuthenticatedHeader, zimbraMtaSmtpdSaslAuthenticatedHeader);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_authenticated_header
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdSaslAuthenticatedHeader new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1536)
    public Map<String,Object> setMtaSmtpdSaslAuthenticatedHeaderAsString(String zimbraMtaSmtpdSaslAuthenticatedHeader, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslAuthenticatedHeader, zimbraMtaSmtpdSaslAuthenticatedHeader);
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_authenticated_header
     *
     * <p>Valid values: [no, yes]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1536)
    public void unsetMtaSmtpdSaslAuthenticatedHeader() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslAuthenticatedHeader, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_authenticated_header
     *
     * <p>Valid values: [no, yes]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1536)
    public Map<String,Object> unsetMtaSmtpdSaslAuthenticatedHeader(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslAuthenticatedHeader, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_security_options
     *
     * <p>Valid values: [noactive, nodictionary, noplaintext, noanonymous, mutual_auth]
     *
     * @return zimbraMtaSmtpdSaslSecurityOptions, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1550)
    public String[] getMtaSmtpdSaslSecurityOptionsAsString() {
        return getMultiAttr(Provisioning.A_zimbraMtaSmtpdSaslSecurityOptions);
    }

    /**
     * Value for postconf smtpd_sasl_security_options
     *
     * <p>Valid values: [noactive, nodictionary, noplaintext, noanonymous, mutual_auth]
     *
     * @param zimbraMtaSmtpdSaslSecurityOptions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1550)
    public void setMtaSmtpdSaslSecurityOptions(ZAttrProvisioning.MtaSmtpdSaslSecurityOptions zimbraMtaSmtpdSaslSecurityOptions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslSecurityOptions, zimbraMtaSmtpdSaslSecurityOptions.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_security_options
     *
     * <p>Valid values: [noactive, nodictionary, noplaintext, noanonymous, mutual_auth]
     *
     * @param zimbraMtaSmtpdSaslSecurityOptions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1550)
    public Map<String,Object> setMtaSmtpdSaslSecurityOptions(ZAttrProvisioning.MtaSmtpdSaslSecurityOptions zimbraMtaSmtpdSaslSecurityOptions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslSecurityOptions, zimbraMtaSmtpdSaslSecurityOptions.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_security_options
     *
     * <p>Valid values: [noactive, nodictionary, noplaintext, noanonymous, mutual_auth]
     *
     * @param zimbraMtaSmtpdSaslSecurityOptions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1550)
    public void setMtaSmtpdSaslSecurityOptionsAsString(String[] zimbraMtaSmtpdSaslSecurityOptions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslSecurityOptions, zimbraMtaSmtpdSaslSecurityOptions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_security_options
     *
     * <p>Valid values: [noactive, nodictionary, noplaintext, noanonymous, mutual_auth]
     *
     * @param zimbraMtaSmtpdSaslSecurityOptions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1550)
    public Map<String,Object> setMtaSmtpdSaslSecurityOptionsAsString(String[] zimbraMtaSmtpdSaslSecurityOptions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslSecurityOptions, zimbraMtaSmtpdSaslSecurityOptions);
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_security_options
     *
     * <p>Valid values: [noactive, nodictionary, noplaintext, noanonymous, mutual_auth]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1550)
    public void unsetMtaSmtpdSaslSecurityOptions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslSecurityOptions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_security_options
     *
     * <p>Valid values: [noactive, nodictionary, noplaintext, noanonymous, mutual_auth]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1550)
    public Map<String,Object> unsetMtaSmtpdSaslSecurityOptions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslSecurityOptions, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_tls_security_options
     *
     * @return zimbraMtaSmtpdSaslTlsSecurityOptions, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1552)
    public String[] getMtaSmtpdSaslTlsSecurityOptions() {
        return getMultiAttr(Provisioning.A_zimbraMtaSmtpdSaslTlsSecurityOptions);
    }

    /**
     * Value for postconf smtpd_sasl_tls_security_options
     *
     * @param zimbraMtaSmtpdSaslTlsSecurityOptions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1552)
    public void setMtaSmtpdSaslTlsSecurityOptions(String[] zimbraMtaSmtpdSaslTlsSecurityOptions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslTlsSecurityOptions, zimbraMtaSmtpdSaslTlsSecurityOptions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_tls_security_options
     *
     * @param zimbraMtaSmtpdSaslTlsSecurityOptions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1552)
    public Map<String,Object> setMtaSmtpdSaslTlsSecurityOptions(String[] zimbraMtaSmtpdSaslTlsSecurityOptions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslTlsSecurityOptions, zimbraMtaSmtpdSaslTlsSecurityOptions);
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_tls_security_options
     *
     * @param zimbraMtaSmtpdSaslTlsSecurityOptions new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1552)
    public void addMtaSmtpdSaslTlsSecurityOptions(String zimbraMtaSmtpdSaslTlsSecurityOptions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaSmtpdSaslTlsSecurityOptions, zimbraMtaSmtpdSaslTlsSecurityOptions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_tls_security_options
     *
     * @param zimbraMtaSmtpdSaslTlsSecurityOptions new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1552)
    public Map<String,Object> addMtaSmtpdSaslTlsSecurityOptions(String zimbraMtaSmtpdSaslTlsSecurityOptions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaSmtpdSaslTlsSecurityOptions, zimbraMtaSmtpdSaslTlsSecurityOptions);
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_tls_security_options
     *
     * @param zimbraMtaSmtpdSaslTlsSecurityOptions existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1552)
    public void removeMtaSmtpdSaslTlsSecurityOptions(String zimbraMtaSmtpdSaslTlsSecurityOptions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaSmtpdSaslTlsSecurityOptions, zimbraMtaSmtpdSaslTlsSecurityOptions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_tls_security_options
     *
     * @param zimbraMtaSmtpdSaslTlsSecurityOptions existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1552)
    public Map<String,Object> removeMtaSmtpdSaslTlsSecurityOptions(String zimbraMtaSmtpdSaslTlsSecurityOptions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaSmtpdSaslTlsSecurityOptions, zimbraMtaSmtpdSaslTlsSecurityOptions);
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_tls_security_options
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1552)
    public void unsetMtaSmtpdSaslTlsSecurityOptions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslTlsSecurityOptions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_tls_security_options
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1552)
    public Map<String,Object> unsetMtaSmtpdSaslTlsSecurityOptions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslTlsSecurityOptions, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_sender_login_maps
     *
     * @return zimbraMtaSmtpdSenderLoginMaps, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1591)
    public String getMtaSmtpdSenderLoginMaps() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdSenderLoginMaps, null);
    }

    /**
     * Value for postconf smtpd_sender_login_maps
     *
     * @param zimbraMtaSmtpdSenderLoginMaps new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1591)
    public void setMtaSmtpdSenderLoginMaps(String zimbraMtaSmtpdSenderLoginMaps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSenderLoginMaps, zimbraMtaSmtpdSenderLoginMaps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sender_login_maps
     *
     * @param zimbraMtaSmtpdSenderLoginMaps new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1591)
    public Map<String,Object> setMtaSmtpdSenderLoginMaps(String zimbraMtaSmtpdSenderLoginMaps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSenderLoginMaps, zimbraMtaSmtpdSenderLoginMaps);
        return attrs;
    }

    /**
     * Value for postconf smtpd_sender_login_maps
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1591)
    public void unsetMtaSmtpdSenderLoginMaps() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSenderLoginMaps, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sender_login_maps
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1591)
    public Map<String,Object> unsetMtaSmtpdSenderLoginMaps(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSenderLoginMaps, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_sender_restrictions
     *
     * @return zimbraMtaSmtpdSenderRestrictions, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1590)
    public String getMtaSmtpdSenderRestrictions() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdSenderRestrictions, null);
    }

    /**
     * Value for postconf smtpd_sender_restrictions
     *
     * @param zimbraMtaSmtpdSenderRestrictions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1590)
    public void setMtaSmtpdSenderRestrictions(String zimbraMtaSmtpdSenderRestrictions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSenderRestrictions, zimbraMtaSmtpdSenderRestrictions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sender_restrictions
     *
     * @param zimbraMtaSmtpdSenderRestrictions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1590)
    public Map<String,Object> setMtaSmtpdSenderRestrictions(String zimbraMtaSmtpdSenderRestrictions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSenderRestrictions, zimbraMtaSmtpdSenderRestrictions);
        return attrs;
    }

    /**
     * Value for postconf smtpd_sender_restrictions
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1590)
    public void unsetMtaSmtpdSenderRestrictions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSenderRestrictions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sender_restrictions
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1590)
    public Map<String,Object> unsetMtaSmtpdSenderRestrictions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSenderRestrictions, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_ask_ccert
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaSmtpdTlsAskCcert, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1542)
    public ZAttrProvisioning.MtaSmtpdTlsAskCcert getMtaSmtpdTlsAskCcert() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpdTlsAskCcert); return v == null ? null : ZAttrProvisioning.MtaSmtpdTlsAskCcert.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf smtpd_tls_ask_ccert
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaSmtpdTlsAskCcert, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1542)
    public String getMtaSmtpdTlsAskCcertAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdTlsAskCcert, null);
    }

    /**
     * Value for postconf smtpd_tls_ask_ccert
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdTlsAskCcert new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1542)
    public void setMtaSmtpdTlsAskCcert(ZAttrProvisioning.MtaSmtpdTlsAskCcert zimbraMtaSmtpdTlsAskCcert) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsAskCcert, zimbraMtaSmtpdTlsAskCcert.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_ask_ccert
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdTlsAskCcert new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1542)
    public Map<String,Object> setMtaSmtpdTlsAskCcert(ZAttrProvisioning.MtaSmtpdTlsAskCcert zimbraMtaSmtpdTlsAskCcert, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsAskCcert, zimbraMtaSmtpdTlsAskCcert.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_ask_ccert
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdTlsAskCcert new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1542)
    public void setMtaSmtpdTlsAskCcertAsString(String zimbraMtaSmtpdTlsAskCcert) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsAskCcert, zimbraMtaSmtpdTlsAskCcert);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_ask_ccert
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaSmtpdTlsAskCcert new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1542)
    public Map<String,Object> setMtaSmtpdTlsAskCcertAsString(String zimbraMtaSmtpdTlsAskCcert, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsAskCcert, zimbraMtaSmtpdTlsAskCcert);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_ask_ccert
     *
     * <p>Valid values: [no, yes]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1542)
    public void unsetMtaSmtpdTlsAskCcert() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsAskCcert, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_ask_ccert
     *
     * <p>Valid values: [no, yes]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1542)
    public Map<String,Object> unsetMtaSmtpdTlsAskCcert(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsAskCcert, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_CAfile
     *
     * @return zimbraMtaSmtpdTlsCAfile, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1563)
    public String getMtaSmtpdTlsCAfile() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdTlsCAfile, null);
    }

    /**
     * Value for postconf smtpd_tls_CAfile
     *
     * @param zimbraMtaSmtpdTlsCAfile new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1563)
    public void setMtaSmtpdTlsCAfile(String zimbraMtaSmtpdTlsCAfile) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCAfile, zimbraMtaSmtpdTlsCAfile);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_CAfile
     *
     * @param zimbraMtaSmtpdTlsCAfile new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1563)
    public Map<String,Object> setMtaSmtpdTlsCAfile(String zimbraMtaSmtpdTlsCAfile, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCAfile, zimbraMtaSmtpdTlsCAfile);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_CAfile
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1563)
    public void unsetMtaSmtpdTlsCAfile() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCAfile, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_CAfile
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1563)
    public Map<String,Object> unsetMtaSmtpdTlsCAfile(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCAfile, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_CApath
     *
     * @return zimbraMtaSmtpdTlsCApath, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1564)
    public String getMtaSmtpdTlsCApath() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdTlsCApath, null);
    }

    /**
     * Value for postconf smtpd_tls_CApath
     *
     * @param zimbraMtaSmtpdTlsCApath new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1564)
    public void setMtaSmtpdTlsCApath(String zimbraMtaSmtpdTlsCApath) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCApath, zimbraMtaSmtpdTlsCApath);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_CApath
     *
     * @param zimbraMtaSmtpdTlsCApath new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1564)
    public Map<String,Object> setMtaSmtpdTlsCApath(String zimbraMtaSmtpdTlsCApath, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCApath, zimbraMtaSmtpdTlsCApath);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_CApath
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1564)
    public void unsetMtaSmtpdTlsCApath() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCApath, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_CApath
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1564)
    public Map<String,Object> unsetMtaSmtpdTlsCApath(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCApath, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_ccert_verifydepth
     *
     * @return zimbraMtaSmtpdTlsCcertVerifydepth, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1543)
    public int getMtaSmtpdTlsCcertVerifydepth() {
        return getIntAttr(Provisioning.A_zimbraMtaSmtpdTlsCcertVerifydepth, -1);
    }

    /**
     * Value for postconf smtpd_tls_ccert_verifydepth
     *
     * @param zimbraMtaSmtpdTlsCcertVerifydepth new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1543)
    public void setMtaSmtpdTlsCcertVerifydepth(int zimbraMtaSmtpdTlsCcertVerifydepth) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCcertVerifydepth, Integer.toString(zimbraMtaSmtpdTlsCcertVerifydepth));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_ccert_verifydepth
     *
     * @param zimbraMtaSmtpdTlsCcertVerifydepth new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1543)
    public Map<String,Object> setMtaSmtpdTlsCcertVerifydepth(int zimbraMtaSmtpdTlsCcertVerifydepth, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCcertVerifydepth, Integer.toString(zimbraMtaSmtpdTlsCcertVerifydepth));
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_ccert_verifydepth
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1543)
    public void unsetMtaSmtpdTlsCcertVerifydepth() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCcertVerifydepth, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_ccert_verifydepth
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1543)
    public Map<String,Object> unsetMtaSmtpdTlsCcertVerifydepth(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCcertVerifydepth, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @return zimbraMtaSmtpdTlsCiphers, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1515)
    public ZAttrProvisioning.MtaSmtpdTlsCiphers getMtaSmtpdTlsCiphers() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpdTlsCiphers); return v == null ? null : ZAttrProvisioning.MtaSmtpdTlsCiphers.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf smtpd_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @return zimbraMtaSmtpdTlsCiphers, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1515)
    public String getMtaSmtpdTlsCiphersAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdTlsCiphers, null);
    }

    /**
     * Value for postconf smtpd_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaSmtpdTlsCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1515)
    public void setMtaSmtpdTlsCiphers(ZAttrProvisioning.MtaSmtpdTlsCiphers zimbraMtaSmtpdTlsCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCiphers, zimbraMtaSmtpdTlsCiphers.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaSmtpdTlsCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1515)
    public Map<String,Object> setMtaSmtpdTlsCiphers(ZAttrProvisioning.MtaSmtpdTlsCiphers zimbraMtaSmtpdTlsCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCiphers, zimbraMtaSmtpdTlsCiphers.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaSmtpdTlsCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1515)
    public void setMtaSmtpdTlsCiphersAsString(String zimbraMtaSmtpdTlsCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCiphers, zimbraMtaSmtpdTlsCiphers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaSmtpdTlsCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1515)
    public Map<String,Object> setMtaSmtpdTlsCiphersAsString(String zimbraMtaSmtpdTlsCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCiphers, zimbraMtaSmtpdTlsCiphers);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1515)
    public void unsetMtaSmtpdTlsCiphers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCiphers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1515)
    public Map<String,Object> unsetMtaSmtpdTlsCiphers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCiphers, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_exclude_ciphers
     *
     * @return zimbraMtaSmtpdTlsExcludeCiphers, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1647)
    public String getMtaSmtpdTlsExcludeCiphers() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdTlsExcludeCiphers, null);
    }

    /**
     * Value for postconf smtpd_tls_exclude_ciphers
     *
     * @param zimbraMtaSmtpdTlsExcludeCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1647)
    public void setMtaSmtpdTlsExcludeCiphers(String zimbraMtaSmtpdTlsExcludeCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsExcludeCiphers, zimbraMtaSmtpdTlsExcludeCiphers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_exclude_ciphers
     *
     * @param zimbraMtaSmtpdTlsExcludeCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1647)
    public Map<String,Object> setMtaSmtpdTlsExcludeCiphers(String zimbraMtaSmtpdTlsExcludeCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsExcludeCiphers, zimbraMtaSmtpdTlsExcludeCiphers);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_exclude_ciphers
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1647)
    public void unsetMtaSmtpdTlsExcludeCiphers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsExcludeCiphers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_exclude_ciphers
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1647)
    public Map<String,Object> unsetMtaSmtpdTlsExcludeCiphers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsExcludeCiphers, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_loglevel. Default is 1. Valid range is
     * 1-4.
     *
     * @return zimbraMtaSmtpdTlsLoglevel, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1541)
    public int getMtaSmtpdTlsLoglevel() {
        return getIntAttr(Provisioning.A_zimbraMtaSmtpdTlsLoglevel, -1);
    }

    /**
     * Value for postconf smtpd_tls_loglevel. Default is 1. Valid range is
     * 1-4.
     *
     * @param zimbraMtaSmtpdTlsLoglevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1541)
    public void setMtaSmtpdTlsLoglevel(int zimbraMtaSmtpdTlsLoglevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsLoglevel, Integer.toString(zimbraMtaSmtpdTlsLoglevel));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_loglevel. Default is 1. Valid range is
     * 1-4.
     *
     * @param zimbraMtaSmtpdTlsLoglevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1541)
    public Map<String,Object> setMtaSmtpdTlsLoglevel(int zimbraMtaSmtpdTlsLoglevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsLoglevel, Integer.toString(zimbraMtaSmtpdTlsLoglevel));
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_loglevel. Default is 1. Valid range is
     * 1-4.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1541)
    public void unsetMtaSmtpdTlsLoglevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsLoglevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_loglevel. Default is 1. Valid range is
     * 1-4.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1541)
    public Map<String,Object> unsetMtaSmtpdTlsLoglevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsLoglevel, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @return zimbraMtaSmtpdTlsMandatoryCiphers, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1516)
    public ZAttrProvisioning.MtaSmtpdTlsMandatoryCiphers getMtaSmtpdTlsMandatoryCiphers() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpdTlsMandatoryCiphers); return v == null ? null : ZAttrProvisioning.MtaSmtpdTlsMandatoryCiphers.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf smtpd_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @return zimbraMtaSmtpdTlsMandatoryCiphers, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1516)
    public String getMtaSmtpdTlsMandatoryCiphersAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdTlsMandatoryCiphers, null);
    }

    /**
     * Value for postconf smtpd_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaSmtpdTlsMandatoryCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1516)
    public void setMtaSmtpdTlsMandatoryCiphers(ZAttrProvisioning.MtaSmtpdTlsMandatoryCiphers zimbraMtaSmtpdTlsMandatoryCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryCiphers, zimbraMtaSmtpdTlsMandatoryCiphers.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaSmtpdTlsMandatoryCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1516)
    public Map<String,Object> setMtaSmtpdTlsMandatoryCiphers(ZAttrProvisioning.MtaSmtpdTlsMandatoryCiphers zimbraMtaSmtpdTlsMandatoryCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryCiphers, zimbraMtaSmtpdTlsMandatoryCiphers.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaSmtpdTlsMandatoryCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1516)
    public void setMtaSmtpdTlsMandatoryCiphersAsString(String zimbraMtaSmtpdTlsMandatoryCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryCiphers, zimbraMtaSmtpdTlsMandatoryCiphers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param zimbraMtaSmtpdTlsMandatoryCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1516)
    public Map<String,Object> setMtaSmtpdTlsMandatoryCiphersAsString(String zimbraMtaSmtpdTlsMandatoryCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryCiphers, zimbraMtaSmtpdTlsMandatoryCiphers);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1516)
    public void unsetMtaSmtpdTlsMandatoryCiphers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryCiphers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_mandatory_ciphers
     *
     * <p>Valid values: [high, medium, null, export, low]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1516)
    public Map<String,Object> unsetMtaSmtpdTlsMandatoryCiphers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryCiphers, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_mandatory_protocols
     *
     * @return zimbraMtaSmtpdTlsMandatoryProtocols, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1783)
    public String getMtaSmtpdTlsMandatoryProtocols() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdTlsMandatoryProtocols, null);
    }

    /**
     * Value for postconf smtpd_tls_mandatory_protocols
     *
     * @param zimbraMtaSmtpdTlsMandatoryProtocols new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1783)
    public void setMtaSmtpdTlsMandatoryProtocols(String zimbraMtaSmtpdTlsMandatoryProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryProtocols, zimbraMtaSmtpdTlsMandatoryProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_mandatory_protocols
     *
     * @param zimbraMtaSmtpdTlsMandatoryProtocols new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1783)
    public Map<String,Object> setMtaSmtpdTlsMandatoryProtocols(String zimbraMtaSmtpdTlsMandatoryProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryProtocols, zimbraMtaSmtpdTlsMandatoryProtocols);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_mandatory_protocols
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1783)
    public void unsetMtaSmtpdTlsMandatoryProtocols() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryProtocols, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_mandatory_protocols
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1783)
    public Map<String,Object> unsetMtaSmtpdTlsMandatoryProtocols(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryProtocols, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_protocols
     *
     * @return zimbraMtaSmtpdTlsProtocols, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1646)
    public String getMtaSmtpdTlsProtocols() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdTlsProtocols, null);
    }

    /**
     * Value for postconf smtpd_tls_protocols
     *
     * @param zimbraMtaSmtpdTlsProtocols new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1646)
    public void setMtaSmtpdTlsProtocols(String zimbraMtaSmtpdTlsProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsProtocols, zimbraMtaSmtpdTlsProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_protocols
     *
     * @param zimbraMtaSmtpdTlsProtocols new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1646)
    public Map<String,Object> setMtaSmtpdTlsProtocols(String zimbraMtaSmtpdTlsProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsProtocols, zimbraMtaSmtpdTlsProtocols);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_protocols
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1646)
    public void unsetMtaSmtpdTlsProtocols() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsProtocols, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_protocols
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1646)
    public Map<String,Object> unsetMtaSmtpdTlsProtocols(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsProtocols, "");
        return attrs;
    }

    /**
     * Value for postconf virtual_transport
     *
     * @return zimbraMtaSmtpdVirtualTransport, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1545)
    public String getMtaSmtpdVirtualTransport() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdVirtualTransport, null);
    }

    /**
     * Value for postconf virtual_transport
     *
     * @param zimbraMtaSmtpdVirtualTransport new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1545)
    public void setMtaSmtpdVirtualTransport(String zimbraMtaSmtpdVirtualTransport) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdVirtualTransport, zimbraMtaSmtpdVirtualTransport);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_transport
     *
     * @param zimbraMtaSmtpdVirtualTransport new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1545)
    public Map<String,Object> setMtaSmtpdVirtualTransport(String zimbraMtaSmtpdVirtualTransport, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdVirtualTransport, zimbraMtaSmtpdVirtualTransport);
        return attrs;
    }

    /**
     * Value for postconf virtual_transport
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1545)
    public void unsetMtaSmtpdVirtualTransport() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdVirtualTransport, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_transport
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1545)
    public Map<String,Object> unsetMtaSmtpdVirtualTransport(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdVirtualTransport, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_soft_error_limit
     *
     * @return zimbraMtaStpdSoftErrorLimit, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1538)
    public int getMtaStpdSoftErrorLimit() {
        return getIntAttr(Provisioning.A_zimbraMtaStpdSoftErrorLimit, -1);
    }

    /**
     * Value for postconf smtpd_soft_error_limit
     *
     * @param zimbraMtaStpdSoftErrorLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1538)
    public void setMtaStpdSoftErrorLimit(int zimbraMtaStpdSoftErrorLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaStpdSoftErrorLimit, Integer.toString(zimbraMtaStpdSoftErrorLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_soft_error_limit
     *
     * @param zimbraMtaStpdSoftErrorLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1538)
    public Map<String,Object> setMtaStpdSoftErrorLimit(int zimbraMtaStpdSoftErrorLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaStpdSoftErrorLimit, Integer.toString(zimbraMtaStpdSoftErrorLimit));
        return attrs;
    }

    /**
     * Value for postconf smtpd_soft_error_limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1538)
    public void unsetMtaStpdSoftErrorLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaStpdSoftErrorLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_soft_error_limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1538)
    public Map<String,Object> unsetMtaStpdSoftErrorLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaStpdSoftErrorLimit, "");
        return attrs;
    }

    /**
     * Value for postconf tls_append_default_CA
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaTlsAppendDefaultCA, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1567)
    public ZAttrProvisioning.MtaTlsAppendDefaultCA getMtaTlsAppendDefaultCA() {
        try { String v = getAttr(Provisioning.A_zimbraMtaTlsAppendDefaultCA); return v == null ? null : ZAttrProvisioning.MtaTlsAppendDefaultCA.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf tls_append_default_CA
     *
     * <p>Valid values: [no, yes]
     *
     * @return zimbraMtaTlsAppendDefaultCA, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1567)
    public String getMtaTlsAppendDefaultCAAsString() {
        return getAttr(Provisioning.A_zimbraMtaTlsAppendDefaultCA, null);
    }

    /**
     * Value for postconf tls_append_default_CA
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaTlsAppendDefaultCA new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1567)
    public void setMtaTlsAppendDefaultCA(ZAttrProvisioning.MtaTlsAppendDefaultCA zimbraMtaTlsAppendDefaultCA) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAppendDefaultCA, zimbraMtaTlsAppendDefaultCA.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf tls_append_default_CA
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaTlsAppendDefaultCA new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1567)
    public Map<String,Object> setMtaTlsAppendDefaultCA(ZAttrProvisioning.MtaTlsAppendDefaultCA zimbraMtaTlsAppendDefaultCA, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAppendDefaultCA, zimbraMtaTlsAppendDefaultCA.toString());
        return attrs;
    }

    /**
     * Value for postconf tls_append_default_CA
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaTlsAppendDefaultCA new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1567)
    public void setMtaTlsAppendDefaultCAAsString(String zimbraMtaTlsAppendDefaultCA) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAppendDefaultCA, zimbraMtaTlsAppendDefaultCA);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf tls_append_default_CA
     *
     * <p>Valid values: [no, yes]
     *
     * @param zimbraMtaTlsAppendDefaultCA new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1567)
    public Map<String,Object> setMtaTlsAppendDefaultCAAsString(String zimbraMtaTlsAppendDefaultCA, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAppendDefaultCA, zimbraMtaTlsAppendDefaultCA);
        return attrs;
    }

    /**
     * Value for postconf tls_append_default_CA
     *
     * <p>Valid values: [no, yes]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1567)
    public void unsetMtaTlsAppendDefaultCA() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAppendDefaultCA, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf tls_append_default_CA
     *
     * <p>Valid values: [no, yes]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1567)
    public Map<String,Object> unsetMtaTlsAppendDefaultCA(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAppendDefaultCA, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_auth_only
     *
     * @return zimbraMtaTlsAuthOnly, or false if unset
     */
    @ZAttr(id=200)
    public boolean isMtaTlsAuthOnly() {
        return getBooleanAttr(Provisioning.A_zimbraMtaTlsAuthOnly, false);
    }

    /**
     * Value for postconf smtpd_tls_auth_only
     *
     * @param zimbraMtaTlsAuthOnly new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=200)
    public void setMtaTlsAuthOnly(boolean zimbraMtaTlsAuthOnly) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAuthOnly, zimbraMtaTlsAuthOnly ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_auth_only
     *
     * @param zimbraMtaTlsAuthOnly new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=200)
    public Map<String,Object> setMtaTlsAuthOnly(boolean zimbraMtaTlsAuthOnly, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAuthOnly, zimbraMtaTlsAuthOnly ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_auth_only
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=200)
    public void unsetMtaTlsAuthOnly() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAuthOnly, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_auth_only
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=200)
    public Map<String,Object> unsetMtaTlsAuthOnly(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAuthOnly, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_security_level
     *
     * <p>Valid values: [may, none]
     *
     * @return zimbraMtaTlsSecurityLevel, or null if unset and/or has invalid value
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=795)
    public ZAttrProvisioning.MtaTlsSecurityLevel getMtaTlsSecurityLevel() {
        try { String v = getAttr(Provisioning.A_zimbraMtaTlsSecurityLevel); return v == null ? null : ZAttrProvisioning.MtaTlsSecurityLevel.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf smtpd_tls_security_level
     *
     * <p>Valid values: [may, none]
     *
     * @return zimbraMtaTlsSecurityLevel, or null if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=795)
    public String getMtaTlsSecurityLevelAsString() {
        return getAttr(Provisioning.A_zimbraMtaTlsSecurityLevel, null);
    }

    /**
     * Value for postconf smtpd_tls_security_level
     *
     * <p>Valid values: [may, none]
     *
     * @param zimbraMtaTlsSecurityLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=795)
    public void setMtaTlsSecurityLevel(ZAttrProvisioning.MtaTlsSecurityLevel zimbraMtaTlsSecurityLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsSecurityLevel, zimbraMtaTlsSecurityLevel.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_security_level
     *
     * <p>Valid values: [may, none]
     *
     * @param zimbraMtaTlsSecurityLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=795)
    public Map<String,Object> setMtaTlsSecurityLevel(ZAttrProvisioning.MtaTlsSecurityLevel zimbraMtaTlsSecurityLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsSecurityLevel, zimbraMtaTlsSecurityLevel.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_security_level
     *
     * <p>Valid values: [may, none]
     *
     * @param zimbraMtaTlsSecurityLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=795)
    public void setMtaTlsSecurityLevelAsString(String zimbraMtaTlsSecurityLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsSecurityLevel, zimbraMtaTlsSecurityLevel);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_security_level
     *
     * <p>Valid values: [may, none]
     *
     * @param zimbraMtaTlsSecurityLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=795)
    public Map<String,Object> setMtaTlsSecurityLevelAsString(String zimbraMtaTlsSecurityLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsSecurityLevel, zimbraMtaTlsSecurityLevel);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_security_level
     *
     * <p>Valid values: [may, none]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=795)
    public void unsetMtaTlsSecurityLevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsSecurityLevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_security_level
     *
     * <p>Valid values: [may, none]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=795)
    public Map<String,Object> unsetMtaTlsSecurityLevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsSecurityLevel, "");
        return attrs;
    }

    /**
     * Value for postconf transport_maps. Comma separated list.
     *
     * @return zimbraMtaTransportMaps, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1555)
    public String getMtaTransportMaps() {
        return getAttr(Provisioning.A_zimbraMtaTransportMaps, null);
    }

    /**
     * Value for postconf transport_maps. Comma separated list.
     *
     * @param zimbraMtaTransportMaps new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1555)
    public void setMtaTransportMaps(String zimbraMtaTransportMaps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTransportMaps, zimbraMtaTransportMaps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf transport_maps. Comma separated list.
     *
     * @param zimbraMtaTransportMaps new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1555)
    public Map<String,Object> setMtaTransportMaps(String zimbraMtaTransportMaps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTransportMaps, zimbraMtaTransportMaps);
        return attrs;
    }

    /**
     * Value for postconf transport_maps. Comma separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1555)
    public void unsetMtaTransportMaps() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTransportMaps, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf transport_maps. Comma separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1555)
    public Map<String,Object> unsetMtaTransportMaps(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTransportMaps, "");
        return attrs;
    }

    /**
     * Value for postconf unverified_recipient_defer_code
     *
     * @return zimbraMtaUnverifiedRecipientDeferCode, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1606)
    public int getMtaUnverifiedRecipientDeferCode() {
        return getIntAttr(Provisioning.A_zimbraMtaUnverifiedRecipientDeferCode, -1);
    }

    /**
     * Value for postconf unverified_recipient_defer_code
     *
     * @param zimbraMtaUnverifiedRecipientDeferCode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1606)
    public void setMtaUnverifiedRecipientDeferCode(int zimbraMtaUnverifiedRecipientDeferCode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaUnverifiedRecipientDeferCode, Integer.toString(zimbraMtaUnverifiedRecipientDeferCode));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf unverified_recipient_defer_code
     *
     * @param zimbraMtaUnverifiedRecipientDeferCode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1606)
    public Map<String,Object> setMtaUnverifiedRecipientDeferCode(int zimbraMtaUnverifiedRecipientDeferCode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaUnverifiedRecipientDeferCode, Integer.toString(zimbraMtaUnverifiedRecipientDeferCode));
        return attrs;
    }

    /**
     * Value for postconf unverified_recipient_defer_code
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1606)
    public void unsetMtaUnverifiedRecipientDeferCode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaUnverifiedRecipientDeferCode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf unverified_recipient_defer_code
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1606)
    public Map<String,Object> unsetMtaUnverifiedRecipientDeferCode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaUnverifiedRecipientDeferCode, "");
        return attrs;
    }

    /**
     * Value for postconf virtual_alias_domains. Comma separated list.
     *
     * @return zimbraMtaVirtualAliasDomains, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1556)
    public String getMtaVirtualAliasDomains() {
        return getAttr(Provisioning.A_zimbraMtaVirtualAliasDomains, null);
    }

    /**
     * Value for postconf virtual_alias_domains. Comma separated list.
     *
     * @param zimbraMtaVirtualAliasDomains new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1556)
    public void setMtaVirtualAliasDomains(String zimbraMtaVirtualAliasDomains) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasDomains, zimbraMtaVirtualAliasDomains);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_alias_domains. Comma separated list.
     *
     * @param zimbraMtaVirtualAliasDomains new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1556)
    public Map<String,Object> setMtaVirtualAliasDomains(String zimbraMtaVirtualAliasDomains, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasDomains, zimbraMtaVirtualAliasDomains);
        return attrs;
    }

    /**
     * Value for postconf virtual_alias_domains. Comma separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1556)
    public void unsetMtaVirtualAliasDomains() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasDomains, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_alias_domains. Comma separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1556)
    public Map<String,Object> unsetMtaVirtualAliasDomains(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasDomains, "");
        return attrs;
    }

    /**
     * Value for postconf virtual_alias_expansion_limit
     *
     * @return zimbraMtaVirtualAliasExpansionLimit, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1544)
    public int getMtaVirtualAliasExpansionLimit() {
        return getIntAttr(Provisioning.A_zimbraMtaVirtualAliasExpansionLimit, -1);
    }

    /**
     * Value for postconf virtual_alias_expansion_limit
     *
     * @param zimbraMtaVirtualAliasExpansionLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1544)
    public void setMtaVirtualAliasExpansionLimit(int zimbraMtaVirtualAliasExpansionLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasExpansionLimit, Integer.toString(zimbraMtaVirtualAliasExpansionLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_alias_expansion_limit
     *
     * @param zimbraMtaVirtualAliasExpansionLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1544)
    public Map<String,Object> setMtaVirtualAliasExpansionLimit(int zimbraMtaVirtualAliasExpansionLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasExpansionLimit, Integer.toString(zimbraMtaVirtualAliasExpansionLimit));
        return attrs;
    }

    /**
     * Value for postconf virtual_alias_expansion_limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1544)
    public void unsetMtaVirtualAliasExpansionLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasExpansionLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_alias_expansion_limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1544)
    public Map<String,Object> unsetMtaVirtualAliasExpansionLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasExpansionLimit, "");
        return attrs;
    }

    /**
     * Value for postconf virtual_alias_maps. Comma separated list.
     *
     * @return zimbraMtaVirtualAliasMaps, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1557)
    public String getMtaVirtualAliasMaps() {
        return getAttr(Provisioning.A_zimbraMtaVirtualAliasMaps, null);
    }

    /**
     * Value for postconf virtual_alias_maps. Comma separated list.
     *
     * @param zimbraMtaVirtualAliasMaps new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1557)
    public void setMtaVirtualAliasMaps(String zimbraMtaVirtualAliasMaps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasMaps, zimbraMtaVirtualAliasMaps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_alias_maps. Comma separated list.
     *
     * @param zimbraMtaVirtualAliasMaps new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1557)
    public Map<String,Object> setMtaVirtualAliasMaps(String zimbraMtaVirtualAliasMaps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasMaps, zimbraMtaVirtualAliasMaps);
        return attrs;
    }

    /**
     * Value for postconf virtual_alias_maps. Comma separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1557)
    public void unsetMtaVirtualAliasMaps() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasMaps, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_alias_maps. Comma separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1557)
    public Map<String,Object> unsetMtaVirtualAliasMaps(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasMaps, "");
        return attrs;
    }

    /**
     * Value for postconf virtual_mailbox_domains. Comma separated list.
     *
     * @return zimbraMtaVirtualMailboxDomains, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1558)
    public String getMtaVirtualMailboxDomains() {
        return getAttr(Provisioning.A_zimbraMtaVirtualMailboxDomains, null);
    }

    /**
     * Value for postconf virtual_mailbox_domains. Comma separated list.
     *
     * @param zimbraMtaVirtualMailboxDomains new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1558)
    public void setMtaVirtualMailboxDomains(String zimbraMtaVirtualMailboxDomains) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualMailboxDomains, zimbraMtaVirtualMailboxDomains);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_mailbox_domains. Comma separated list.
     *
     * @param zimbraMtaVirtualMailboxDomains new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1558)
    public Map<String,Object> setMtaVirtualMailboxDomains(String zimbraMtaVirtualMailboxDomains, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualMailboxDomains, zimbraMtaVirtualMailboxDomains);
        return attrs;
    }

    /**
     * Value for postconf virtual_mailbox_domains. Comma separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1558)
    public void unsetMtaVirtualMailboxDomains() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualMailboxDomains, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_mailbox_domains. Comma separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1558)
    public Map<String,Object> unsetMtaVirtualMailboxDomains(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualMailboxDomains, "");
        return attrs;
    }

    /**
     * Value for postconf virtual_mailbox_maps. Comma separated list.
     *
     * @return zimbraMtaVirtualMailboxMaps, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1559)
    public String getMtaVirtualMailboxMaps() {
        return getAttr(Provisioning.A_zimbraMtaVirtualMailboxMaps, null);
    }

    /**
     * Value for postconf virtual_mailbox_maps. Comma separated list.
     *
     * @param zimbraMtaVirtualMailboxMaps new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1559)
    public void setMtaVirtualMailboxMaps(String zimbraMtaVirtualMailboxMaps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualMailboxMaps, zimbraMtaVirtualMailboxMaps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_mailbox_maps. Comma separated list.
     *
     * @param zimbraMtaVirtualMailboxMaps new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1559)
    public Map<String,Object> setMtaVirtualMailboxMaps(String zimbraMtaVirtualMailboxMaps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualMailboxMaps, zimbraMtaVirtualMailboxMaps);
        return attrs;
    }

    /**
     * Value for postconf virtual_mailbox_maps. Comma separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1559)
    public void unsetMtaVirtualMailboxMaps() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualMailboxMaps, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_mailbox_maps. Comma separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1559)
    public Map<String,Object> unsetMtaVirtualMailboxMaps(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualMailboxMaps, "");
        return attrs;
    }

    /**
     * Flag to enable streaming of jdbc results.
     *
     * @return zimbraMysqlJdbcResultStreamingEnabled, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1789)
    public boolean isMysqlJdbcResultStreamingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMysqlJdbcResultStreamingEnabled, false);
    }

    /**
     * Flag to enable streaming of jdbc results.
     *
     * @param zimbraMysqlJdbcResultStreamingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1789)
    public void setMysqlJdbcResultStreamingEnabled(boolean zimbraMysqlJdbcResultStreamingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMysqlJdbcResultStreamingEnabled, zimbraMysqlJdbcResultStreamingEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable streaming of jdbc results.
     *
     * @param zimbraMysqlJdbcResultStreamingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1789)
    public Map<String,Object> setMysqlJdbcResultStreamingEnabled(boolean zimbraMysqlJdbcResultStreamingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMysqlJdbcResultStreamingEnabled, zimbraMysqlJdbcResultStreamingEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to enable streaming of jdbc results.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1789)
    public void unsetMysqlJdbcResultStreamingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMysqlJdbcResultStreamingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable streaming of jdbc results.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1789)
    public Map<String,Object> unsetMysqlJdbcResultStreamingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMysqlJdbcResultStreamingEnabled, "");
        return attrs;
    }

    /**
     * Nio maximum write queue size in bytes
     *
     * @return zimbraNioMaxWriteQueueSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1803)
    public int getNioMaxWriteQueueSize() {
        return getIntAttr(Provisioning.A_zimbraNioMaxWriteQueueSize, -1);
    }

    /**
     * Nio maximum write queue size in bytes
     *
     * @param zimbraNioMaxWriteQueueSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1803)
    public void setNioMaxWriteQueueSize(int zimbraNioMaxWriteQueueSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNioMaxWriteQueueSize, Integer.toString(zimbraNioMaxWriteQueueSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Nio maximum write queue size in bytes
     *
     * @param zimbraNioMaxWriteQueueSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1803)
    public Map<String,Object> setNioMaxWriteQueueSize(int zimbraNioMaxWriteQueueSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNioMaxWriteQueueSize, Integer.toString(zimbraNioMaxWriteQueueSize));
        return attrs;
    }

    /**
     * Nio maximum write queue size in bytes
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1803)
    public void unsetNioMaxWriteQueueSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNioMaxWriteQueueSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Nio maximum write queue size in bytes
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1803)
    public Map<String,Object> unsetNioMaxWriteQueueSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNioMaxWriteQueueSize, "");
        return attrs;
    }

    /**
     * The size of composed Wiki / Notebook page cache on the server.
     *
     * @return zimbraNotebookPageCacheSize, or -1 if unset
     */
    @ZAttr(id=369)
    public int getNotebookPageCacheSize() {
        return getIntAttr(Provisioning.A_zimbraNotebookPageCacheSize, -1);
    }

    /**
     * The size of composed Wiki / Notebook page cache on the server.
     *
     * @param zimbraNotebookPageCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=369)
    public void setNotebookPageCacheSize(int zimbraNotebookPageCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookPageCacheSize, Integer.toString(zimbraNotebookPageCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The size of composed Wiki / Notebook page cache on the server.
     *
     * @param zimbraNotebookPageCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=369)
    public Map<String,Object> setNotebookPageCacheSize(int zimbraNotebookPageCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookPageCacheSize, Integer.toString(zimbraNotebookPageCacheSize));
        return attrs;
    }

    /**
     * The size of composed Wiki / Notebook page cache on the server.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=369)
    public void unsetNotebookPageCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookPageCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The size of composed Wiki / Notebook page cache on the server.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=369)
    public Map<String,Object> unsetNotebookPageCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookPageCacheSize, "");
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which notification server
     * should listen; if empty, binds to all interfaces.
     *
     * @return zimbraNotifyBindAddress, or empty array if unset
     */
    @ZAttr(id=317)
    public String[] getNotifyBindAddress() {
        return getMultiAttr(Provisioning.A_zimbraNotifyBindAddress);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which notification server
     * should listen; if empty, binds to all interfaces.
     *
     * @param zimbraNotifyBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=317)
    public void setNotifyBindAddress(String[] zimbraNotifyBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifyBindAddress, zimbraNotifyBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which notification server
     * should listen; if empty, binds to all interfaces.
     *
     * @param zimbraNotifyBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=317)
    public Map<String,Object> setNotifyBindAddress(String[] zimbraNotifyBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifyBindAddress, zimbraNotifyBindAddress);
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which notification server
     * should listen; if empty, binds to all interfaces.
     *
     * @param zimbraNotifyBindAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=317)
    public void addNotifyBindAddress(String zimbraNotifyBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraNotifyBindAddress, zimbraNotifyBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which notification server
     * should listen; if empty, binds to all interfaces.
     *
     * @param zimbraNotifyBindAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=317)
    public Map<String,Object> addNotifyBindAddress(String zimbraNotifyBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraNotifyBindAddress, zimbraNotifyBindAddress);
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which notification server
     * should listen; if empty, binds to all interfaces.
     *
     * @param zimbraNotifyBindAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=317)
    public void removeNotifyBindAddress(String zimbraNotifyBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraNotifyBindAddress, zimbraNotifyBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which notification server
     * should listen; if empty, binds to all interfaces.
     *
     * @param zimbraNotifyBindAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=317)
    public Map<String,Object> removeNotifyBindAddress(String zimbraNotifyBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraNotifyBindAddress, zimbraNotifyBindAddress);
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which notification server
     * should listen; if empty, binds to all interfaces.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=317)
    public void unsetNotifyBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifyBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which notification server
     * should listen; if empty, binds to all interfaces.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=317)
    public Map<String,Object> unsetNotifyBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifyBindAddress, "");
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which SSL notification server
     * should listen; if empty, binds to all interfaces
     *
     * @return zimbraNotifySSLBindAddress, or empty array if unset
     */
    @ZAttr(id=320)
    public String[] getNotifySSLBindAddress() {
        return getMultiAttr(Provisioning.A_zimbraNotifySSLBindAddress);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which SSL notification server
     * should listen; if empty, binds to all interfaces
     *
     * @param zimbraNotifySSLBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=320)
    public void setNotifySSLBindAddress(String[] zimbraNotifySSLBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifySSLBindAddress, zimbraNotifySSLBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which SSL notification server
     * should listen; if empty, binds to all interfaces
     *
     * @param zimbraNotifySSLBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=320)
    public Map<String,Object> setNotifySSLBindAddress(String[] zimbraNotifySSLBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifySSLBindAddress, zimbraNotifySSLBindAddress);
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which SSL notification server
     * should listen; if empty, binds to all interfaces
     *
     * @param zimbraNotifySSLBindAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=320)
    public void addNotifySSLBindAddress(String zimbraNotifySSLBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraNotifySSLBindAddress, zimbraNotifySSLBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which SSL notification server
     * should listen; if empty, binds to all interfaces
     *
     * @param zimbraNotifySSLBindAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=320)
    public Map<String,Object> addNotifySSLBindAddress(String zimbraNotifySSLBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraNotifySSLBindAddress, zimbraNotifySSLBindAddress);
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which SSL notification server
     * should listen; if empty, binds to all interfaces
     *
     * @param zimbraNotifySSLBindAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=320)
    public void removeNotifySSLBindAddress(String zimbraNotifySSLBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraNotifySSLBindAddress, zimbraNotifySSLBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which SSL notification server
     * should listen; if empty, binds to all interfaces
     *
     * @param zimbraNotifySSLBindAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=320)
    public Map<String,Object> removeNotifySSLBindAddress(String zimbraNotifySSLBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraNotifySSLBindAddress, zimbraNotifySSLBindAddress);
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which SSL notification server
     * should listen; if empty, binds to all interfaces
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=320)
    public void unsetNotifySSLBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifySSLBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which SSL notification server
     * should listen; if empty, binds to all interfaces
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=320)
    public Map<String,Object> unsetNotifySSLBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifySSLBindAddress, "");
        return attrs;
    }

    /**
     * whether stateless mode (not establishing an association with the
     * OpenID Provider) in OpenID Consumer is enabled
     *
     * @return zimbraOpenidConsumerStatelessModeEnabled, or false if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1189)
    public boolean isOpenidConsumerStatelessModeEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraOpenidConsumerStatelessModeEnabled, false);
    }

    /**
     * whether stateless mode (not establishing an association with the
     * OpenID Provider) in OpenID Consumer is enabled
     *
     * @param zimbraOpenidConsumerStatelessModeEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1189)
    public void setOpenidConsumerStatelessModeEnabled(boolean zimbraOpenidConsumerStatelessModeEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOpenidConsumerStatelessModeEnabled, zimbraOpenidConsumerStatelessModeEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether stateless mode (not establishing an association with the
     * OpenID Provider) in OpenID Consumer is enabled
     *
     * @param zimbraOpenidConsumerStatelessModeEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1189)
    public Map<String,Object> setOpenidConsumerStatelessModeEnabled(boolean zimbraOpenidConsumerStatelessModeEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOpenidConsumerStatelessModeEnabled, zimbraOpenidConsumerStatelessModeEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * whether stateless mode (not establishing an association with the
     * OpenID Provider) in OpenID Consumer is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1189)
    public void unsetOpenidConsumerStatelessModeEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOpenidConsumerStatelessModeEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether stateless mode (not establishing an association with the
     * OpenID Provider) in OpenID Consumer is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1189)
    public Map<String,Object> unsetOpenidConsumerStatelessModeEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOpenidConsumerStatelessModeEnabled, "");
        return attrs;
    }

    /**
     * interface address on which POP3 server should listen; if empty, binds
     * to all interfaces
     *
     * @return zimbraPop3BindAddress, or empty array if unset
     */
    @ZAttr(id=95)
    public String[] getPop3BindAddress() {
        return getMultiAttr(Provisioning.A_zimbraPop3BindAddress);
    }

    /**
     * interface address on which POP3 server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraPop3BindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=95)
    public void setPop3BindAddress(String[] zimbraPop3BindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3BindAddress, zimbraPop3BindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which POP3 server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraPop3BindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=95)
    public Map<String,Object> setPop3BindAddress(String[] zimbraPop3BindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3BindAddress, zimbraPop3BindAddress);
        return attrs;
    }

    /**
     * interface address on which POP3 server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraPop3BindAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=95)
    public void addPop3BindAddress(String zimbraPop3BindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPop3BindAddress, zimbraPop3BindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which POP3 server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraPop3BindAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=95)
    public Map<String,Object> addPop3BindAddress(String zimbraPop3BindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPop3BindAddress, zimbraPop3BindAddress);
        return attrs;
    }

    /**
     * interface address on which POP3 server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraPop3BindAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=95)
    public void removePop3BindAddress(String zimbraPop3BindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPop3BindAddress, zimbraPop3BindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which POP3 server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraPop3BindAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=95)
    public Map<String,Object> removePop3BindAddress(String zimbraPop3BindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPop3BindAddress, zimbraPop3BindAddress);
        return attrs;
    }

    /**
     * interface address on which POP3 server should listen; if empty, binds
     * to all interfaces
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=95)
    public void unsetPop3BindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3BindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which POP3 server should listen; if empty, binds
     * to all interfaces
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=95)
    public Map<String,Object> unsetPop3BindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3BindAddress, "");
        return attrs;
    }

    /**
     * Enable debug for pop3
     *
     * @return zimbraPop3EnableDebug, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1727)
    public boolean isPop3EnableDebug() {
        return getBooleanAttr(Provisioning.A_zimbraPop3EnableDebug, false);
    }

    /**
     * Enable debug for pop3
     *
     * @param zimbraPop3EnableDebug new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1727)
    public void setPop3EnableDebug(boolean zimbraPop3EnableDebug) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3EnableDebug, zimbraPop3EnableDebug ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable debug for pop3
     *
     * @param zimbraPop3EnableDebug new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1727)
    public Map<String,Object> setPop3EnableDebug(boolean zimbraPop3EnableDebug, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3EnableDebug, zimbraPop3EnableDebug ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Enable debug for pop3
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1727)
    public void unsetPop3EnableDebug() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3EnableDebug, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable debug for pop3
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1727)
    public Map<String,Object> unsetPop3EnableDebug(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3EnableDebug, "");
        return attrs;
    }

    /**
     * Enable STARTTLS for POP3
     *
     * @return zimbraPop3EnableStartTls, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1725)
    public boolean isPop3EnableStartTls() {
        return getBooleanAttr(Provisioning.A_zimbraPop3EnableStartTls, false);
    }

    /**
     * Enable STARTTLS for POP3
     *
     * @param zimbraPop3EnableStartTls new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1725)
    public void setPop3EnableStartTls(boolean zimbraPop3EnableStartTls) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3EnableStartTls, zimbraPop3EnableStartTls ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable STARTTLS for POP3
     *
     * @param zimbraPop3EnableStartTls new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1725)
    public Map<String,Object> setPop3EnableStartTls(boolean zimbraPop3EnableStartTls, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3EnableStartTls, zimbraPop3EnableStartTls ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Enable STARTTLS for POP3
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1725)
    public void unsetPop3EnableStartTls() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3EnableStartTls, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable STARTTLS for POP3
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1725)
    public Map<String,Object> unsetPop3EnableStartTls(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3EnableStartTls, "");
        return attrs;
    }

    /**
     * Maximum no of consecutive errors for retry
     *
     * @return zimbraPop3MaxConsecutiveError, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1805)
    public int getPop3MaxConsecutiveError() {
        return getIntAttr(Provisioning.A_zimbraPop3MaxConsecutiveError, -1);
    }

    /**
     * Maximum no of consecutive errors for retry
     *
     * @param zimbraPop3MaxConsecutiveError new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1805)
    public void setPop3MaxConsecutiveError(int zimbraPop3MaxConsecutiveError) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3MaxConsecutiveError, Integer.toString(zimbraPop3MaxConsecutiveError));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum no of consecutive errors for retry
     *
     * @param zimbraPop3MaxConsecutiveError new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1805)
    public Map<String,Object> setPop3MaxConsecutiveError(int zimbraPop3MaxConsecutiveError, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3MaxConsecutiveError, Integer.toString(zimbraPop3MaxConsecutiveError));
        return attrs;
    }

    /**
     * Maximum no of consecutive errors for retry
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1805)
    public void unsetPop3MaxConsecutiveError() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3MaxConsecutiveError, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum no of consecutive errors for retry
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1805)
    public Map<String,Object> unsetPop3MaxConsecutiveError(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3MaxConsecutiveError, "");
        return attrs;
    }

    /**
     * Maximum idle time in seconds. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getPop3MaxIdleTimeAsString to access value as a string.
     *
     * @see #getPop3MaxIdleTimeAsString()
     *
     * @return zimbraPop3MaxIdleTime in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1806)
    public long getPop3MaxIdleTime() {
        return getTimeInterval(Provisioning.A_zimbraPop3MaxIdleTime, -1L);
    }

    /**
     * Maximum idle time in seconds. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraPop3MaxIdleTime, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1806)
    public String getPop3MaxIdleTimeAsString() {
        return getAttr(Provisioning.A_zimbraPop3MaxIdleTime, null);
    }

    /**
     * Maximum idle time in seconds. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraPop3MaxIdleTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1806)
    public void setPop3MaxIdleTime(String zimbraPop3MaxIdleTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3MaxIdleTime, zimbraPop3MaxIdleTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum idle time in seconds. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraPop3MaxIdleTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1806)
    public Map<String,Object> setPop3MaxIdleTime(String zimbraPop3MaxIdleTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3MaxIdleTime, zimbraPop3MaxIdleTime);
        return attrs;
    }

    /**
     * Maximum idle time in seconds. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1806)
    public void unsetPop3MaxIdleTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3MaxIdleTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum idle time in seconds. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1806)
    public Map<String,Object> unsetPop3MaxIdleTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3MaxIdleTime, "");
        return attrs;
    }

    /**
     * Flag to enable pop3 nio
     *
     * @return zimbraPop3NioEnabled, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1794)
    public boolean isPop3NioEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPop3NioEnabled, false);
    }

    /**
     * Flag to enable pop3 nio
     *
     * @param zimbraPop3NioEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1794)
    public void setPop3NioEnabled(boolean zimbraPop3NioEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3NioEnabled, zimbraPop3NioEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable pop3 nio
     *
     * @param zimbraPop3NioEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1794)
    public Map<String,Object> setPop3NioEnabled(boolean zimbraPop3NioEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3NioEnabled, zimbraPop3NioEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to enable pop3 nio
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1794)
    public void unsetPop3NioEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3NioEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable pop3 nio
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1794)
    public Map<String,Object> unsetPop3NioEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3NioEnabled, "");
        return attrs;
    }

    /**
     * number of handler threads
     *
     * @return zimbraPop3NumThreads, or -1 if unset
     */
    @ZAttr(id=96)
    public int getPop3NumThreads() {
        return getIntAttr(Provisioning.A_zimbraPop3NumThreads, -1);
    }

    /**
     * number of handler threads
     *
     * @param zimbraPop3NumThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=96)
    public void setPop3NumThreads(int zimbraPop3NumThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3NumThreads, Integer.toString(zimbraPop3NumThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of handler threads
     *
     * @param zimbraPop3NumThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=96)
    public Map<String,Object> setPop3NumThreads(int zimbraPop3NumThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3NumThreads, Integer.toString(zimbraPop3NumThreads));
        return attrs;
    }

    /**
     * number of handler threads
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=96)
    public void unsetPop3NumThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3NumThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of handler threads
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=96)
    public Map<String,Object> unsetPop3NumThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3NumThreads, "");
        return attrs;
    }

    /**
     * interface address on which POP3 server should listen; if empty, binds
     * to all interfaces
     *
     * @return zimbraPop3SSLBindAddress, or empty array if unset
     */
    @ZAttr(id=186)
    public String[] getPop3SSLBindAddress() {
        return getMultiAttr(Provisioning.A_zimbraPop3SSLBindAddress);
    }

    /**
     * interface address on which POP3 server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraPop3SSLBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=186)
    public void setPop3SSLBindAddress(String[] zimbraPop3SSLBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLBindAddress, zimbraPop3SSLBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which POP3 server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraPop3SSLBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=186)
    public Map<String,Object> setPop3SSLBindAddress(String[] zimbraPop3SSLBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLBindAddress, zimbraPop3SSLBindAddress);
        return attrs;
    }

    /**
     * interface address on which POP3 server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraPop3SSLBindAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=186)
    public void addPop3SSLBindAddress(String zimbraPop3SSLBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPop3SSLBindAddress, zimbraPop3SSLBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which POP3 server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraPop3SSLBindAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=186)
    public Map<String,Object> addPop3SSLBindAddress(String zimbraPop3SSLBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPop3SSLBindAddress, zimbraPop3SSLBindAddress);
        return attrs;
    }

    /**
     * interface address on which POP3 server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraPop3SSLBindAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=186)
    public void removePop3SSLBindAddress(String zimbraPop3SSLBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPop3SSLBindAddress, zimbraPop3SSLBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which POP3 server should listen; if empty, binds
     * to all interfaces
     *
     * @param zimbraPop3SSLBindAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=186)
    public Map<String,Object> removePop3SSLBindAddress(String zimbraPop3SSLBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPop3SSLBindAddress, zimbraPop3SSLBindAddress);
        return attrs;
    }

    /**
     * interface address on which POP3 server should listen; if empty, binds
     * to all interfaces
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=186)
    public void unsetPop3SSLBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which POP3 server should listen; if empty, binds
     * to all interfaces
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=186)
    public Map<String,Object> unsetPop3SSLBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLBindAddress, "");
        return attrs;
    }

    /**
     * Pop3 maximum keep alive time in seconds. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getPop3ThreadKeepAliveTimeAsString to access value as a string.
     *
     * @see #getPop3ThreadKeepAliveTimeAsString()
     *
     * @return zimbraPop3ThreadKeepAliveTime in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1808)
    public long getPop3ThreadKeepAliveTime() {
        return getTimeInterval(Provisioning.A_zimbraPop3ThreadKeepAliveTime, -1L);
    }

    /**
     * Pop3 maximum keep alive time in seconds. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraPop3ThreadKeepAliveTime, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1808)
    public String getPop3ThreadKeepAliveTimeAsString() {
        return getAttr(Provisioning.A_zimbraPop3ThreadKeepAliveTime, null);
    }

    /**
     * Pop3 maximum keep alive time in seconds. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraPop3ThreadKeepAliveTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1808)
    public void setPop3ThreadKeepAliveTime(String zimbraPop3ThreadKeepAliveTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ThreadKeepAliveTime, zimbraPop3ThreadKeepAliveTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Pop3 maximum keep alive time in seconds. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraPop3ThreadKeepAliveTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1808)
    public Map<String,Object> setPop3ThreadKeepAliveTime(String zimbraPop3ThreadKeepAliveTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ThreadKeepAliveTime, zimbraPop3ThreadKeepAliveTime);
        return attrs;
    }

    /**
     * Pop3 maximum keep alive time in seconds. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1808)
    public void unsetPop3ThreadKeepAliveTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ThreadKeepAliveTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Pop3 maximum keep alive time in seconds. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1808)
    public Map<String,Object> unsetPop3ThreadKeepAliveTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ThreadKeepAliveTime, "");
        return attrs;
    }

    /**
     * pop3 throttle account. Maximum allowed requests per second per account
     * .
     *
     * @return zimbraPop3ThrottleAcctLimit, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1810)
    public int getPop3ThrottleAcctLimit() {
        return getIntAttr(Provisioning.A_zimbraPop3ThrottleAcctLimit, -1);
    }

    /**
     * pop3 throttle account. Maximum allowed requests per second per account
     * .
     *
     * @param zimbraPop3ThrottleAcctLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1810)
    public void setPop3ThrottleAcctLimit(int zimbraPop3ThrottleAcctLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ThrottleAcctLimit, Integer.toString(zimbraPop3ThrottleAcctLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * pop3 throttle account. Maximum allowed requests per second per account
     * .
     *
     * @param zimbraPop3ThrottleAcctLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1810)
    public Map<String,Object> setPop3ThrottleAcctLimit(int zimbraPop3ThrottleAcctLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ThrottleAcctLimit, Integer.toString(zimbraPop3ThrottleAcctLimit));
        return attrs;
    }

    /**
     * pop3 throttle account. Maximum allowed requests per second per account
     * .
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1810)
    public void unsetPop3ThrottleAcctLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ThrottleAcctLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * pop3 throttle account. Maximum allowed requests per second per account
     * .
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1810)
    public Map<String,Object> unsetPop3ThrottleAcctLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ThrottleAcctLimit, "");
        return attrs;
    }

    /**
     * pop3 ip throttle. Maximum allowed requests per second per ip .
     *
     * @return zimbraPop3ThrottleIpLimit, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1809)
    public int getPop3ThrottleIpLimit() {
        return getIntAttr(Provisioning.A_zimbraPop3ThrottleIpLimit, -1);
    }

    /**
     * pop3 ip throttle. Maximum allowed requests per second per ip .
     *
     * @param zimbraPop3ThrottleIpLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1809)
    public void setPop3ThrottleIpLimit(int zimbraPop3ThrottleIpLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ThrottleIpLimit, Integer.toString(zimbraPop3ThrottleIpLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * pop3 ip throttle. Maximum allowed requests per second per ip .
     *
     * @param zimbraPop3ThrottleIpLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1809)
    public Map<String,Object> setPop3ThrottleIpLimit(int zimbraPop3ThrottleIpLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ThrottleIpLimit, Integer.toString(zimbraPop3ThrottleIpLimit));
        return attrs;
    }

    /**
     * pop3 ip throttle. Maximum allowed requests per second per ip .
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1809)
    public void unsetPop3ThrottleIpLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ThrottleIpLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * pop3 ip throttle. Maximum allowed requests per second per ip .
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1809)
    public Map<String,Object> unsetPop3ThrottleIpLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ThrottleIpLimit, "");
        return attrs;
    }

    /**
     * Pop3 timeout in seconds
     *
     * @return zimbraPop3Timeout, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1726)
    public int getPop3Timeout() {
        return getIntAttr(Provisioning.A_zimbraPop3Timeout, -1);
    }

    /**
     * Pop3 timeout in seconds
     *
     * @param zimbraPop3Timeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1726)
    public void setPop3Timeout(int zimbraPop3Timeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3Timeout, Integer.toString(zimbraPop3Timeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Pop3 timeout in seconds
     *
     * @param zimbraPop3Timeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1726)
    public Map<String,Object> setPop3Timeout(int zimbraPop3Timeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3Timeout, Integer.toString(zimbraPop3Timeout));
        return attrs;
    }

    /**
     * Pop3 timeout in seconds
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1726)
    public void unsetPop3Timeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3Timeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Pop3 timeout in seconds
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1726)
    public Map<String,Object> unsetPop3Timeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3Timeout, "");
        return attrs;
    }

    /**
     * Pop3 write timeout in seconds. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getPop3WriteTimeoutAsString to access value as a string.
     *
     * @see #getPop3WriteTimeoutAsString()
     *
     * @return zimbraPop3WriteTimeout in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1807)
    public long getPop3WriteTimeout() {
        return getTimeInterval(Provisioning.A_zimbraPop3WriteTimeout, -1L);
    }

    /**
     * Pop3 write timeout in seconds. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraPop3WriteTimeout, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1807)
    public String getPop3WriteTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraPop3WriteTimeout, null);
    }

    /**
     * Pop3 write timeout in seconds. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraPop3WriteTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1807)
    public void setPop3WriteTimeout(String zimbraPop3WriteTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3WriteTimeout, zimbraPop3WriteTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Pop3 write timeout in seconds. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraPop3WriteTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1807)
    public Map<String,Object> setPop3WriteTimeout(String zimbraPop3WriteTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3WriteTimeout, zimbraPop3WriteTimeout);
        return attrs;
    }

    /**
     * Pop3 write timeout in seconds. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1807)
    public void unsetPop3WriteTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3WriteTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Pop3 write timeout in seconds. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1807)
    public Map<String,Object> unsetPop3WriteTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3WriteTimeout, "");
        return attrs;
    }

    /**
     * Max number of previous residing folders server tracks for a mail item
     *
     * @return zimbraPrevFoldersToTrackMax, or -1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1592)
    public int getPrevFoldersToTrackMax() {
        return getIntAttr(Provisioning.A_zimbraPrevFoldersToTrackMax, -1);
    }

    /**
     * Max number of previous residing folders server tracks for a mail item
     *
     * @param zimbraPrevFoldersToTrackMax new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1592)
    public void setPrevFoldersToTrackMax(int zimbraPrevFoldersToTrackMax) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrevFoldersToTrackMax, Integer.toString(zimbraPrevFoldersToTrackMax));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max number of previous residing folders server tracks for a mail item
     *
     * @param zimbraPrevFoldersToTrackMax new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1592)
    public Map<String,Object> setPrevFoldersToTrackMax(int zimbraPrevFoldersToTrackMax, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrevFoldersToTrackMax, Integer.toString(zimbraPrevFoldersToTrackMax));
        return attrs;
    }

    /**
     * Max number of previous residing folders server tracks for a mail item
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1592)
    public void unsetPrevFoldersToTrackMax() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrevFoldersToTrackMax, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max number of previous residing folders server tracks for a mail item
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1592)
    public Map<String,Object> unsetPrevFoldersToTrackMax(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrevFoldersToTrackMax, "");
        return attrs;
    }

    /**
     * Maximum size of the Redis connection pool
     *
     * @return zimbraRedisMaxConnectionCount, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1951)
    public int getRedisMaxConnectionCount() {
        return getIntAttr(Provisioning.A_zimbraRedisMaxConnectionCount, -1);
    }

    /**
     * Maximum size of the Redis connection pool
     *
     * @param zimbraRedisMaxConnectionCount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1951)
    public void setRedisMaxConnectionCount(int zimbraRedisMaxConnectionCount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedisMaxConnectionCount, Integer.toString(zimbraRedisMaxConnectionCount));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum size of the Redis connection pool
     *
     * @param zimbraRedisMaxConnectionCount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1951)
    public Map<String,Object> setRedisMaxConnectionCount(int zimbraRedisMaxConnectionCount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedisMaxConnectionCount, Integer.toString(zimbraRedisMaxConnectionCount));
        return attrs;
    }

    /**
     * Maximum size of the Redis connection pool
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1951)
    public void unsetRedisMaxConnectionCount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedisMaxConnectionCount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum size of the Redis connection pool
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1951)
    public Map<String,Object> unsetRedisMaxConnectionCount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedisMaxConnectionCount, "");
        return attrs;
    }

    /**
     * The name of the Redis master, used by Redis Sentinel. This name
     * matches the &quot;sentinel monitor [mymaster]&quot; entry in
     * redis-sentinel.conf.
     *
     * @return zimbraRedisSentinelMaster, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1979)
    public String getRedisSentinelMaster() {
        return getAttr(Provisioning.A_zimbraRedisSentinelMaster, null);
    }

    /**
     * The name of the Redis master, used by Redis Sentinel. This name
     * matches the &quot;sentinel monitor [mymaster]&quot; entry in
     * redis-sentinel.conf.
     *
     * @param zimbraRedisSentinelMaster new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1979)
    public void setRedisSentinelMaster(String zimbraRedisSentinelMaster) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedisSentinelMaster, zimbraRedisSentinelMaster);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The name of the Redis master, used by Redis Sentinel. This name
     * matches the &quot;sentinel monitor [mymaster]&quot; entry in
     * redis-sentinel.conf.
     *
     * @param zimbraRedisSentinelMaster new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1979)
    public Map<String,Object> setRedisSentinelMaster(String zimbraRedisSentinelMaster, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedisSentinelMaster, zimbraRedisSentinelMaster);
        return attrs;
    }

    /**
     * The name of the Redis master, used by Redis Sentinel. This name
     * matches the &quot;sentinel monitor [mymaster]&quot; entry in
     * redis-sentinel.conf.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1979)
    public void unsetRedisSentinelMaster() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedisSentinelMaster, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The name of the Redis master, used by Redis Sentinel. This name
     * matches the &quot;sentinel monitor [mymaster]&quot; entry in
     * redis-sentinel.conf.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1979)
    public Map<String,Object> unsetRedisSentinelMaster(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedisSentinelMaster, "");
        return attrs;
    }

    /**
     * Redis Sentinel URIs. Use redis:// URIs, one for each Sentinel node.
     *
     * @return zimbraRedisSentinelUrl, or empty array if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1978)
    public String[] getRedisSentinelUrl() {
        return getMultiAttr(Provisioning.A_zimbraRedisSentinelUrl);
    }

    /**
     * Redis Sentinel URIs. Use redis:// URIs, one for each Sentinel node.
     *
     * @param zimbraRedisSentinelUrl new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1978)
    public void setRedisSentinelUrl(String[] zimbraRedisSentinelUrl) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedisSentinelUrl, zimbraRedisSentinelUrl);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Redis Sentinel URIs. Use redis:// URIs, one for each Sentinel node.
     *
     * @param zimbraRedisSentinelUrl new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1978)
    public Map<String,Object> setRedisSentinelUrl(String[] zimbraRedisSentinelUrl, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedisSentinelUrl, zimbraRedisSentinelUrl);
        return attrs;
    }

    /**
     * Redis Sentinel URIs. Use redis:// URIs, one for each Sentinel node.
     *
     * @param zimbraRedisSentinelUrl new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1978)
    public void addRedisSentinelUrl(String zimbraRedisSentinelUrl) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraRedisSentinelUrl, zimbraRedisSentinelUrl);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Redis Sentinel URIs. Use redis:// URIs, one for each Sentinel node.
     *
     * @param zimbraRedisSentinelUrl new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1978)
    public Map<String,Object> addRedisSentinelUrl(String zimbraRedisSentinelUrl, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraRedisSentinelUrl, zimbraRedisSentinelUrl);
        return attrs;
    }

    /**
     * Redis Sentinel URIs. Use redis:// URIs, one for each Sentinel node.
     *
     * @param zimbraRedisSentinelUrl existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1978)
    public void removeRedisSentinelUrl(String zimbraRedisSentinelUrl) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraRedisSentinelUrl, zimbraRedisSentinelUrl);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Redis Sentinel URIs. Use redis:// URIs, one for each Sentinel node.
     *
     * @param zimbraRedisSentinelUrl existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1978)
    public Map<String,Object> removeRedisSentinelUrl(String zimbraRedisSentinelUrl, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraRedisSentinelUrl, zimbraRedisSentinelUrl);
        return attrs;
    }

    /**
     * Redis Sentinel URIs. Use redis:// URIs, one for each Sentinel node.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1978)
    public void unsetRedisSentinelUrl() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedisSentinelUrl, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Redis Sentinel URIs. Use redis:// URIs, one for each Sentinel node.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1978)
    public Map<String,Object> unsetRedisSentinelUrl(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedisSentinelUrl, "");
        return attrs;
    }

    /**
     * Redis URIs. When using stand-alone or master/slave+Sentinel, set a
     * single value with the redis:// URI. When using Redis Cluster, set
     * multiple redis:// URI values, one for every master and slave node.
     *
     * @return zimbraRedisUrl, or empty array if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1788)
    public String[] getRedisUrl() {
        return getMultiAttr(Provisioning.A_zimbraRedisUrl);
    }

    /**
     * Redis URIs. When using stand-alone or master/slave+Sentinel, set a
     * single value with the redis:// URI. When using Redis Cluster, set
     * multiple redis:// URI values, one for every master and slave node.
     *
     * @param zimbraRedisUrl new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1788)
    public void setRedisUrl(String[] zimbraRedisUrl) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedisUrl, zimbraRedisUrl);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Redis URIs. When using stand-alone or master/slave+Sentinel, set a
     * single value with the redis:// URI. When using Redis Cluster, set
     * multiple redis:// URI values, one for every master and slave node.
     *
     * @param zimbraRedisUrl new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1788)
    public Map<String,Object> setRedisUrl(String[] zimbraRedisUrl, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedisUrl, zimbraRedisUrl);
        return attrs;
    }

    /**
     * Redis URIs. When using stand-alone or master/slave+Sentinel, set a
     * single value with the redis:// URI. When using Redis Cluster, set
     * multiple redis:// URI values, one for every master and slave node.
     *
     * @param zimbraRedisUrl new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1788)
    public void addRedisUrl(String zimbraRedisUrl) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraRedisUrl, zimbraRedisUrl);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Redis URIs. When using stand-alone or master/slave+Sentinel, set a
     * single value with the redis:// URI. When using Redis Cluster, set
     * multiple redis:// URI values, one for every master and slave node.
     *
     * @param zimbraRedisUrl new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1788)
    public Map<String,Object> addRedisUrl(String zimbraRedisUrl, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraRedisUrl, zimbraRedisUrl);
        return attrs;
    }

    /**
     * Redis URIs. When using stand-alone or master/slave+Sentinel, set a
     * single value with the redis:// URI. When using Redis Cluster, set
     * multiple redis:// URI values, one for every master and slave node.
     *
     * @param zimbraRedisUrl existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1788)
    public void removeRedisUrl(String zimbraRedisUrl) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraRedisUrl, zimbraRedisUrl);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Redis URIs. When using stand-alone or master/slave+Sentinel, set a
     * single value with the redis:// URI. When using Redis Cluster, set
     * multiple redis:// URI values, one for every master and slave node.
     *
     * @param zimbraRedisUrl existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1788)
    public Map<String,Object> removeRedisUrl(String zimbraRedisUrl, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraRedisUrl, zimbraRedisUrl);
        return attrs;
    }

    /**
     * Redis URIs. When using stand-alone or master/slave+Sentinel, set a
     * single value with the redis:// URI. When using Redis Cluster, set
     * multiple redis:// URI values, one for every master and slave node.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1788)
    public void unsetRedisUrl() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedisUrl, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Redis URIs. When using stand-alone or master/slave+Sentinel, set a
     * single value with the redis:// URI. When using Redis Cluster, set
     * multiple redis:// URI values, one for every master and slave node.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1788)
    public Map<String,Object> unsetRedisUrl(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedisUrl, "");
        return attrs;
    }

    /**
     * redolog rollover destination
     *
     * @return zimbraRedoLogArchiveDir, or null if unset
     */
    @ZAttr(id=76)
    public String getRedoLogArchiveDir() {
        return getAttr(Provisioning.A_zimbraRedoLogArchiveDir, null);
    }

    /**
     * redolog rollover destination
     *
     * @param zimbraRedoLogArchiveDir new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=76)
    public void setRedoLogArchiveDir(String zimbraRedoLogArchiveDir) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogArchiveDir, zimbraRedoLogArchiveDir);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * redolog rollover destination
     *
     * @param zimbraRedoLogArchiveDir new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=76)
    public Map<String,Object> setRedoLogArchiveDir(String zimbraRedoLogArchiveDir, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogArchiveDir, zimbraRedoLogArchiveDir);
        return attrs;
    }

    /**
     * redolog rollover destination
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=76)
    public void unsetRedoLogArchiveDir() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogArchiveDir, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * redolog rollover destination
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=76)
    public Map<String,Object> unsetRedoLogArchiveDir(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogArchiveDir, "");
        return attrs;
    }

    /**
     * how many seconds worth of committed redo ops to re-execute during
     * crash recovery; related to mysql parameter
     * innodb_flush_log_at_trx_commit=0
     *
     * @return zimbraRedoLogCrashRecoveryLookbackSec, or -1 if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1009)
    public int getRedoLogCrashRecoveryLookbackSec() {
        return getIntAttr(Provisioning.A_zimbraRedoLogCrashRecoveryLookbackSec, -1);
    }

    /**
     * how many seconds worth of committed redo ops to re-execute during
     * crash recovery; related to mysql parameter
     * innodb_flush_log_at_trx_commit=0
     *
     * @param zimbraRedoLogCrashRecoveryLookbackSec new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1009)
    public void setRedoLogCrashRecoveryLookbackSec(int zimbraRedoLogCrashRecoveryLookbackSec) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogCrashRecoveryLookbackSec, Integer.toString(zimbraRedoLogCrashRecoveryLookbackSec));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how many seconds worth of committed redo ops to re-execute during
     * crash recovery; related to mysql parameter
     * innodb_flush_log_at_trx_commit=0
     *
     * @param zimbraRedoLogCrashRecoveryLookbackSec new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1009)
    public Map<String,Object> setRedoLogCrashRecoveryLookbackSec(int zimbraRedoLogCrashRecoveryLookbackSec, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogCrashRecoveryLookbackSec, Integer.toString(zimbraRedoLogCrashRecoveryLookbackSec));
        return attrs;
    }

    /**
     * how many seconds worth of committed redo ops to re-execute during
     * crash recovery; related to mysql parameter
     * innodb_flush_log_at_trx_commit=0
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1009)
    public void unsetRedoLogCrashRecoveryLookbackSec() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogCrashRecoveryLookbackSec, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how many seconds worth of committed redo ops to re-execute during
     * crash recovery; related to mysql parameter
     * innodb_flush_log_at_trx_commit=0
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1009)
    public Map<String,Object> unsetRedoLogCrashRecoveryLookbackSec(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogCrashRecoveryLookbackSec, "");
        return attrs;
    }

    /**
     * whether logs are delete on rollover or archived
     *
     * @return zimbraRedoLogDeleteOnRollover, or false if unset
     */
    @ZAttr(id=251)
    public boolean isRedoLogDeleteOnRollover() {
        return getBooleanAttr(Provisioning.A_zimbraRedoLogDeleteOnRollover, false);
    }

    /**
     * whether logs are delete on rollover or archived
     *
     * @param zimbraRedoLogDeleteOnRollover new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=251)
    public void setRedoLogDeleteOnRollover(boolean zimbraRedoLogDeleteOnRollover) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogDeleteOnRollover, zimbraRedoLogDeleteOnRollover ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether logs are delete on rollover or archived
     *
     * @param zimbraRedoLogDeleteOnRollover new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=251)
    public Map<String,Object> setRedoLogDeleteOnRollover(boolean zimbraRedoLogDeleteOnRollover, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogDeleteOnRollover, zimbraRedoLogDeleteOnRollover ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * whether logs are delete on rollover or archived
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=251)
    public void unsetRedoLogDeleteOnRollover() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogDeleteOnRollover, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether logs are delete on rollover or archived
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=251)
    public Map<String,Object> unsetRedoLogDeleteOnRollover(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogDeleteOnRollover, "");
        return attrs;
    }

    /**
     * whether redo logging is enabled
     *
     * @return zimbraRedoLogEnabled, or false if unset
     */
    @ZAttr(id=74)
    public boolean isRedoLogEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraRedoLogEnabled, false);
    }

    /**
     * whether redo logging is enabled
     *
     * @param zimbraRedoLogEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=74)
    public void setRedoLogEnabled(boolean zimbraRedoLogEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogEnabled, zimbraRedoLogEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether redo logging is enabled
     *
     * @param zimbraRedoLogEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=74)
    public Map<String,Object> setRedoLogEnabled(boolean zimbraRedoLogEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogEnabled, zimbraRedoLogEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * whether redo logging is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=74)
    public void unsetRedoLogEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether redo logging is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=74)
    public Map<String,Object> unsetRedoLogEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogEnabled, "");
        return attrs;
    }

    /**
     * how frequently writes to redo log get fsynced to disk
     *
     * @return zimbraRedoLogFsyncIntervalMS, or -1 if unset
     */
    @ZAttr(id=79)
    public int getRedoLogFsyncIntervalMS() {
        return getIntAttr(Provisioning.A_zimbraRedoLogFsyncIntervalMS, -1);
    }

    /**
     * how frequently writes to redo log get fsynced to disk
     *
     * @param zimbraRedoLogFsyncIntervalMS new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=79)
    public void setRedoLogFsyncIntervalMS(int zimbraRedoLogFsyncIntervalMS) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogFsyncIntervalMS, Integer.toString(zimbraRedoLogFsyncIntervalMS));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how frequently writes to redo log get fsynced to disk
     *
     * @param zimbraRedoLogFsyncIntervalMS new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=79)
    public Map<String,Object> setRedoLogFsyncIntervalMS(int zimbraRedoLogFsyncIntervalMS, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogFsyncIntervalMS, Integer.toString(zimbraRedoLogFsyncIntervalMS));
        return attrs;
    }

    /**
     * how frequently writes to redo log get fsynced to disk
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=79)
    public void unsetRedoLogFsyncIntervalMS() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogFsyncIntervalMS, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how frequently writes to redo log get fsynced to disk
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=79)
    public Map<String,Object> unsetRedoLogFsyncIntervalMS(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogFsyncIntervalMS, "");
        return attrs;
    }

    /**
     * name and location of the redolog file
     *
     * @return zimbraRedoLogLogPath, or null if unset
     */
    @ZAttr(id=75)
    public String getRedoLogLogPath() {
        return getAttr(Provisioning.A_zimbraRedoLogLogPath, null);
    }

    /**
     * name and location of the redolog file
     *
     * @param zimbraRedoLogLogPath new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=75)
    public void setRedoLogLogPath(String zimbraRedoLogLogPath) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogLogPath, zimbraRedoLogLogPath);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * name and location of the redolog file
     *
     * @param zimbraRedoLogLogPath new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=75)
    public Map<String,Object> setRedoLogLogPath(String zimbraRedoLogLogPath, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogLogPath, zimbraRedoLogLogPath);
        return attrs;
    }

    /**
     * name and location of the redolog file
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=75)
    public void unsetRedoLogLogPath() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogLogPath, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * name and location of the redolog file
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=75)
    public Map<String,Object> unsetRedoLogLogPath(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogLogPath, "");
        return attrs;
    }

    /**
     * provider class name for redo logging
     *
     * @return zimbraRedoLogProvider, or empty array if unset
     */
    @ZAttr(id=225)
    public String[] getRedoLogProvider() {
        return getMultiAttr(Provisioning.A_zimbraRedoLogProvider);
    }

    /**
     * provider class name for redo logging
     *
     * @param zimbraRedoLogProvider new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=225)
    public void setRedoLogProvider(String[] zimbraRedoLogProvider) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogProvider, zimbraRedoLogProvider);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * provider class name for redo logging
     *
     * @param zimbraRedoLogProvider new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=225)
    public Map<String,Object> setRedoLogProvider(String[] zimbraRedoLogProvider, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogProvider, zimbraRedoLogProvider);
        return attrs;
    }

    /**
     * provider class name for redo logging
     *
     * @param zimbraRedoLogProvider new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=225)
    public void addRedoLogProvider(String zimbraRedoLogProvider) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraRedoLogProvider, zimbraRedoLogProvider);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * provider class name for redo logging
     *
     * @param zimbraRedoLogProvider new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=225)
    public Map<String,Object> addRedoLogProvider(String zimbraRedoLogProvider, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraRedoLogProvider, zimbraRedoLogProvider);
        return attrs;
    }

    /**
     * provider class name for redo logging
     *
     * @param zimbraRedoLogProvider existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=225)
    public void removeRedoLogProvider(String zimbraRedoLogProvider) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraRedoLogProvider, zimbraRedoLogProvider);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * provider class name for redo logging
     *
     * @param zimbraRedoLogProvider existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=225)
    public Map<String,Object> removeRedoLogProvider(String zimbraRedoLogProvider, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraRedoLogProvider, zimbraRedoLogProvider);
        return attrs;
    }

    /**
     * provider class name for redo logging
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=225)
    public void unsetRedoLogProvider() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogProvider, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * provider class name for redo logging
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=225)
    public Map<String,Object> unsetRedoLogProvider(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogProvider, "");
        return attrs;
    }

    /**
     * redo.log file becomes eligible for rollover over when it goes over
     * this size
     *
     * @return zimbraRedoLogRolloverFileSizeKB, or -1 if unset
     */
    @ZAttr(id=78)
    public int getRedoLogRolloverFileSizeKB() {
        return getIntAttr(Provisioning.A_zimbraRedoLogRolloverFileSizeKB, -1);
    }

    /**
     * redo.log file becomes eligible for rollover over when it goes over
     * this size
     *
     * @param zimbraRedoLogRolloverFileSizeKB new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=78)
    public void setRedoLogRolloverFileSizeKB(int zimbraRedoLogRolloverFileSizeKB) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverFileSizeKB, Integer.toString(zimbraRedoLogRolloverFileSizeKB));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * redo.log file becomes eligible for rollover over when it goes over
     * this size
     *
     * @param zimbraRedoLogRolloverFileSizeKB new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=78)
    public Map<String,Object> setRedoLogRolloverFileSizeKB(int zimbraRedoLogRolloverFileSizeKB, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverFileSizeKB, Integer.toString(zimbraRedoLogRolloverFileSizeKB));
        return attrs;
    }

    /**
     * redo.log file becomes eligible for rollover over when it goes over
     * this size
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=78)
    public void unsetRedoLogRolloverFileSizeKB() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverFileSizeKB, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * redo.log file becomes eligible for rollover over when it goes over
     * this size
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=78)
    public Map<String,Object> unsetRedoLogRolloverFileSizeKB(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverFileSizeKB, "");
        return attrs;
    }

    /**
     * redo.log file rolls over when it goes over this size, even if it does
     * not meet the minimum file age requirement
     *
     * @return zimbraRedoLogRolloverHardMaxFileSizeKB, or -1 if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1021)
    public int getRedoLogRolloverHardMaxFileSizeKB() {
        return getIntAttr(Provisioning.A_zimbraRedoLogRolloverHardMaxFileSizeKB, -1);
    }

    /**
     * redo.log file rolls over when it goes over this size, even if it does
     * not meet the minimum file age requirement
     *
     * @param zimbraRedoLogRolloverHardMaxFileSizeKB new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1021)
    public void setRedoLogRolloverHardMaxFileSizeKB(int zimbraRedoLogRolloverHardMaxFileSizeKB) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverHardMaxFileSizeKB, Integer.toString(zimbraRedoLogRolloverHardMaxFileSizeKB));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * redo.log file rolls over when it goes over this size, even if it does
     * not meet the minimum file age requirement
     *
     * @param zimbraRedoLogRolloverHardMaxFileSizeKB new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1021)
    public Map<String,Object> setRedoLogRolloverHardMaxFileSizeKB(int zimbraRedoLogRolloverHardMaxFileSizeKB, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverHardMaxFileSizeKB, Integer.toString(zimbraRedoLogRolloverHardMaxFileSizeKB));
        return attrs;
    }

    /**
     * redo.log file rolls over when it goes over this size, even if it does
     * not meet the minimum file age requirement
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1021)
    public void unsetRedoLogRolloverHardMaxFileSizeKB() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverHardMaxFileSizeKB, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * redo.log file rolls over when it goes over this size, even if it does
     * not meet the minimum file age requirement
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1021)
    public Map<String,Object> unsetRedoLogRolloverHardMaxFileSizeKB(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverHardMaxFileSizeKB, "");
        return attrs;
    }

    /**
     * minimum age in minutes for redo.log file before it becomes eligible
     * for rollover based on size
     *
     * @return zimbraRedoLogRolloverMinFileAge, or -1 if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1020)
    public int getRedoLogRolloverMinFileAge() {
        return getIntAttr(Provisioning.A_zimbraRedoLogRolloverMinFileAge, -1);
    }

    /**
     * minimum age in minutes for redo.log file before it becomes eligible
     * for rollover based on size
     *
     * @param zimbraRedoLogRolloverMinFileAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1020)
    public void setRedoLogRolloverMinFileAge(int zimbraRedoLogRolloverMinFileAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverMinFileAge, Integer.toString(zimbraRedoLogRolloverMinFileAge));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum age in minutes for redo.log file before it becomes eligible
     * for rollover based on size
     *
     * @param zimbraRedoLogRolloverMinFileAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1020)
    public Map<String,Object> setRedoLogRolloverMinFileAge(int zimbraRedoLogRolloverMinFileAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverMinFileAge, Integer.toString(zimbraRedoLogRolloverMinFileAge));
        return attrs;
    }

    /**
     * minimum age in minutes for redo.log file before it becomes eligible
     * for rollover based on size
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1020)
    public void unsetRedoLogRolloverMinFileAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverMinFileAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum age in minutes for redo.log file before it becomes eligible
     * for rollover based on size
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1020)
    public Map<String,Object> unsetRedoLogRolloverMinFileAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverMinFileAge, "");
        return attrs;
    }

    /**
     * interface address on which redolog service should listen; if empty,
     * binds to all localhost
     *
     * @return zimbraRedologBindAddress, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1961)
    public String getRedologBindAddress() {
        return getAttr(Provisioning.A_zimbraRedologBindAddress, null);
    }

    /**
     * interface address on which redolog service should listen; if empty,
     * binds to all localhost
     *
     * @param zimbraRedologBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1961)
    public void setRedologBindAddress(String zimbraRedologBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedologBindAddress, zimbraRedologBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which redolog service should listen; if empty,
     * binds to all localhost
     *
     * @param zimbraRedologBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1961)
    public Map<String,Object> setRedologBindAddress(String zimbraRedologBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedologBindAddress, zimbraRedologBindAddress);
        return attrs;
    }

    /**
     * interface address on which redolog service should listen; if empty,
     * binds to all localhost
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1961)
    public void unsetRedologBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedologBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which redolog service should listen; if empty,
     * binds to all localhost
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1961)
    public Map<String,Object> unsetRedologBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedologBindAddress, "");
        return attrs;
    }

    /**
     * HTTPs port for redolog service
     *
     * <p>Use getRedologBindPortAsString to access value as a string.
     *
     * @see #getRedologBindPortAsString()
     *
     * @return zimbraRedologBindPort, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1962)
    public int getRedologBindPort() {
        return getIntAttr(Provisioning.A_zimbraRedologBindPort, -1);
    }

    /**
     * HTTPs port for redolog service
     *
     * @return zimbraRedologBindPort, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1962)
    public String getRedologBindPortAsString() {
        return getAttr(Provisioning.A_zimbraRedologBindPort, null);
    }

    /**
     * HTTPs port for redolog service
     *
     * @param zimbraRedologBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1962)
    public void setRedologBindPort(int zimbraRedologBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedologBindPort, Integer.toString(zimbraRedologBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTPs port for redolog service
     *
     * @param zimbraRedologBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1962)
    public Map<String,Object> setRedologBindPort(int zimbraRedologBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedologBindPort, Integer.toString(zimbraRedologBindPort));
        return attrs;
    }

    /**
     * HTTPs port for redolog service
     *
     * @param zimbraRedologBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1962)
    public void setRedologBindPortAsString(String zimbraRedologBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedologBindPort, zimbraRedologBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTPs port for redolog service
     *
     * @param zimbraRedologBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1962)
    public Map<String,Object> setRedologBindPortAsString(String zimbraRedologBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedologBindPort, zimbraRedologBindPort);
        return attrs;
    }

    /**
     * HTTPs port for redolog service
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1962)
    public void unsetRedologBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedologBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTPs port for redolog service
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1962)
    public Map<String,Object> unsetRedologBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedologBindPort, "");
        return attrs;
    }

    /**
     * Maximum number of items to put into a single reindexing task.
     *
     * @return zimbraReindexBatchSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1834)
    public int getReindexBatchSize() {
        return getIntAttr(Provisioning.A_zimbraReindexBatchSize, -1);
    }

    /**
     * Maximum number of items to put into a single reindexing task.
     *
     * @param zimbraReindexBatchSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1834)
    public void setReindexBatchSize(int zimbraReindexBatchSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReindexBatchSize, Integer.toString(zimbraReindexBatchSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of items to put into a single reindexing task.
     *
     * @param zimbraReindexBatchSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1834)
    public Map<String,Object> setReindexBatchSize(int zimbraReindexBatchSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReindexBatchSize, Integer.toString(zimbraReindexBatchSize));
        return attrs;
    }

    /**
     * Maximum number of items to put into a single reindexing task.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1834)
    public void unsetReindexBatchSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReindexBatchSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of items to put into a single reindexing task.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1834)
    public Map<String,Object> unsetReindexBatchSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReindexBatchSize, "");
        return attrs;
    }

    /**
     * Path to remote management command to execute on this server
     *
     * @return zimbraRemoteManagementCommand, or null if unset
     */
    @ZAttr(id=336)
    public String getRemoteManagementCommand() {
        return getAttr(Provisioning.A_zimbraRemoteManagementCommand, null);
    }

    /**
     * Path to remote management command to execute on this server
     *
     * @param zimbraRemoteManagementCommand new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=336)
    public void setRemoteManagementCommand(String zimbraRemoteManagementCommand) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementCommand, zimbraRemoteManagementCommand);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Path to remote management command to execute on this server
     *
     * @param zimbraRemoteManagementCommand new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=336)
    public Map<String,Object> setRemoteManagementCommand(String zimbraRemoteManagementCommand, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementCommand, zimbraRemoteManagementCommand);
        return attrs;
    }

    /**
     * Path to remote management command to execute on this server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=336)
    public void unsetRemoteManagementCommand() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementCommand, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Path to remote management command to execute on this server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=336)
    public Map<String,Object> unsetRemoteManagementCommand(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementCommand, "");
        return attrs;
    }

    /**
     * Port on which remote management sshd listening on this server.
     *
     * @return zimbraRemoteManagementPort, or -1 if unset
     */
    @ZAttr(id=339)
    public int getRemoteManagementPort() {
        return getIntAttr(Provisioning.A_zimbraRemoteManagementPort, -1);
    }

    /**
     * Port on which remote management sshd listening on this server.
     *
     * @param zimbraRemoteManagementPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=339)
    public void setRemoteManagementPort(int zimbraRemoteManagementPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementPort, Integer.toString(zimbraRemoteManagementPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Port on which remote management sshd listening on this server.
     *
     * @param zimbraRemoteManagementPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=339)
    public Map<String,Object> setRemoteManagementPort(int zimbraRemoteManagementPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementPort, Integer.toString(zimbraRemoteManagementPort));
        return attrs;
    }

    /**
     * Port on which remote management sshd listening on this server.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=339)
    public void unsetRemoteManagementPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Port on which remote management sshd listening on this server.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=339)
    public Map<String,Object> unsetRemoteManagementPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementPort, "");
        return attrs;
    }

    /**
     * Private key this server should use to access another server
     *
     * @return zimbraRemoteManagementPrivateKeyPath, or null if unset
     */
    @ZAttr(id=338)
    public String getRemoteManagementPrivateKeyPath() {
        return getAttr(Provisioning.A_zimbraRemoteManagementPrivateKeyPath, null);
    }

    /**
     * Private key this server should use to access another server
     *
     * @param zimbraRemoteManagementPrivateKeyPath new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=338)
    public void setRemoteManagementPrivateKeyPath(String zimbraRemoteManagementPrivateKeyPath) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementPrivateKeyPath, zimbraRemoteManagementPrivateKeyPath);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Private key this server should use to access another server
     *
     * @param zimbraRemoteManagementPrivateKeyPath new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=338)
    public Map<String,Object> setRemoteManagementPrivateKeyPath(String zimbraRemoteManagementPrivateKeyPath, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementPrivateKeyPath, zimbraRemoteManagementPrivateKeyPath);
        return attrs;
    }

    /**
     * Private key this server should use to access another server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=338)
    public void unsetRemoteManagementPrivateKeyPath() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementPrivateKeyPath, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Private key this server should use to access another server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=338)
    public Map<String,Object> unsetRemoteManagementPrivateKeyPath(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementPrivateKeyPath, "");
        return attrs;
    }

    /**
     * Login name of user allowed to execute remote management command
     *
     * @return zimbraRemoteManagementUser, or null if unset
     */
    @ZAttr(id=337)
    public String getRemoteManagementUser() {
        return getAttr(Provisioning.A_zimbraRemoteManagementUser, null);
    }

    /**
     * Login name of user allowed to execute remote management command
     *
     * @param zimbraRemoteManagementUser new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=337)
    public void setRemoteManagementUser(String zimbraRemoteManagementUser) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementUser, zimbraRemoteManagementUser);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Login name of user allowed to execute remote management command
     *
     * @param zimbraRemoteManagementUser new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=337)
    public Map<String,Object> setRemoteManagementUser(String zimbraRemoteManagementUser, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementUser, zimbraRemoteManagementUser);
        return attrs;
    }

    /**
     * Login name of user allowed to execute remote management command
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=337)
    public void unsetRemoteManagementUser() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementUser, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Login name of user allowed to execute remote management command
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=337)
    public Map<String,Object> unsetRemoteManagementUser(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementUser, "");
        return attrs;
    }

    /**
     * on - accept_mutex flag &#039;on&#039; for the reverse proxy. This is
     * default. off - accept_mutex flag &#039;off&#039; for the reverse
     * proxy. Turning it off will get much better distribution of client
     * connections between workers.
     *
     * <p>Valid values: [off, on]
     *
     * @return zimbraReverseProxyAcceptMutex, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1594)
    public ZAttrProvisioning.ReverseProxyAcceptMutex getReverseProxyAcceptMutex() {
        try { String v = getAttr(Provisioning.A_zimbraReverseProxyAcceptMutex); return v == null ? null : ZAttrProvisioning.ReverseProxyAcceptMutex.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * on - accept_mutex flag &#039;on&#039; for the reverse proxy. This is
     * default. off - accept_mutex flag &#039;off&#039; for the reverse
     * proxy. Turning it off will get much better distribution of client
     * connections between workers.
     *
     * <p>Valid values: [off, on]
     *
     * @return zimbraReverseProxyAcceptMutex, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1594)
    public String getReverseProxyAcceptMutexAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyAcceptMutex, null);
    }

    /**
     * on - accept_mutex flag &#039;on&#039; for the reverse proxy. This is
     * default. off - accept_mutex flag &#039;off&#039; for the reverse
     * proxy. Turning it off will get much better distribution of client
     * connections between workers.
     *
     * <p>Valid values: [off, on]
     *
     * @param zimbraReverseProxyAcceptMutex new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1594)
    public void setReverseProxyAcceptMutex(ZAttrProvisioning.ReverseProxyAcceptMutex zimbraReverseProxyAcceptMutex) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAcceptMutex, zimbraReverseProxyAcceptMutex.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * on - accept_mutex flag &#039;on&#039; for the reverse proxy. This is
     * default. off - accept_mutex flag &#039;off&#039; for the reverse
     * proxy. Turning it off will get much better distribution of client
     * connections between workers.
     *
     * <p>Valid values: [off, on]
     *
     * @param zimbraReverseProxyAcceptMutex new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1594)
    public Map<String,Object> setReverseProxyAcceptMutex(ZAttrProvisioning.ReverseProxyAcceptMutex zimbraReverseProxyAcceptMutex, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAcceptMutex, zimbraReverseProxyAcceptMutex.toString());
        return attrs;
    }

    /**
     * on - accept_mutex flag &#039;on&#039; for the reverse proxy. This is
     * default. off - accept_mutex flag &#039;off&#039; for the reverse
     * proxy. Turning it off will get much better distribution of client
     * connections between workers.
     *
     * <p>Valid values: [off, on]
     *
     * @param zimbraReverseProxyAcceptMutex new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1594)
    public void setReverseProxyAcceptMutexAsString(String zimbraReverseProxyAcceptMutex) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAcceptMutex, zimbraReverseProxyAcceptMutex);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * on - accept_mutex flag &#039;on&#039; for the reverse proxy. This is
     * default. off - accept_mutex flag &#039;off&#039; for the reverse
     * proxy. Turning it off will get much better distribution of client
     * connections between workers.
     *
     * <p>Valid values: [off, on]
     *
     * @param zimbraReverseProxyAcceptMutex new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1594)
    public Map<String,Object> setReverseProxyAcceptMutexAsString(String zimbraReverseProxyAcceptMutex, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAcceptMutex, zimbraReverseProxyAcceptMutex);
        return attrs;
    }

    /**
     * on - accept_mutex flag &#039;on&#039; for the reverse proxy. This is
     * default. off - accept_mutex flag &#039;off&#039; for the reverse
     * proxy. Turning it off will get much better distribution of client
     * connections between workers.
     *
     * <p>Valid values: [off, on]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1594)
    public void unsetReverseProxyAcceptMutex() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAcceptMutex, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * on - accept_mutex flag &#039;on&#039; for the reverse proxy. This is
     * default. off - accept_mutex flag &#039;off&#039; for the reverse
     * proxy. Turning it off will get much better distribution of client
     * connections between workers.
     *
     * <p>Valid values: [off, on]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1594)
    public Map<String,Object> unsetReverseProxyAcceptMutex(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAcceptMutex, "");
        return attrs;
    }

    /**
     * indicate whether to turn on admin console proxy
     *
     * @return zimbraReverseProxyAdminEnabled, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1321)
    public boolean isReverseProxyAdminEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyAdminEnabled, false);
    }

    /**
     * indicate whether to turn on admin console proxy
     *
     * @param zimbraReverseProxyAdminEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1321)
    public void setReverseProxyAdminEnabled(boolean zimbraReverseProxyAdminEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAdminEnabled, zimbraReverseProxyAdminEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * indicate whether to turn on admin console proxy
     *
     * @param zimbraReverseProxyAdminEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1321)
    public Map<String,Object> setReverseProxyAdminEnabled(boolean zimbraReverseProxyAdminEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAdminEnabled, zimbraReverseProxyAdminEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * indicate whether to turn on admin console proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1321)
    public void unsetReverseProxyAdminEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAdminEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * indicate whether to turn on admin console proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1321)
    public Map<String,Object> unsetReverseProxyAdminEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAdminEnabled, "");
        return attrs;
    }

    /**
     * The servers to be included in the proxy lookup handlers list. Proxy
     * will only use the servers specified here to do the lookup. Leaving
     * empty means using all the servers whose zimbraReverseProxyLookupTarget
     * is TRUE.
     *
     * @return zimbraReverseProxyAvailableLookupTargets, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1379)
    public String[] getReverseProxyAvailableLookupTargets() {
        return getMultiAttr(Provisioning.A_zimbraReverseProxyAvailableLookupTargets);
    }

    /**
     * The servers to be included in the proxy lookup handlers list. Proxy
     * will only use the servers specified here to do the lookup. Leaving
     * empty means using all the servers whose zimbraReverseProxyLookupTarget
     * is TRUE.
     *
     * @param zimbraReverseProxyAvailableLookupTargets new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1379)
    public void setReverseProxyAvailableLookupTargets(String[] zimbraReverseProxyAvailableLookupTargets) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAvailableLookupTargets, zimbraReverseProxyAvailableLookupTargets);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers to be included in the proxy lookup handlers list. Proxy
     * will only use the servers specified here to do the lookup. Leaving
     * empty means using all the servers whose zimbraReverseProxyLookupTarget
     * is TRUE.
     *
     * @param zimbraReverseProxyAvailableLookupTargets new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1379)
    public Map<String,Object> setReverseProxyAvailableLookupTargets(String[] zimbraReverseProxyAvailableLookupTargets, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAvailableLookupTargets, zimbraReverseProxyAvailableLookupTargets);
        return attrs;
    }

    /**
     * The servers to be included in the proxy lookup handlers list. Proxy
     * will only use the servers specified here to do the lookup. Leaving
     * empty means using all the servers whose zimbraReverseProxyLookupTarget
     * is TRUE.
     *
     * @param zimbraReverseProxyAvailableLookupTargets new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1379)
    public void addReverseProxyAvailableLookupTargets(String zimbraReverseProxyAvailableLookupTargets) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyAvailableLookupTargets, zimbraReverseProxyAvailableLookupTargets);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers to be included in the proxy lookup handlers list. Proxy
     * will only use the servers specified here to do the lookup. Leaving
     * empty means using all the servers whose zimbraReverseProxyLookupTarget
     * is TRUE.
     *
     * @param zimbraReverseProxyAvailableLookupTargets new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1379)
    public Map<String,Object> addReverseProxyAvailableLookupTargets(String zimbraReverseProxyAvailableLookupTargets, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyAvailableLookupTargets, zimbraReverseProxyAvailableLookupTargets);
        return attrs;
    }

    /**
     * The servers to be included in the proxy lookup handlers list. Proxy
     * will only use the servers specified here to do the lookup. Leaving
     * empty means using all the servers whose zimbraReverseProxyLookupTarget
     * is TRUE.
     *
     * @param zimbraReverseProxyAvailableLookupTargets existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1379)
    public void removeReverseProxyAvailableLookupTargets(String zimbraReverseProxyAvailableLookupTargets) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyAvailableLookupTargets, zimbraReverseProxyAvailableLookupTargets);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers to be included in the proxy lookup handlers list. Proxy
     * will only use the servers specified here to do the lookup. Leaving
     * empty means using all the servers whose zimbraReverseProxyLookupTarget
     * is TRUE.
     *
     * @param zimbraReverseProxyAvailableLookupTargets existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1379)
    public Map<String,Object> removeReverseProxyAvailableLookupTargets(String zimbraReverseProxyAvailableLookupTargets, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyAvailableLookupTargets, zimbraReverseProxyAvailableLookupTargets);
        return attrs;
    }

    /**
     * The servers to be included in the proxy lookup handlers list. Proxy
     * will only use the servers specified here to do the lookup. Leaving
     * empty means using all the servers whose zimbraReverseProxyLookupTarget
     * is TRUE.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1379)
    public void unsetReverseProxyAvailableLookupTargets() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAvailableLookupTargets, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers to be included in the proxy lookup handlers list. Proxy
     * will only use the servers specified here to do the lookup. Leaving
     * empty means using all the servers whose zimbraReverseProxyLookupTarget
     * is TRUE.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1379)
    public Map<String,Object> unsetReverseProxyAvailableLookupTargets(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAvailableLookupTargets, "");
        return attrs;
    }

    /**
     * URL prefixes that don&#039;t exist in mailboxd and need to be blocked
     * by the proxy
     *
     * @return zimbraReverseProxyBlockedURLs, or empty array if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1684)
    public String[] getReverseProxyBlockedURLs() {
        return getMultiAttr(Provisioning.A_zimbraReverseProxyBlockedURLs);
    }

    /**
     * URL prefixes that don&#039;t exist in mailboxd and need to be blocked
     * by the proxy
     *
     * @param zimbraReverseProxyBlockedURLs new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1684)
    public void setReverseProxyBlockedURLs(String[] zimbraReverseProxyBlockedURLs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyBlockedURLs, zimbraReverseProxyBlockedURLs);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL prefixes that don&#039;t exist in mailboxd and need to be blocked
     * by the proxy
     *
     * @param zimbraReverseProxyBlockedURLs new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1684)
    public Map<String,Object> setReverseProxyBlockedURLs(String[] zimbraReverseProxyBlockedURLs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyBlockedURLs, zimbraReverseProxyBlockedURLs);
        return attrs;
    }

    /**
     * URL prefixes that don&#039;t exist in mailboxd and need to be blocked
     * by the proxy
     *
     * @param zimbraReverseProxyBlockedURLs new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1684)
    public void addReverseProxyBlockedURLs(String zimbraReverseProxyBlockedURLs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyBlockedURLs, zimbraReverseProxyBlockedURLs);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL prefixes that don&#039;t exist in mailboxd and need to be blocked
     * by the proxy
     *
     * @param zimbraReverseProxyBlockedURLs new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1684)
    public Map<String,Object> addReverseProxyBlockedURLs(String zimbraReverseProxyBlockedURLs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyBlockedURLs, zimbraReverseProxyBlockedURLs);
        return attrs;
    }

    /**
     * URL prefixes that don&#039;t exist in mailboxd and need to be blocked
     * by the proxy
     *
     * @param zimbraReverseProxyBlockedURLs existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1684)
    public void removeReverseProxyBlockedURLs(String zimbraReverseProxyBlockedURLs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyBlockedURLs, zimbraReverseProxyBlockedURLs);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL prefixes that don&#039;t exist in mailboxd and need to be blocked
     * by the proxy
     *
     * @param zimbraReverseProxyBlockedURLs existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1684)
    public Map<String,Object> removeReverseProxyBlockedURLs(String zimbraReverseProxyBlockedURLs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyBlockedURLs, zimbraReverseProxyBlockedURLs);
        return attrs;
    }

    /**
     * URL prefixes that don&#039;t exist in mailboxd and need to be blocked
     * by the proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1684)
    public void unsetReverseProxyBlockedURLs() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyBlockedURLs, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL prefixes that don&#039;t exist in mailboxd and need to be blocked
     * by the proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1684)
    public Map<String,Object> unsetReverseProxyBlockedURLs(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyBlockedURLs, "");
        return attrs;
    }

    /**
     * User Agents that need to be blocked by the proxy (Case insensitive eg.
     * Firefox, chrome, SAFARI etc)
     *
     * @return zimbraReverseProxyBlockedUserAgents, or empty array if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1685)
    public String[] getReverseProxyBlockedUserAgents() {
        return getMultiAttr(Provisioning.A_zimbraReverseProxyBlockedUserAgents);
    }

    /**
     * User Agents that need to be blocked by the proxy (Case insensitive eg.
     * Firefox, chrome, SAFARI etc)
     *
     * @param zimbraReverseProxyBlockedUserAgents new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1685)
    public void setReverseProxyBlockedUserAgents(String[] zimbraReverseProxyBlockedUserAgents) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyBlockedUserAgents, zimbraReverseProxyBlockedUserAgents);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * User Agents that need to be blocked by the proxy (Case insensitive eg.
     * Firefox, chrome, SAFARI etc)
     *
     * @param zimbraReverseProxyBlockedUserAgents new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1685)
    public Map<String,Object> setReverseProxyBlockedUserAgents(String[] zimbraReverseProxyBlockedUserAgents, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyBlockedUserAgents, zimbraReverseProxyBlockedUserAgents);
        return attrs;
    }

    /**
     * User Agents that need to be blocked by the proxy (Case insensitive eg.
     * Firefox, chrome, SAFARI etc)
     *
     * @param zimbraReverseProxyBlockedUserAgents new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1685)
    public void addReverseProxyBlockedUserAgents(String zimbraReverseProxyBlockedUserAgents) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyBlockedUserAgents, zimbraReverseProxyBlockedUserAgents);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * User Agents that need to be blocked by the proxy (Case insensitive eg.
     * Firefox, chrome, SAFARI etc)
     *
     * @param zimbraReverseProxyBlockedUserAgents new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1685)
    public Map<String,Object> addReverseProxyBlockedUserAgents(String zimbraReverseProxyBlockedUserAgents, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyBlockedUserAgents, zimbraReverseProxyBlockedUserAgents);
        return attrs;
    }

    /**
     * User Agents that need to be blocked by the proxy (Case insensitive eg.
     * Firefox, chrome, SAFARI etc)
     *
     * @param zimbraReverseProxyBlockedUserAgents existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1685)
    public void removeReverseProxyBlockedUserAgents(String zimbraReverseProxyBlockedUserAgents) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyBlockedUserAgents, zimbraReverseProxyBlockedUserAgents);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * User Agents that need to be blocked by the proxy (Case insensitive eg.
     * Firefox, chrome, SAFARI etc)
     *
     * @param zimbraReverseProxyBlockedUserAgents existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1685)
    public Map<String,Object> removeReverseProxyBlockedUserAgents(String zimbraReverseProxyBlockedUserAgents, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyBlockedUserAgents, zimbraReverseProxyBlockedUserAgents);
        return attrs;
    }

    /**
     * User Agents that need to be blocked by the proxy (Case insensitive eg.
     * Firefox, chrome, SAFARI etc)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1685)
    public void unsetReverseProxyBlockedUserAgents() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyBlockedUserAgents, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * User Agents that need to be blocked by the proxy (Case insensitive eg.
     * Firefox, chrome, SAFARI etc)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1685)
    public Map<String,Object> unsetReverseProxyBlockedUserAgents(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyBlockedUserAgents, "");
        return attrs;
    }

    /**
     * CA certificate for authenticating client certificates in nginx proxy
     * (https only)
     *
     * @return zimbraReverseProxyClientCertCA, or null if unset
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1201)
    public String getReverseProxyClientCertCA() {
        return getAttr(Provisioning.A_zimbraReverseProxyClientCertCA, null);
    }

    /**
     * CA certificate for authenticating client certificates in nginx proxy
     * (https only)
     *
     * @param zimbraReverseProxyClientCertCA new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1201)
    public void setReverseProxyClientCertCA(String zimbraReverseProxyClientCertCA) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertCA, zimbraReverseProxyClientCertCA);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * CA certificate for authenticating client certificates in nginx proxy
     * (https only)
     *
     * @param zimbraReverseProxyClientCertCA new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1201)
    public Map<String,Object> setReverseProxyClientCertCA(String zimbraReverseProxyClientCertCA, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertCA, zimbraReverseProxyClientCertCA);
        return attrs;
    }

    /**
     * CA certificate for authenticating client certificates in nginx proxy
     * (https only)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1201)
    public void unsetReverseProxyClientCertCA() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertCA, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * CA certificate for authenticating client certificates in nginx proxy
     * (https only)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1201)
    public Map<String,Object> unsetReverseProxyClientCertCA(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertCA, "");
        return attrs;
    }

    /**
     * enable authentication via X.509 Client Certificate in nginx proxy
     * (https only)
     *
     * <p>Valid values: [off, optional, on]
     *
     * @return zimbraReverseProxyClientCertMode, or null if unset and/or has invalid value
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1200)
    public ZAttrProvisioning.ReverseProxyClientCertMode getReverseProxyClientCertMode() {
        try { String v = getAttr(Provisioning.A_zimbraReverseProxyClientCertMode); return v == null ? null : ZAttrProvisioning.ReverseProxyClientCertMode.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * enable authentication via X.509 Client Certificate in nginx proxy
     * (https only)
     *
     * <p>Valid values: [off, optional, on]
     *
     * @return zimbraReverseProxyClientCertMode, or null if unset
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1200)
    public String getReverseProxyClientCertModeAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyClientCertMode, null);
    }

    /**
     * enable authentication via X.509 Client Certificate in nginx proxy
     * (https only)
     *
     * <p>Valid values: [off, optional, on]
     *
     * @param zimbraReverseProxyClientCertMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1200)
    public void setReverseProxyClientCertMode(ZAttrProvisioning.ReverseProxyClientCertMode zimbraReverseProxyClientCertMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertMode, zimbraReverseProxyClientCertMode.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable authentication via X.509 Client Certificate in nginx proxy
     * (https only)
     *
     * <p>Valid values: [off, optional, on]
     *
     * @param zimbraReverseProxyClientCertMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1200)
    public Map<String,Object> setReverseProxyClientCertMode(ZAttrProvisioning.ReverseProxyClientCertMode zimbraReverseProxyClientCertMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertMode, zimbraReverseProxyClientCertMode.toString());
        return attrs;
    }

    /**
     * enable authentication via X.509 Client Certificate in nginx proxy
     * (https only)
     *
     * <p>Valid values: [off, optional, on]
     *
     * @param zimbraReverseProxyClientCertMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1200)
    public void setReverseProxyClientCertModeAsString(String zimbraReverseProxyClientCertMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertMode, zimbraReverseProxyClientCertMode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable authentication via X.509 Client Certificate in nginx proxy
     * (https only)
     *
     * <p>Valid values: [off, optional, on]
     *
     * @param zimbraReverseProxyClientCertMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1200)
    public Map<String,Object> setReverseProxyClientCertModeAsString(String zimbraReverseProxyClientCertMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertMode, zimbraReverseProxyClientCertMode);
        return attrs;
    }

    /**
     * enable authentication via X.509 Client Certificate in nginx proxy
     * (https only)
     *
     * <p>Valid values: [off, optional, on]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1200)
    public void unsetReverseProxyClientCertMode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertMode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable authentication via X.509 Client Certificate in nginx proxy
     * (https only)
     *
     * <p>Valid values: [off, optional, on]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1200)
    public Map<String,Object> unsetReverseProxyClientCertMode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertMode, "");
        return attrs;
    }

    /**
     * Time interval after which NGINX mail proxy will disconnect while
     * establishing an upstream IMAP/POP connection. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getReverseProxyConnectTimeoutAsString to access value as a string.
     *
     * @see #getReverseProxyConnectTimeoutAsString()
     *
     * @return zimbraReverseProxyConnectTimeout in millseconds, or -1 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=797)
    public long getReverseProxyConnectTimeout() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyConnectTimeout, -1L);
    }

    /**
     * Time interval after which NGINX mail proxy will disconnect while
     * establishing an upstream IMAP/POP connection. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraReverseProxyConnectTimeout, or null if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=797)
    public String getReverseProxyConnectTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyConnectTimeout, null);
    }

    /**
     * Time interval after which NGINX mail proxy will disconnect while
     * establishing an upstream IMAP/POP connection. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxyConnectTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=797)
    public void setReverseProxyConnectTimeout(String zimbraReverseProxyConnectTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyConnectTimeout, zimbraReverseProxyConnectTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time interval after which NGINX mail proxy will disconnect while
     * establishing an upstream IMAP/POP connection. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxyConnectTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=797)
    public Map<String,Object> setReverseProxyConnectTimeout(String zimbraReverseProxyConnectTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyConnectTimeout, zimbraReverseProxyConnectTimeout);
        return attrs;
    }

    /**
     * Time interval after which NGINX mail proxy will disconnect while
     * establishing an upstream IMAP/POP connection. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=797)
    public void unsetReverseProxyConnectTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyConnectTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time interval after which NGINX mail proxy will disconnect while
     * establishing an upstream IMAP/POP connection. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=797)
    public Map<String,Object> unsetReverseProxyConnectTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyConnectTimeout, "");
        return attrs;
    }

    /**
     * The default realm that will be used by NGINX mail proxy, when the
     * realm is not specified in GSSAPI Authentication
     *
     * @return zimbraReverseProxyDefaultRealm, or null if unset
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=703)
    public String getReverseProxyDefaultRealm() {
        return getAttr(Provisioning.A_zimbraReverseProxyDefaultRealm, null);
    }

    /**
     * The default realm that will be used by NGINX mail proxy, when the
     * realm is not specified in GSSAPI Authentication
     *
     * @param zimbraReverseProxyDefaultRealm new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=703)
    public void setReverseProxyDefaultRealm(String zimbraReverseProxyDefaultRealm) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDefaultRealm, zimbraReverseProxyDefaultRealm);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The default realm that will be used by NGINX mail proxy, when the
     * realm is not specified in GSSAPI Authentication
     *
     * @param zimbraReverseProxyDefaultRealm new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=703)
    public Map<String,Object> setReverseProxyDefaultRealm(String zimbraReverseProxyDefaultRealm, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDefaultRealm, zimbraReverseProxyDefaultRealm);
        return attrs;
    }

    /**
     * The default realm that will be used by NGINX mail proxy, when the
     * realm is not specified in GSSAPI Authentication
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=703)
    public void unsetReverseProxyDefaultRealm() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDefaultRealm, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The default realm that will be used by NGINX mail proxy, when the
     * realm is not specified in GSSAPI Authentication
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=703)
    public Map<String,Object> unsetReverseProxyDefaultRealm(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDefaultRealm, "");
        return attrs;
    }

    /**
     * Control whether force the server side do the DNS lookup and send the
     * result IP back to proxy. If set false, the raw address configured
     * (e.g. zimbraMailHost) is directly sent to proxy.
     *
     * @return zimbraReverseProxyDnsLookupInServerEnabled, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1384)
    public boolean isReverseProxyDnsLookupInServerEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyDnsLookupInServerEnabled, false);
    }

    /**
     * Control whether force the server side do the DNS lookup and send the
     * result IP back to proxy. If set false, the raw address configured
     * (e.g. zimbraMailHost) is directly sent to proxy.
     *
     * @param zimbraReverseProxyDnsLookupInServerEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1384)
    public void setReverseProxyDnsLookupInServerEnabled(boolean zimbraReverseProxyDnsLookupInServerEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDnsLookupInServerEnabled, zimbraReverseProxyDnsLookupInServerEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Control whether force the server side do the DNS lookup and send the
     * result IP back to proxy. If set false, the raw address configured
     * (e.g. zimbraMailHost) is directly sent to proxy.
     *
     * @param zimbraReverseProxyDnsLookupInServerEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1384)
    public Map<String,Object> setReverseProxyDnsLookupInServerEnabled(boolean zimbraReverseProxyDnsLookupInServerEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDnsLookupInServerEnabled, zimbraReverseProxyDnsLookupInServerEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Control whether force the server side do the DNS lookup and send the
     * result IP back to proxy. If set false, the raw address configured
     * (e.g. zimbraMailHost) is directly sent to proxy.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1384)
    public void unsetReverseProxyDnsLookupInServerEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDnsLookupInServerEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Control whether force the server side do the DNS lookup and send the
     * result IP back to proxy. If set false, the raw address configured
     * (e.g. zimbraMailHost) is directly sent to proxy.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1384)
    public Map<String,Object> unsetReverseProxyDnsLookupInServerEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDnsLookupInServerEnabled, "");
        return attrs;
    }

    /**
     * Whether nginx will match exact server version against the version
     * received in the client request (in ZM_AUTH_TOKEN). Defaults to on.
     * Setting this to off will make nginx compare only the major and minor
     * server versions (eg. all 8.5.x will be treated same by nginx)
     *
     * <p>Valid values: [off, on]
     *
     * @return zimbraReverseProxyExactServerVersionCheck, or null if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1616)
    public ZAttrProvisioning.ReverseProxyExactServerVersionCheck getReverseProxyExactServerVersionCheck() {
        try { String v = getAttr(Provisioning.A_zimbraReverseProxyExactServerVersionCheck); return v == null ? null : ZAttrProvisioning.ReverseProxyExactServerVersionCheck.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Whether nginx will match exact server version against the version
     * received in the client request (in ZM_AUTH_TOKEN). Defaults to on.
     * Setting this to off will make nginx compare only the major and minor
     * server versions (eg. all 8.5.x will be treated same by nginx)
     *
     * <p>Valid values: [off, on]
     *
     * @return zimbraReverseProxyExactServerVersionCheck, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1616)
    public String getReverseProxyExactServerVersionCheckAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyExactServerVersionCheck, null);
    }

    /**
     * Whether nginx will match exact server version against the version
     * received in the client request (in ZM_AUTH_TOKEN). Defaults to on.
     * Setting this to off will make nginx compare only the major and minor
     * server versions (eg. all 8.5.x will be treated same by nginx)
     *
     * <p>Valid values: [off, on]
     *
     * @param zimbraReverseProxyExactServerVersionCheck new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1616)
    public void setReverseProxyExactServerVersionCheck(ZAttrProvisioning.ReverseProxyExactServerVersionCheck zimbraReverseProxyExactServerVersionCheck) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyExactServerVersionCheck, zimbraReverseProxyExactServerVersionCheck.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether nginx will match exact server version against the version
     * received in the client request (in ZM_AUTH_TOKEN). Defaults to on.
     * Setting this to off will make nginx compare only the major and minor
     * server versions (eg. all 8.5.x will be treated same by nginx)
     *
     * <p>Valid values: [off, on]
     *
     * @param zimbraReverseProxyExactServerVersionCheck new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1616)
    public Map<String,Object> setReverseProxyExactServerVersionCheck(ZAttrProvisioning.ReverseProxyExactServerVersionCheck zimbraReverseProxyExactServerVersionCheck, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyExactServerVersionCheck, zimbraReverseProxyExactServerVersionCheck.toString());
        return attrs;
    }

    /**
     * Whether nginx will match exact server version against the version
     * received in the client request (in ZM_AUTH_TOKEN). Defaults to on.
     * Setting this to off will make nginx compare only the major and minor
     * server versions (eg. all 8.5.x will be treated same by nginx)
     *
     * <p>Valid values: [off, on]
     *
     * @param zimbraReverseProxyExactServerVersionCheck new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1616)
    public void setReverseProxyExactServerVersionCheckAsString(String zimbraReverseProxyExactServerVersionCheck) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyExactServerVersionCheck, zimbraReverseProxyExactServerVersionCheck);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether nginx will match exact server version against the version
     * received in the client request (in ZM_AUTH_TOKEN). Defaults to on.
     * Setting this to off will make nginx compare only the major and minor
     * server versions (eg. all 8.5.x will be treated same by nginx)
     *
     * <p>Valid values: [off, on]
     *
     * @param zimbraReverseProxyExactServerVersionCheck new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1616)
    public Map<String,Object> setReverseProxyExactServerVersionCheckAsString(String zimbraReverseProxyExactServerVersionCheck, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyExactServerVersionCheck, zimbraReverseProxyExactServerVersionCheck);
        return attrs;
    }

    /**
     * Whether nginx will match exact server version against the version
     * received in the client request (in ZM_AUTH_TOKEN). Defaults to on.
     * Setting this to off will make nginx compare only the major and minor
     * server versions (eg. all 8.5.x will be treated same by nginx)
     *
     * <p>Valid values: [off, on]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1616)
    public void unsetReverseProxyExactServerVersionCheck() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyExactServerVersionCheck, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether nginx will match exact server version against the version
     * received in the client request (in ZM_AUTH_TOKEN). Defaults to on.
     * Setting this to off will make nginx compare only the major and minor
     * server versions (eg. all 8.5.x will be treated same by nginx)
     *
     * <p>Valid values: [off, on]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1616)
    public Map<String,Object> unsetReverseProxyExactServerVersionCheck(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyExactServerVersionCheck, "");
        return attrs;
    }

    /**
     * Control whether to generate per virtual hostname nginx configuration.
     * This would be helpful when multiple virtual host names are defined,
     * but they are actually share the same configuration (like ssl cert,
     * client CA, ...). This attr has to be set as &quot;TRUE&quot; to enable
     * the features like cert per domain.
     *
     * @return zimbraReverseProxyGenConfigPerVirtualHostname, or false if unset
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1374)
    public boolean isReverseProxyGenConfigPerVirtualHostname() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyGenConfigPerVirtualHostname, false);
    }

    /**
     * Control whether to generate per virtual hostname nginx configuration.
     * This would be helpful when multiple virtual host names are defined,
     * but they are actually share the same configuration (like ssl cert,
     * client CA, ...). This attr has to be set as &quot;TRUE&quot; to enable
     * the features like cert per domain.
     *
     * @param zimbraReverseProxyGenConfigPerVirtualHostname new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1374)
    public void setReverseProxyGenConfigPerVirtualHostname(boolean zimbraReverseProxyGenConfigPerVirtualHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyGenConfigPerVirtualHostname, zimbraReverseProxyGenConfigPerVirtualHostname ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Control whether to generate per virtual hostname nginx configuration.
     * This would be helpful when multiple virtual host names are defined,
     * but they are actually share the same configuration (like ssl cert,
     * client CA, ...). This attr has to be set as &quot;TRUE&quot; to enable
     * the features like cert per domain.
     *
     * @param zimbraReverseProxyGenConfigPerVirtualHostname new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1374)
    public Map<String,Object> setReverseProxyGenConfigPerVirtualHostname(boolean zimbraReverseProxyGenConfigPerVirtualHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyGenConfigPerVirtualHostname, zimbraReverseProxyGenConfigPerVirtualHostname ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Control whether to generate per virtual hostname nginx configuration.
     * This would be helpful when multiple virtual host names are defined,
     * but they are actually share the same configuration (like ssl cert,
     * client CA, ...). This attr has to be set as &quot;TRUE&quot; to enable
     * the features like cert per domain.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1374)
    public void unsetReverseProxyGenConfigPerVirtualHostname() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyGenConfigPerVirtualHostname, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Control whether to generate per virtual hostname nginx configuration.
     * This would be helpful when multiple virtual host names are defined,
     * but they are actually share the same configuration (like ssl cert,
     * client CA, ...). This attr has to be set as &quot;TRUE&quot; to enable
     * the features like cert per domain.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1374)
    public Map<String,Object> unsetReverseProxyGenConfigPerVirtualHostname(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyGenConfigPerVirtualHostname, "");
        return attrs;
    }

    /**
     * NGINX reverse proxy imap capabilities
     *
     * @return zimbraReverseProxyImapEnabledCapability, or empty array if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=719)
    public String[] getReverseProxyImapEnabledCapability() {
        return getMultiAttr(Provisioning.A_zimbraReverseProxyImapEnabledCapability);
    }

    /**
     * NGINX reverse proxy imap capabilities
     *
     * @param zimbraReverseProxyImapEnabledCapability new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=719)
    public void setReverseProxyImapEnabledCapability(String[] zimbraReverseProxyImapEnabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapEnabledCapability, zimbraReverseProxyImapEnabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * NGINX reverse proxy imap capabilities
     *
     * @param zimbraReverseProxyImapEnabledCapability new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=719)
    public Map<String,Object> setReverseProxyImapEnabledCapability(String[] zimbraReverseProxyImapEnabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapEnabledCapability, zimbraReverseProxyImapEnabledCapability);
        return attrs;
    }

    /**
     * NGINX reverse proxy imap capabilities
     *
     * @param zimbraReverseProxyImapEnabledCapability new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=719)
    public void addReverseProxyImapEnabledCapability(String zimbraReverseProxyImapEnabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyImapEnabledCapability, zimbraReverseProxyImapEnabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * NGINX reverse proxy imap capabilities
     *
     * @param zimbraReverseProxyImapEnabledCapability new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=719)
    public Map<String,Object> addReverseProxyImapEnabledCapability(String zimbraReverseProxyImapEnabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyImapEnabledCapability, zimbraReverseProxyImapEnabledCapability);
        return attrs;
    }

    /**
     * NGINX reverse proxy imap capabilities
     *
     * @param zimbraReverseProxyImapEnabledCapability existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=719)
    public void removeReverseProxyImapEnabledCapability(String zimbraReverseProxyImapEnabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyImapEnabledCapability, zimbraReverseProxyImapEnabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * NGINX reverse proxy imap capabilities
     *
     * @param zimbraReverseProxyImapEnabledCapability existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=719)
    public Map<String,Object> removeReverseProxyImapEnabledCapability(String zimbraReverseProxyImapEnabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyImapEnabledCapability, zimbraReverseProxyImapEnabledCapability);
        return attrs;
    }

    /**
     * NGINX reverse proxy imap capabilities
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=719)
    public void unsetReverseProxyImapEnabledCapability() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapEnabledCapability, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * NGINX reverse proxy imap capabilities
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=719)
    public Map<String,Object> unsetReverseProxyImapEnabledCapability(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapEnabledCapability, "");
        return attrs;
    }

    /**
     * whether IMAP SASL PLAIN is enabled for reverse proxy
     *
     * @return zimbraReverseProxyImapSaslPlainEnabled, or false if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=728)
    public boolean isReverseProxyImapSaslPlainEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyImapSaslPlainEnabled, false);
    }

    /**
     * whether IMAP SASL PLAIN is enabled for reverse proxy
     *
     * @param zimbraReverseProxyImapSaslPlainEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=728)
    public void setReverseProxyImapSaslPlainEnabled(boolean zimbraReverseProxyImapSaslPlainEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapSaslPlainEnabled, zimbraReverseProxyImapSaslPlainEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether IMAP SASL PLAIN is enabled for reverse proxy
     *
     * @param zimbraReverseProxyImapSaslPlainEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=728)
    public Map<String,Object> setReverseProxyImapSaslPlainEnabled(boolean zimbraReverseProxyImapSaslPlainEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapSaslPlainEnabled, zimbraReverseProxyImapSaslPlainEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * whether IMAP SASL PLAIN is enabled for reverse proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=728)
    public void unsetReverseProxyImapSaslPlainEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapSaslPlainEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether IMAP SASL PLAIN is enabled for reverse proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=728)
    public Map<String,Object> unsetReverseProxyImapSaslPlainEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapSaslPlainEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. deprecated in favor of local config
     * &quot;imap_max_idle_time&quot;, &quot;pop3_max_idle_time&quot;,
     * &quot;imap_authenticated_max_idle_time&quot; in bug 59685. Orig desc:
     * Time interval after which NGINX mail proxy will disconnect an inactive
     * IMAP/POP connection. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getReverseProxyInactivityTimeoutAsString to access value as a string.
     *
     * @see #getReverseProxyInactivityTimeoutAsString()
     *
     * @return zimbraReverseProxyInactivityTimeout in millseconds, or -1 if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=735)
    public long getReverseProxyInactivityTimeout() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyInactivityTimeout, -1L);
    }

    /**
     * Deprecated since: 8.0.0. deprecated in favor of local config
     * &quot;imap_max_idle_time&quot;, &quot;pop3_max_idle_time&quot;,
     * &quot;imap_authenticated_max_idle_time&quot; in bug 59685. Orig desc:
     * Time interval after which NGINX mail proxy will disconnect an inactive
     * IMAP/POP connection. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraReverseProxyInactivityTimeout, or null if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=735)
    public String getReverseProxyInactivityTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyInactivityTimeout, null);
    }

    /**
     * Deprecated since: 8.0.0. deprecated in favor of local config
     * &quot;imap_max_idle_time&quot;, &quot;pop3_max_idle_time&quot;,
     * &quot;imap_authenticated_max_idle_time&quot; in bug 59685. Orig desc:
     * Time interval after which NGINX mail proxy will disconnect an inactive
     * IMAP/POP connection. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyInactivityTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=735)
    public void setReverseProxyInactivityTimeout(String zimbraReverseProxyInactivityTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyInactivityTimeout, zimbraReverseProxyInactivityTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. deprecated in favor of local config
     * &quot;imap_max_idle_time&quot;, &quot;pop3_max_idle_time&quot;,
     * &quot;imap_authenticated_max_idle_time&quot; in bug 59685. Orig desc:
     * Time interval after which NGINX mail proxy will disconnect an inactive
     * IMAP/POP connection. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyInactivityTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=735)
    public Map<String,Object> setReverseProxyInactivityTimeout(String zimbraReverseProxyInactivityTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyInactivityTimeout, zimbraReverseProxyInactivityTimeout);
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. deprecated in favor of local config
     * &quot;imap_max_idle_time&quot;, &quot;pop3_max_idle_time&quot;,
     * &quot;imap_authenticated_max_idle_time&quot; in bug 59685. Orig desc:
     * Time interval after which NGINX mail proxy will disconnect an inactive
     * IMAP/POP connection. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=735)
    public void unsetReverseProxyInactivityTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyInactivityTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. deprecated in favor of local config
     * &quot;imap_max_idle_time&quot;, &quot;pop3_max_idle_time&quot;,
     * &quot;imap_authenticated_max_idle_time&quot; in bug 59685. Orig desc:
     * Time interval after which NGINX mail proxy will disconnect an inactive
     * IMAP/POP connection. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=735)
    public Map<String,Object> unsetReverseProxyInactivityTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyInactivityTimeout, "");
        return attrs;
    }

    /**
     * Maximum rate in requests per second to be enforced by the proxy for a
     * particualr zone. Requests in excess of this are throttled.
     *
     * @return zimbraReverseProxyLimitReqZoneRate, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1681)
    public int getReverseProxyLimitReqZoneRate() {
        return getIntAttr(Provisioning.A_zimbraReverseProxyLimitReqZoneRate, -1);
    }

    /**
     * Maximum rate in requests per second to be enforced by the proxy for a
     * particualr zone. Requests in excess of this are throttled.
     *
     * @param zimbraReverseProxyLimitReqZoneRate new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1681)
    public void setReverseProxyLimitReqZoneRate(int zimbraReverseProxyLimitReqZoneRate) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLimitReqZoneRate, Integer.toString(zimbraReverseProxyLimitReqZoneRate));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum rate in requests per second to be enforced by the proxy for a
     * particualr zone. Requests in excess of this are throttled.
     *
     * @param zimbraReverseProxyLimitReqZoneRate new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1681)
    public Map<String,Object> setReverseProxyLimitReqZoneRate(int zimbraReverseProxyLimitReqZoneRate, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLimitReqZoneRate, Integer.toString(zimbraReverseProxyLimitReqZoneRate));
        return attrs;
    }

    /**
     * Maximum rate in requests per second to be enforced by the proxy for a
     * particualr zone. Requests in excess of this are throttled.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1681)
    public void unsetReverseProxyLimitReqZoneRate() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLimitReqZoneRate, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum rate in requests per second to be enforced by the proxy for a
     * particualr zone. Requests in excess of this are throttled.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1681)
    public Map<String,Object> unsetReverseProxyLimitReqZoneRate(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLimitReqZoneRate, "");
        return attrs;
    }

    /**
     * Shared memory zone size in megabytes used by ngx_http_limit_req_module
     * to store the current number of excessive requests per client IP
     *
     * @return zimbraReverseProxyLimitReqZoneSize, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1682)
    public String getReverseProxyLimitReqZoneSize() {
        return getAttr(Provisioning.A_zimbraReverseProxyLimitReqZoneSize, null);
    }

    /**
     * Shared memory zone size in megabytes used by ngx_http_limit_req_module
     * to store the current number of excessive requests per client IP
     *
     * @param zimbraReverseProxyLimitReqZoneSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1682)
    public void setReverseProxyLimitReqZoneSize(String zimbraReverseProxyLimitReqZoneSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLimitReqZoneSize, zimbraReverseProxyLimitReqZoneSize);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Shared memory zone size in megabytes used by ngx_http_limit_req_module
     * to store the current number of excessive requests per client IP
     *
     * @param zimbraReverseProxyLimitReqZoneSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1682)
    public Map<String,Object> setReverseProxyLimitReqZoneSize(String zimbraReverseProxyLimitReqZoneSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLimitReqZoneSize, zimbraReverseProxyLimitReqZoneSize);
        return attrs;
    }

    /**
     * Shared memory zone size in megabytes used by ngx_http_limit_req_module
     * to store the current number of excessive requests per client IP
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1682)
    public void unsetReverseProxyLimitReqZoneSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLimitReqZoneSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Shared memory zone size in megabytes used by ngx_http_limit_req_module
     * to store the current number of excessive requests per client IP
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1682)
    public Map<String,Object> unsetReverseProxyLimitReqZoneSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLimitReqZoneSize, "");
        return attrs;
    }

    /**
     * Log level for NGINX Proxy error log
     *
     * <p>Valid values: [warn, debug, debug_core, crit, debug_zimbra, error, debug_mail, info, notice, debug_http]
     *
     * @return zimbraReverseProxyLogLevel, or null if unset and/or has invalid value
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=723)
    public ZAttrProvisioning.ReverseProxyLogLevel getReverseProxyLogLevel() {
        try { String v = getAttr(Provisioning.A_zimbraReverseProxyLogLevel); return v == null ? null : ZAttrProvisioning.ReverseProxyLogLevel.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Log level for NGINX Proxy error log
     *
     * <p>Valid values: [warn, debug, debug_core, crit, debug_zimbra, error, debug_mail, info, notice, debug_http]
     *
     * @return zimbraReverseProxyLogLevel, or null if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=723)
    public String getReverseProxyLogLevelAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyLogLevel, null);
    }

    /**
     * Log level for NGINX Proxy error log
     *
     * <p>Valid values: [warn, debug, debug_core, crit, debug_zimbra, error, debug_mail, info, notice, debug_http]
     *
     * @param zimbraReverseProxyLogLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=723)
    public void setReverseProxyLogLevel(ZAttrProvisioning.ReverseProxyLogLevel zimbraReverseProxyLogLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLogLevel, zimbraReverseProxyLogLevel.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Log level for NGINX Proxy error log
     *
     * <p>Valid values: [warn, debug, debug_core, crit, debug_zimbra, error, debug_mail, info, notice, debug_http]
     *
     * @param zimbraReverseProxyLogLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=723)
    public Map<String,Object> setReverseProxyLogLevel(ZAttrProvisioning.ReverseProxyLogLevel zimbraReverseProxyLogLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLogLevel, zimbraReverseProxyLogLevel.toString());
        return attrs;
    }

    /**
     * Log level for NGINX Proxy error log
     *
     * <p>Valid values: [warn, debug, debug_core, crit, debug_zimbra, error, debug_mail, info, notice, debug_http]
     *
     * @param zimbraReverseProxyLogLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=723)
    public void setReverseProxyLogLevelAsString(String zimbraReverseProxyLogLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLogLevel, zimbraReverseProxyLogLevel);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Log level for NGINX Proxy error log
     *
     * <p>Valid values: [warn, debug, debug_core, crit, debug_zimbra, error, debug_mail, info, notice, debug_http]
     *
     * @param zimbraReverseProxyLogLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=723)
    public Map<String,Object> setReverseProxyLogLevelAsString(String zimbraReverseProxyLogLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLogLevel, zimbraReverseProxyLogLevel);
        return attrs;
    }

    /**
     * Log level for NGINX Proxy error log
     *
     * <p>Valid values: [warn, debug, debug_core, crit, debug_zimbra, error, debug_mail, info, notice, debug_http]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=723)
    public void unsetReverseProxyLogLevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLogLevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Log level for NGINX Proxy error log
     *
     * <p>Valid values: [warn, debug, debug_core, crit, debug_zimbra, error, debug_mail, info, notice, debug_http]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=723)
    public Map<String,Object> unsetReverseProxyLogLevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLogLevel, "");
        return attrs;
    }

    /**
     * whether nginx proxy should log to syslog
     *
     * @return zimbraReverseProxyLogToSyslog, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1649)
    public boolean isReverseProxyLogToSyslog() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyLogToSyslog, false);
    }

    /**
     * whether nginx proxy should log to syslog
     *
     * @param zimbraReverseProxyLogToSyslog new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1649)
    public void setReverseProxyLogToSyslog(boolean zimbraReverseProxyLogToSyslog) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLogToSyslog, zimbraReverseProxyLogToSyslog ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether nginx proxy should log to syslog
     *
     * @param zimbraReverseProxyLogToSyslog new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1649)
    public Map<String,Object> setReverseProxyLogToSyslog(boolean zimbraReverseProxyLogToSyslog, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLogToSyslog, zimbraReverseProxyLogToSyslog ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * whether nginx proxy should log to syslog
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1649)
    public void unsetReverseProxyLogToSyslog() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLogToSyslog, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether nginx proxy should log to syslog
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1649)
    public Map<String,Object> unsetReverseProxyLogToSyslog(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLogToSyslog, "");
        return attrs;
    }

    /**
     * whether this server is a valid upstream and needs to be included in
     * the upstream config of the reverse proxy
     *
     * @return zimbraReverseProxyLookupTarget, or false if unset
     */
    @ZAttr(id=504)
    public boolean isReverseProxyLookupTarget() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyLookupTarget, false);
    }

    /**
     * whether this server is a valid upstream and needs to be included in
     * the upstream config of the reverse proxy
     *
     * @param zimbraReverseProxyLookupTarget new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=504)
    public void setReverseProxyLookupTarget(boolean zimbraReverseProxyLookupTarget) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLookupTarget, zimbraReverseProxyLookupTarget ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether this server is a valid upstream and needs to be included in
     * the upstream config of the reverse proxy
     *
     * @param zimbraReverseProxyLookupTarget new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=504)
    public Map<String,Object> setReverseProxyLookupTarget(boolean zimbraReverseProxyLookupTarget, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLookupTarget, zimbraReverseProxyLookupTarget ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * whether this server is a valid upstream and needs to be included in
     * the upstream config of the reverse proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=504)
    public void unsetReverseProxyLookupTarget() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLookupTarget, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether this server is a valid upstream and needs to be included in
     * the upstream config of the reverse proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=504)
    public Map<String,Object> unsetReverseProxyLookupTarget(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLookupTarget, "");
        return attrs;
    }

    /**
     * Whether to enable IMAP proxy
     *
     * @return zimbraReverseProxyMailImapEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1621)
    public boolean isReverseProxyMailImapEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyMailImapEnabled, false);
    }

    /**
     * Whether to enable IMAP proxy
     *
     * @param zimbraReverseProxyMailImapEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1621)
    public void setReverseProxyMailImapEnabled(boolean zimbraReverseProxyMailImapEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailImapEnabled, zimbraReverseProxyMailImapEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable IMAP proxy
     *
     * @param zimbraReverseProxyMailImapEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1621)
    public Map<String,Object> setReverseProxyMailImapEnabled(boolean zimbraReverseProxyMailImapEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailImapEnabled, zimbraReverseProxyMailImapEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether to enable IMAP proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1621)
    public void unsetReverseProxyMailImapEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailImapEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable IMAP proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1621)
    public Map<String,Object> unsetReverseProxyMailImapEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailImapEnabled, "");
        return attrs;
    }

    /**
     * Whether to enable IMAPs proxy
     *
     * @return zimbraReverseProxyMailImapsEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1622)
    public boolean isReverseProxyMailImapsEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyMailImapsEnabled, false);
    }

    /**
     * Whether to enable IMAPs proxy
     *
     * @param zimbraReverseProxyMailImapsEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1622)
    public void setReverseProxyMailImapsEnabled(boolean zimbraReverseProxyMailImapsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailImapsEnabled, zimbraReverseProxyMailImapsEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable IMAPs proxy
     *
     * @param zimbraReverseProxyMailImapsEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1622)
    public Map<String,Object> setReverseProxyMailImapsEnabled(boolean zimbraReverseProxyMailImapsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailImapsEnabled, zimbraReverseProxyMailImapsEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether to enable IMAPs proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1622)
    public void unsetReverseProxyMailImapsEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailImapsEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable IMAPs proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1622)
    public Map<String,Object> unsetReverseProxyMailImapsEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailImapsEnabled, "");
        return attrs;
    }

    /**
     * whether to run proxy in HTTP, HTTPS, both, mixed, or redirect mode.
     * See also related attributes zimbraMailProxyPort and
     * zimbraMailSSLProxyPort
     *
     * <p>Valid values: [redirect, http, mixed, https, both]
     *
     * @return zimbraReverseProxyMailMode, or null if unset and/or has invalid value
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=685)
    public ZAttrProvisioning.ReverseProxyMailMode getReverseProxyMailMode() {
        try { String v = getAttr(Provisioning.A_zimbraReverseProxyMailMode); return v == null ? null : ZAttrProvisioning.ReverseProxyMailMode.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * whether to run proxy in HTTP, HTTPS, both, mixed, or redirect mode.
     * See also related attributes zimbraMailProxyPort and
     * zimbraMailSSLProxyPort
     *
     * <p>Valid values: [redirect, http, mixed, https, both]
     *
     * @return zimbraReverseProxyMailMode, or null if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=685)
    public String getReverseProxyMailModeAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyMailMode, null);
    }

    /**
     * whether to run proxy in HTTP, HTTPS, both, mixed, or redirect mode.
     * See also related attributes zimbraMailProxyPort and
     * zimbraMailSSLProxyPort
     *
     * <p>Valid values: [redirect, http, mixed, https, both]
     *
     * @param zimbraReverseProxyMailMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=685)
    public void setReverseProxyMailMode(ZAttrProvisioning.ReverseProxyMailMode zimbraReverseProxyMailMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailMode, zimbraReverseProxyMailMode.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to run proxy in HTTP, HTTPS, both, mixed, or redirect mode.
     * See also related attributes zimbraMailProxyPort and
     * zimbraMailSSLProxyPort
     *
     * <p>Valid values: [redirect, http, mixed, https, both]
     *
     * @param zimbraReverseProxyMailMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=685)
    public Map<String,Object> setReverseProxyMailMode(ZAttrProvisioning.ReverseProxyMailMode zimbraReverseProxyMailMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailMode, zimbraReverseProxyMailMode.toString());
        return attrs;
    }

    /**
     * whether to run proxy in HTTP, HTTPS, both, mixed, or redirect mode.
     * See also related attributes zimbraMailProxyPort and
     * zimbraMailSSLProxyPort
     *
     * <p>Valid values: [redirect, http, mixed, https, both]
     *
     * @param zimbraReverseProxyMailMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=685)
    public void setReverseProxyMailModeAsString(String zimbraReverseProxyMailMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailMode, zimbraReverseProxyMailMode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to run proxy in HTTP, HTTPS, both, mixed, or redirect mode.
     * See also related attributes zimbraMailProxyPort and
     * zimbraMailSSLProxyPort
     *
     * <p>Valid values: [redirect, http, mixed, https, both]
     *
     * @param zimbraReverseProxyMailMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=685)
    public Map<String,Object> setReverseProxyMailModeAsString(String zimbraReverseProxyMailMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailMode, zimbraReverseProxyMailMode);
        return attrs;
    }

    /**
     * whether to run proxy in HTTP, HTTPS, both, mixed, or redirect mode.
     * See also related attributes zimbraMailProxyPort and
     * zimbraMailSSLProxyPort
     *
     * <p>Valid values: [redirect, http, mixed, https, both]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=685)
    public void unsetReverseProxyMailMode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailMode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to run proxy in HTTP, HTTPS, both, mixed, or redirect mode.
     * See also related attributes zimbraMailProxyPort and
     * zimbraMailSSLProxyPort
     *
     * <p>Valid values: [redirect, http, mixed, https, both]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=685)
    public Map<String,Object> unsetReverseProxyMailMode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailMode, "");
        return attrs;
    }

    /**
     * on - ModSecurity for nginx enabled off - ModSecurity for nginx
     * disabled
     *
     * <p>Valid values: [off, on]
     *
     * @return zimbraReverseProxyModSecurityEnabled, or null if unset and/or has invalid value
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1671)
    public ZAttrProvisioning.ReverseProxyModSecurityEnabled getReverseProxyModSecurityEnabled() {
        try { String v = getAttr(Provisioning.A_zimbraReverseProxyModSecurityEnabled); return v == null ? null : ZAttrProvisioning.ReverseProxyModSecurityEnabled.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * on - ModSecurity for nginx enabled off - ModSecurity for nginx
     * disabled
     *
     * <p>Valid values: [off, on]
     *
     * @return zimbraReverseProxyModSecurityEnabled, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1671)
    public String getReverseProxyModSecurityEnabledAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyModSecurityEnabled, null);
    }

    /**
     * on - ModSecurity for nginx enabled off - ModSecurity for nginx
     * disabled
     *
     * <p>Valid values: [off, on]
     *
     * @param zimbraReverseProxyModSecurityEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1671)
    public void setReverseProxyModSecurityEnabled(ZAttrProvisioning.ReverseProxyModSecurityEnabled zimbraReverseProxyModSecurityEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyModSecurityEnabled, zimbraReverseProxyModSecurityEnabled.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * on - ModSecurity for nginx enabled off - ModSecurity for nginx
     * disabled
     *
     * <p>Valid values: [off, on]
     *
     * @param zimbraReverseProxyModSecurityEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1671)
    public Map<String,Object> setReverseProxyModSecurityEnabled(ZAttrProvisioning.ReverseProxyModSecurityEnabled zimbraReverseProxyModSecurityEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyModSecurityEnabled, zimbraReverseProxyModSecurityEnabled.toString());
        return attrs;
    }

    /**
     * on - ModSecurity for nginx enabled off - ModSecurity for nginx
     * disabled
     *
     * <p>Valid values: [off, on]
     *
     * @param zimbraReverseProxyModSecurityEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1671)
    public void setReverseProxyModSecurityEnabledAsString(String zimbraReverseProxyModSecurityEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyModSecurityEnabled, zimbraReverseProxyModSecurityEnabled);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * on - ModSecurity for nginx enabled off - ModSecurity for nginx
     * disabled
     *
     * <p>Valid values: [off, on]
     *
     * @param zimbraReverseProxyModSecurityEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1671)
    public Map<String,Object> setReverseProxyModSecurityEnabledAsString(String zimbraReverseProxyModSecurityEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyModSecurityEnabled, zimbraReverseProxyModSecurityEnabled);
        return attrs;
    }

    /**
     * on - ModSecurity for nginx enabled off - ModSecurity for nginx
     * disabled
     *
     * <p>Valid values: [off, on]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1671)
    public void unsetReverseProxyModSecurityEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyModSecurityEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * on - ModSecurity for nginx enabled off - ModSecurity for nginx
     * disabled
     *
     * <p>Valid values: [off, on]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1671)
    public Map<String,Object> unsetReverseProxyModSecurityEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyModSecurityEnabled, "");
        return attrs;
    }

    /**
     * whether NGINX mail proxy will pass upstream server errors back to the
     * downstream email clients
     *
     * @return zimbraReverseProxyPassErrors, or false if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=736)
    public boolean isReverseProxyPassErrors() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyPassErrors, false);
    }

    /**
     * whether NGINX mail proxy will pass upstream server errors back to the
     * downstream email clients
     *
     * @param zimbraReverseProxyPassErrors new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=736)
    public void setReverseProxyPassErrors(boolean zimbraReverseProxyPassErrors) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPassErrors, zimbraReverseProxyPassErrors ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether NGINX mail proxy will pass upstream server errors back to the
     * downstream email clients
     *
     * @param zimbraReverseProxyPassErrors new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=736)
    public Map<String,Object> setReverseProxyPassErrors(boolean zimbraReverseProxyPassErrors, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPassErrors, zimbraReverseProxyPassErrors ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * whether NGINX mail proxy will pass upstream server errors back to the
     * downstream email clients
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=736)
    public void unsetReverseProxyPassErrors() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPassErrors, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether NGINX mail proxy will pass upstream server errors back to the
     * downstream email clients
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=736)
    public Map<String,Object> unsetReverseProxyPassErrors(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPassErrors, "");
        return attrs;
    }

    /**
     * Client network or IP address to be denied access by the proxy
     *
     * @return zimbraReverseProxyRestrictedIPs, or empty array if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1683)
    public String[] getReverseProxyRestrictedIPs() {
        return getMultiAttr(Provisioning.A_zimbraReverseProxyRestrictedIPs);
    }

    /**
     * Client network or IP address to be denied access by the proxy
     *
     * @param zimbraReverseProxyRestrictedIPs new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1683)
    public void setReverseProxyRestrictedIPs(String[] zimbraReverseProxyRestrictedIPs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRestrictedIPs, zimbraReverseProxyRestrictedIPs);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Client network or IP address to be denied access by the proxy
     *
     * @param zimbraReverseProxyRestrictedIPs new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1683)
    public Map<String,Object> setReverseProxyRestrictedIPs(String[] zimbraReverseProxyRestrictedIPs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRestrictedIPs, zimbraReverseProxyRestrictedIPs);
        return attrs;
    }

    /**
     * Client network or IP address to be denied access by the proxy
     *
     * @param zimbraReverseProxyRestrictedIPs new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1683)
    public void addReverseProxyRestrictedIPs(String zimbraReverseProxyRestrictedIPs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyRestrictedIPs, zimbraReverseProxyRestrictedIPs);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Client network or IP address to be denied access by the proxy
     *
     * @param zimbraReverseProxyRestrictedIPs new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1683)
    public Map<String,Object> addReverseProxyRestrictedIPs(String zimbraReverseProxyRestrictedIPs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyRestrictedIPs, zimbraReverseProxyRestrictedIPs);
        return attrs;
    }

    /**
     * Client network or IP address to be denied access by the proxy
     *
     * @param zimbraReverseProxyRestrictedIPs existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1683)
    public void removeReverseProxyRestrictedIPs(String zimbraReverseProxyRestrictedIPs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyRestrictedIPs, zimbraReverseProxyRestrictedIPs);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Client network or IP address to be denied access by the proxy
     *
     * @param zimbraReverseProxyRestrictedIPs existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1683)
    public Map<String,Object> removeReverseProxyRestrictedIPs(String zimbraReverseProxyRestrictedIPs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyRestrictedIPs, zimbraReverseProxyRestrictedIPs);
        return attrs;
    }

    /**
     * Client network or IP address to be denied access by the proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1683)
    public void unsetReverseProxyRestrictedIPs() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRestrictedIPs, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Client network or IP address to be denied access by the proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1683)
    public Map<String,Object> unsetReverseProxyRestrictedIPs(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRestrictedIPs, "");
        return attrs;
    }

    /**
     * Time interval after which NGINX will fail over to the next route
     * lookup handler, if a handler does not respond to the route lookup
     * request within this time. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getReverseProxyRouteLookupTimeoutAsString to access value as a string.
     *
     * @see #getReverseProxyRouteLookupTimeoutAsString()
     *
     * @return zimbraReverseProxyRouteLookupTimeout in millseconds, or -1 if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=745)
    public long getReverseProxyRouteLookupTimeout() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyRouteLookupTimeout, -1L);
    }

    /**
     * Time interval after which NGINX will fail over to the next route
     * lookup handler, if a handler does not respond to the route lookup
     * request within this time. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraReverseProxyRouteLookupTimeout, or null if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=745)
    public String getReverseProxyRouteLookupTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyRouteLookupTimeout, null);
    }

    /**
     * Time interval after which NGINX will fail over to the next route
     * lookup handler, if a handler does not respond to the route lookup
     * request within this time. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyRouteLookupTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=745)
    public void setReverseProxyRouteLookupTimeout(String zimbraReverseProxyRouteLookupTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRouteLookupTimeout, zimbraReverseProxyRouteLookupTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time interval after which NGINX will fail over to the next route
     * lookup handler, if a handler does not respond to the route lookup
     * request within this time. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyRouteLookupTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=745)
    public Map<String,Object> setReverseProxyRouteLookupTimeout(String zimbraReverseProxyRouteLookupTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRouteLookupTimeout, zimbraReverseProxyRouteLookupTimeout);
        return attrs;
    }

    /**
     * Time interval after which NGINX will fail over to the next route
     * lookup handler, if a handler does not respond to the route lookup
     * request within this time. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=745)
    public void unsetReverseProxyRouteLookupTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRouteLookupTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time interval after which NGINX will fail over to the next route
     * lookup handler, if a handler does not respond to the route lookup
     * request within this time. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=745)
    public Map<String,Object> unsetReverseProxyRouteLookupTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRouteLookupTimeout, "");
        return attrs;
    }

    /**
     * Time interval (ms) given to mail route lookup handler to cache a
     * failed response to route a previous lookup request (after this time
     * elapses, Proxy retries this host). Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getReverseProxyRouteLookupTimeoutCacheAsString to access value as a string.
     *
     * @see #getReverseProxyRouteLookupTimeoutCacheAsString()
     *
     * @return zimbraReverseProxyRouteLookupTimeoutCache in millseconds, or -1 if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=778)
    public long getReverseProxyRouteLookupTimeoutCache() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyRouteLookupTimeoutCache, -1L);
    }

    /**
     * Time interval (ms) given to mail route lookup handler to cache a
     * failed response to route a previous lookup request (after this time
     * elapses, Proxy retries this host). Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraReverseProxyRouteLookupTimeoutCache, or null if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=778)
    public String getReverseProxyRouteLookupTimeoutCacheAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyRouteLookupTimeoutCache, null);
    }

    /**
     * Time interval (ms) given to mail route lookup handler to cache a
     * failed response to route a previous lookup request (after this time
     * elapses, Proxy retries this host). Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyRouteLookupTimeoutCache new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=778)
    public void setReverseProxyRouteLookupTimeoutCache(String zimbraReverseProxyRouteLookupTimeoutCache) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRouteLookupTimeoutCache, zimbraReverseProxyRouteLookupTimeoutCache);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time interval (ms) given to mail route lookup handler to cache a
     * failed response to route a previous lookup request (after this time
     * elapses, Proxy retries this host). Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyRouteLookupTimeoutCache new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=778)
    public Map<String,Object> setReverseProxyRouteLookupTimeoutCache(String zimbraReverseProxyRouteLookupTimeoutCache, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRouteLookupTimeoutCache, zimbraReverseProxyRouteLookupTimeoutCache);
        return attrs;
    }

    /**
     * Time interval (ms) given to mail route lookup handler to cache a
     * failed response to route a previous lookup request (after this time
     * elapses, Proxy retries this host). Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=778)
    public void unsetReverseProxyRouteLookupTimeoutCache() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRouteLookupTimeoutCache, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time interval (ms) given to mail route lookup handler to cache a
     * failed response to route a previous lookup request (after this time
     * elapses, Proxy retries this host). Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=778)
    public Map<String,Object> unsetReverseProxyRouteLookupTimeoutCache(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRouteLookupTimeoutCache, "");
        return attrs;
    }

    /**
     * Enable the use of Server Name Indication (SNI) TLS extension in the
     * proxy. When set to TRUE, and using SNI capable clients, there is no
     * need for a separate IP address per domain (zimbraVirtualIPAddress)
     *
     * @return zimbraReverseProxySNIEnabled, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1818)
    public boolean isReverseProxySNIEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxySNIEnabled, false);
    }

    /**
     * Enable the use of Server Name Indication (SNI) TLS extension in the
     * proxy. When set to TRUE, and using SNI capable clients, there is no
     * need for a separate IP address per domain (zimbraVirtualIPAddress)
     *
     * @param zimbraReverseProxySNIEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1818)
    public void setReverseProxySNIEnabled(boolean zimbraReverseProxySNIEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySNIEnabled, zimbraReverseProxySNIEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable the use of Server Name Indication (SNI) TLS extension in the
     * proxy. When set to TRUE, and using SNI capable clients, there is no
     * need for a separate IP address per domain (zimbraVirtualIPAddress)
     *
     * @param zimbraReverseProxySNIEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1818)
    public Map<String,Object> setReverseProxySNIEnabled(boolean zimbraReverseProxySNIEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySNIEnabled, zimbraReverseProxySNIEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Enable the use of Server Name Indication (SNI) TLS extension in the
     * proxy. When set to TRUE, and using SNI capable clients, there is no
     * need for a separate IP address per domain (zimbraVirtualIPAddress)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1818)
    public void unsetReverseProxySNIEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySNIEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable the use of Server Name Indication (SNI) TLS extension in the
     * proxy. When set to TRUE, and using SNI capable clients, there is no
     * need for a separate IP address per domain (zimbraVirtualIPAddress)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1818)
    public Map<String,Object> unsetReverseProxySNIEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySNIEnabled, "");
        return attrs;
    }

    /**
     * Enable/Disable SPDY support for nginx
     *
     * @return zimbraReverseProxySPDYEnabled, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1674)
    public boolean isReverseProxySPDYEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxySPDYEnabled, false);
    }

    /**
     * Enable/Disable SPDY support for nginx
     *
     * @param zimbraReverseProxySPDYEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1674)
    public void setReverseProxySPDYEnabled(boolean zimbraReverseProxySPDYEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySPDYEnabled, zimbraReverseProxySPDYEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable/Disable SPDY support for nginx
     *
     * @param zimbraReverseProxySPDYEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1674)
    public Map<String,Object> setReverseProxySPDYEnabled(boolean zimbraReverseProxySPDYEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySPDYEnabled, zimbraReverseProxySPDYEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Enable/Disable SPDY support for nginx
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1674)
    public void unsetReverseProxySPDYEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySPDYEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable/Disable SPDY support for nginx
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1674)
    public Map<String,Object> unsetReverseProxySPDYEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySPDYEnabled, "");
        return attrs;
    }

    /**
     * SSL protocols enabled for the proxy
     *
     * @return zimbraReverseProxySSLProtocols, or empty array if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1653)
    public String[] getReverseProxySSLProtocols() {
        return getMultiAttr(Provisioning.A_zimbraReverseProxySSLProtocols);
    }

    /**
     * SSL protocols enabled for the proxy
     *
     * @param zimbraReverseProxySSLProtocols new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1653)
    public void setReverseProxySSLProtocols(String[] zimbraReverseProxySSLProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLProtocols, zimbraReverseProxySSLProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL protocols enabled for the proxy
     *
     * @param zimbraReverseProxySSLProtocols new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1653)
    public Map<String,Object> setReverseProxySSLProtocols(String[] zimbraReverseProxySSLProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLProtocols, zimbraReverseProxySSLProtocols);
        return attrs;
    }

    /**
     * SSL protocols enabled for the proxy
     *
     * @param zimbraReverseProxySSLProtocols new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1653)
    public void addReverseProxySSLProtocols(String zimbraReverseProxySSLProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxySSLProtocols, zimbraReverseProxySSLProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL protocols enabled for the proxy
     *
     * @param zimbraReverseProxySSLProtocols new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1653)
    public Map<String,Object> addReverseProxySSLProtocols(String zimbraReverseProxySSLProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxySSLProtocols, zimbraReverseProxySSLProtocols);
        return attrs;
    }

    /**
     * SSL protocols enabled for the proxy
     *
     * @param zimbraReverseProxySSLProtocols existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1653)
    public void removeReverseProxySSLProtocols(String zimbraReverseProxySSLProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxySSLProtocols, zimbraReverseProxySSLProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL protocols enabled for the proxy
     *
     * @param zimbraReverseProxySSLProtocols existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1653)
    public Map<String,Object> removeReverseProxySSLProtocols(String zimbraReverseProxySSLProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxySSLProtocols, zimbraReverseProxySSLProtocols);
        return attrs;
    }

    /**
     * SSL protocols enabled for the proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1653)
    public void unsetReverseProxySSLProtocols() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLProtocols, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL protocols enabled for the proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1653)
    public Map<String,Object> unsetReverseProxySSLProtocols(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLProtocols, "");
        return attrs;
    }

    /**
     * SSL session cache size in megabytes. Need to have &#039;m&#039; (for
     * megabytes) suffix at the end
     *
     * @return zimbraReverseProxySSLSessionCacheSize, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1680)
    public String getReverseProxySSLSessionCacheSize() {
        return getAttr(Provisioning.A_zimbraReverseProxySSLSessionCacheSize, null);
    }

    /**
     * SSL session cache size in megabytes. Need to have &#039;m&#039; (for
     * megabytes) suffix at the end
     *
     * @param zimbraReverseProxySSLSessionCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1680)
    public void setReverseProxySSLSessionCacheSize(String zimbraReverseProxySSLSessionCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLSessionCacheSize, zimbraReverseProxySSLSessionCacheSize);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL session cache size in megabytes. Need to have &#039;m&#039; (for
     * megabytes) suffix at the end
     *
     * @param zimbraReverseProxySSLSessionCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1680)
    public Map<String,Object> setReverseProxySSLSessionCacheSize(String zimbraReverseProxySSLSessionCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLSessionCacheSize, zimbraReverseProxySSLSessionCacheSize);
        return attrs;
    }

    /**
     * SSL session cache size in megabytes. Need to have &#039;m&#039; (for
     * megabytes) suffix at the end
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1680)
    public void unsetReverseProxySSLSessionCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLSessionCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL session cache size in megabytes. Need to have &#039;m&#039; (for
     * megabytes) suffix at the end
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1680)
    public Map<String,Object> unsetReverseProxySSLSessionCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLSessionCacheSize, "");
        return attrs;
    }

    /**
     * SSL session timeout value for the proxy in minutes. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getReverseProxySSLSessionTimeoutAsString to access value as a string.
     *
     * @see #getReverseProxySSLSessionTimeoutAsString()
     *
     * @return zimbraReverseProxySSLSessionTimeout in millseconds, or -1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1679)
    public long getReverseProxySSLSessionTimeout() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxySSLSessionTimeout, -1L);
    }

    /**
     * SSL session timeout value for the proxy in minutes. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraReverseProxySSLSessionTimeout, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1679)
    public String getReverseProxySSLSessionTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxySSLSessionTimeout, null);
    }

    /**
     * SSL session timeout value for the proxy in minutes. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxySSLSessionTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1679)
    public void setReverseProxySSLSessionTimeout(String zimbraReverseProxySSLSessionTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLSessionTimeout, zimbraReverseProxySSLSessionTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL session timeout value for the proxy in minutes. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxySSLSessionTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1679)
    public Map<String,Object> setReverseProxySSLSessionTimeout(String zimbraReverseProxySSLSessionTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLSessionTimeout, zimbraReverseProxySSLSessionTimeout);
        return attrs;
    }

    /**
     * SSL session timeout value for the proxy in minutes. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1679)
    public void unsetReverseProxySSLSessionTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLSessionTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL session timeout value for the proxy in minutes. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1679)
    public Map<String,Object> unsetReverseProxySSLSessionTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLSessionTimeout, "");
        return attrs;
    }

    /**
     * Enables or disables stapling of OCSP responses by nginx
     *
     * <p>Valid values: [off, on]
     *
     * @return zimbraReverseProxySSLStapling, or null if unset and/or has invalid value
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1672)
    public ZAttrProvisioning.ReverseProxySSLStapling getReverseProxySSLStapling() {
        try { String v = getAttr(Provisioning.A_zimbraReverseProxySSLStapling); return v == null ? null : ZAttrProvisioning.ReverseProxySSLStapling.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Enables or disables stapling of OCSP responses by nginx
     *
     * <p>Valid values: [off, on]
     *
     * @return zimbraReverseProxySSLStapling, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1672)
    public String getReverseProxySSLStaplingAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxySSLStapling, null);
    }

    /**
     * Enables or disables stapling of OCSP responses by nginx
     *
     * <p>Valid values: [off, on]
     *
     * @param zimbraReverseProxySSLStapling new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1672)
    public void setReverseProxySSLStapling(ZAttrProvisioning.ReverseProxySSLStapling zimbraReverseProxySSLStapling) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLStapling, zimbraReverseProxySSLStapling.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enables or disables stapling of OCSP responses by nginx
     *
     * <p>Valid values: [off, on]
     *
     * @param zimbraReverseProxySSLStapling new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1672)
    public Map<String,Object> setReverseProxySSLStapling(ZAttrProvisioning.ReverseProxySSLStapling zimbraReverseProxySSLStapling, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLStapling, zimbraReverseProxySSLStapling.toString());
        return attrs;
    }

    /**
     * Enables or disables stapling of OCSP responses by nginx
     *
     * <p>Valid values: [off, on]
     *
     * @param zimbraReverseProxySSLStapling new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1672)
    public void setReverseProxySSLStaplingAsString(String zimbraReverseProxySSLStapling) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLStapling, zimbraReverseProxySSLStapling);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enables or disables stapling of OCSP responses by nginx
     *
     * <p>Valid values: [off, on]
     *
     * @param zimbraReverseProxySSLStapling new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1672)
    public Map<String,Object> setReverseProxySSLStaplingAsString(String zimbraReverseProxySSLStapling, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLStapling, zimbraReverseProxySSLStapling);
        return attrs;
    }

    /**
     * Enables or disables stapling of OCSP responses by nginx
     *
     * <p>Valid values: [off, on]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1672)
    public void unsetReverseProxySSLStapling() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLStapling, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enables or disables stapling of OCSP responses by nginx
     *
     * <p>Valid values: [off, on]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1672)
    public Map<String,Object> unsetReverseProxySSLStapling(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLStapling, "");
        return attrs;
    }

    /**
     * OCSP Responder URL which overrides the URL of the OCSP responder
     * specified in the “Authority Information Access” certificate extension.
     * Only “http://” OCSP responders are supported
     *
     * @return zimbraReverseProxySSLStaplingResponderURL, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1673)
    public String getReverseProxySSLStaplingResponderURL() {
        return getAttr(Provisioning.A_zimbraReverseProxySSLStaplingResponderURL, null);
    }

    /**
     * OCSP Responder URL which overrides the URL of the OCSP responder
     * specified in the “Authority Information Access” certificate extension.
     * Only “http://” OCSP responders are supported
     *
     * @param zimbraReverseProxySSLStaplingResponderURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1673)
    public void setReverseProxySSLStaplingResponderURL(String zimbraReverseProxySSLStaplingResponderURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLStaplingResponderURL, zimbraReverseProxySSLStaplingResponderURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * OCSP Responder URL which overrides the URL of the OCSP responder
     * specified in the “Authority Information Access” certificate extension.
     * Only “http://” OCSP responders are supported
     *
     * @param zimbraReverseProxySSLStaplingResponderURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1673)
    public Map<String,Object> setReverseProxySSLStaplingResponderURL(String zimbraReverseProxySSLStaplingResponderURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLStaplingResponderURL, zimbraReverseProxySSLStaplingResponderURL);
        return attrs;
    }

    /**
     * OCSP Responder URL which overrides the URL of the OCSP responder
     * specified in the “Authority Information Access” certificate extension.
     * Only “http://” OCSP responders are supported
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1673)
    public void unsetReverseProxySSLStaplingResponderURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLStaplingResponderURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * OCSP Responder URL which overrides the URL of the OCSP responder
     * specified in the “Authority Information Access” certificate extension.
     * Only “http://” OCSP responders are supported
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1673)
    public Map<String,Object> unsetReverseProxySSLStaplingResponderURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLStaplingResponderURL, "");
        return attrs;
    }

    /**
     * If set as TRUE, proxy will use SSL to connect to the upstream mail
     * servers for web and mail proxy. Note admin console proxy always use
     * https no matter how this attr is set.
     *
     * @return zimbraReverseProxySSLToUpstreamEnabled, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1360)
    public boolean isReverseProxySSLToUpstreamEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxySSLToUpstreamEnabled, false);
    }

    /**
     * If set as TRUE, proxy will use SSL to connect to the upstream mail
     * servers for web and mail proxy. Note admin console proxy always use
     * https no matter how this attr is set.
     *
     * @param zimbraReverseProxySSLToUpstreamEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1360)
    public void setReverseProxySSLToUpstreamEnabled(boolean zimbraReverseProxySSLToUpstreamEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLToUpstreamEnabled, zimbraReverseProxySSLToUpstreamEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If set as TRUE, proxy will use SSL to connect to the upstream mail
     * servers for web and mail proxy. Note admin console proxy always use
     * https no matter how this attr is set.
     *
     * @param zimbraReverseProxySSLToUpstreamEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1360)
    public Map<String,Object> setReverseProxySSLToUpstreamEnabled(boolean zimbraReverseProxySSLToUpstreamEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLToUpstreamEnabled, zimbraReverseProxySSLToUpstreamEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * If set as TRUE, proxy will use SSL to connect to the upstream mail
     * servers for web and mail proxy. Note admin console proxy always use
     * https no matter how this attr is set.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1360)
    public void unsetReverseProxySSLToUpstreamEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLToUpstreamEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If set as TRUE, proxy will use SSL to connect to the upstream mail
     * servers for web and mail proxy. Note admin console proxy always use
     * https no matter how this attr is set.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1360)
    public Map<String,Object> unsetReverseProxySSLToUpstreamEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLToUpstreamEnabled, "");
        return attrs;
    }

    /**
     * The connect timeout is the time interval after which NGINX will
     * disconnect while establishing an upstream HTTP connection. Measured in
     * seconds, should not be more than 75 seconds.
     *
     * @return zimbraReverseProxyUpstreamConnectTimeout, or -1 if unset
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1440)
    public int getReverseProxyUpstreamConnectTimeout() {
        return getIntAttr(Provisioning.A_zimbraReverseProxyUpstreamConnectTimeout, -1);
    }

    /**
     * The connect timeout is the time interval after which NGINX will
     * disconnect while establishing an upstream HTTP connection. Measured in
     * seconds, should not be more than 75 seconds.
     *
     * @param zimbraReverseProxyUpstreamConnectTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1440)
    public void setReverseProxyUpstreamConnectTimeout(int zimbraReverseProxyUpstreamConnectTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamConnectTimeout, Integer.toString(zimbraReverseProxyUpstreamConnectTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The connect timeout is the time interval after which NGINX will
     * disconnect while establishing an upstream HTTP connection. Measured in
     * seconds, should not be more than 75 seconds.
     *
     * @param zimbraReverseProxyUpstreamConnectTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1440)
    public Map<String,Object> setReverseProxyUpstreamConnectTimeout(int zimbraReverseProxyUpstreamConnectTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamConnectTimeout, Integer.toString(zimbraReverseProxyUpstreamConnectTimeout));
        return attrs;
    }

    /**
     * The connect timeout is the time interval after which NGINX will
     * disconnect while establishing an upstream HTTP connection. Measured in
     * seconds, should not be more than 75 seconds.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1440)
    public void unsetReverseProxyUpstreamConnectTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamConnectTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The connect timeout is the time interval after which NGINX will
     * disconnect while establishing an upstream HTTP connection. Measured in
     * seconds, should not be more than 75 seconds.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1440)
    public Map<String,Object> unsetReverseProxyUpstreamConnectTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamConnectTimeout, "");
        return attrs;
    }

    /**
     * The servers running mailbox with EWS functionality to be included in
     * the &quot;ews&quot; block in the nginx web proxy config file
     *
     * @return zimbraReverseProxyUpstreamEwsServers, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1595)
    public String[] getReverseProxyUpstreamEwsServers() {
        return getMultiAttr(Provisioning.A_zimbraReverseProxyUpstreamEwsServers);
    }

    /**
     * The servers running mailbox with EWS functionality to be included in
     * the &quot;ews&quot; block in the nginx web proxy config file
     *
     * @param zimbraReverseProxyUpstreamEwsServers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1595)
    public void setReverseProxyUpstreamEwsServers(String[] zimbraReverseProxyUpstreamEwsServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamEwsServers, zimbraReverseProxyUpstreamEwsServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers running mailbox with EWS functionality to be included in
     * the &quot;ews&quot; block in the nginx web proxy config file
     *
     * @param zimbraReverseProxyUpstreamEwsServers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1595)
    public Map<String,Object> setReverseProxyUpstreamEwsServers(String[] zimbraReverseProxyUpstreamEwsServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamEwsServers, zimbraReverseProxyUpstreamEwsServers);
        return attrs;
    }

    /**
     * The servers running mailbox with EWS functionality to be included in
     * the &quot;ews&quot; block in the nginx web proxy config file
     *
     * @param zimbraReverseProxyUpstreamEwsServers new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1595)
    public void addReverseProxyUpstreamEwsServers(String zimbraReverseProxyUpstreamEwsServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyUpstreamEwsServers, zimbraReverseProxyUpstreamEwsServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers running mailbox with EWS functionality to be included in
     * the &quot;ews&quot; block in the nginx web proxy config file
     *
     * @param zimbraReverseProxyUpstreamEwsServers new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1595)
    public Map<String,Object> addReverseProxyUpstreamEwsServers(String zimbraReverseProxyUpstreamEwsServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyUpstreamEwsServers, zimbraReverseProxyUpstreamEwsServers);
        return attrs;
    }

    /**
     * The servers running mailbox with EWS functionality to be included in
     * the &quot;ews&quot; block in the nginx web proxy config file
     *
     * @param zimbraReverseProxyUpstreamEwsServers existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1595)
    public void removeReverseProxyUpstreamEwsServers(String zimbraReverseProxyUpstreamEwsServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyUpstreamEwsServers, zimbraReverseProxyUpstreamEwsServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers running mailbox with EWS functionality to be included in
     * the &quot;ews&quot; block in the nginx web proxy config file
     *
     * @param zimbraReverseProxyUpstreamEwsServers existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1595)
    public Map<String,Object> removeReverseProxyUpstreamEwsServers(String zimbraReverseProxyUpstreamEwsServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyUpstreamEwsServers, zimbraReverseProxyUpstreamEwsServers);
        return attrs;
    }

    /**
     * The servers running mailbox with EWS functionality to be included in
     * the &quot;ews&quot; block in the nginx web proxy config file
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1595)
    public void unsetReverseProxyUpstreamEwsServers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamEwsServers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers running mailbox with EWS functionality to be included in
     * the &quot;ews&quot; block in the nginx web proxy config file
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1595)
    public Map<String,Object> unsetReverseProxyUpstreamEwsServers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamEwsServers, "");
        return attrs;
    }

    /**
     * The servers to be included in the login block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * login URL requests.
     *
     * @return zimbraReverseProxyUpstreamLoginServers, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1603)
    public String[] getReverseProxyUpstreamLoginServers() {
        return getMultiAttr(Provisioning.A_zimbraReverseProxyUpstreamLoginServers);
    }

    /**
     * The servers to be included in the login block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * login URL requests.
     *
     * @param zimbraReverseProxyUpstreamLoginServers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1603)
    public void setReverseProxyUpstreamLoginServers(String[] zimbraReverseProxyUpstreamLoginServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamLoginServers, zimbraReverseProxyUpstreamLoginServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers to be included in the login block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * login URL requests.
     *
     * @param zimbraReverseProxyUpstreamLoginServers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1603)
    public Map<String,Object> setReverseProxyUpstreamLoginServers(String[] zimbraReverseProxyUpstreamLoginServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamLoginServers, zimbraReverseProxyUpstreamLoginServers);
        return attrs;
    }

    /**
     * The servers to be included in the login block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * login URL requests.
     *
     * @param zimbraReverseProxyUpstreamLoginServers new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1603)
    public void addReverseProxyUpstreamLoginServers(String zimbraReverseProxyUpstreamLoginServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyUpstreamLoginServers, zimbraReverseProxyUpstreamLoginServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers to be included in the login block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * login URL requests.
     *
     * @param zimbraReverseProxyUpstreamLoginServers new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1603)
    public Map<String,Object> addReverseProxyUpstreamLoginServers(String zimbraReverseProxyUpstreamLoginServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyUpstreamLoginServers, zimbraReverseProxyUpstreamLoginServers);
        return attrs;
    }

    /**
     * The servers to be included in the login block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * login URL requests.
     *
     * @param zimbraReverseProxyUpstreamLoginServers existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1603)
    public void removeReverseProxyUpstreamLoginServers(String zimbraReverseProxyUpstreamLoginServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyUpstreamLoginServers, zimbraReverseProxyUpstreamLoginServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers to be included in the login block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * login URL requests.
     *
     * @param zimbraReverseProxyUpstreamLoginServers existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1603)
    public Map<String,Object> removeReverseProxyUpstreamLoginServers(String zimbraReverseProxyUpstreamLoginServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyUpstreamLoginServers, zimbraReverseProxyUpstreamLoginServers);
        return attrs;
    }

    /**
     * The servers to be included in the login block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * login URL requests.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1603)
    public void unsetReverseProxyUpstreamLoginServers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamLoginServers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers to be included in the login block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * login URL requests.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1603)
    public Map<String,Object> unsetReverseProxyUpstreamLoginServers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamLoginServers, "");
        return attrs;
    }

    /**
     * The read timeout for long polling support by proxy, e.g. ActiveSync
     * for mobile devices. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getReverseProxyUpstreamPollingTimeoutAsString to access value as a string.
     *
     * @see #getReverseProxyUpstreamPollingTimeoutAsString()
     *
     * @return zimbraReverseProxyUpstreamPollingTimeout in millseconds, or -1 if unset
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1337)
    public long getReverseProxyUpstreamPollingTimeout() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyUpstreamPollingTimeout, -1L);
    }

    /**
     * The read timeout for long polling support by proxy, e.g. ActiveSync
     * for mobile devices. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraReverseProxyUpstreamPollingTimeout, or null if unset
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1337)
    public String getReverseProxyUpstreamPollingTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyUpstreamPollingTimeout, null);
    }

    /**
     * The read timeout for long polling support by proxy, e.g. ActiveSync
     * for mobile devices. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyUpstreamPollingTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1337)
    public void setReverseProxyUpstreamPollingTimeout(String zimbraReverseProxyUpstreamPollingTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamPollingTimeout, zimbraReverseProxyUpstreamPollingTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The read timeout for long polling support by proxy, e.g. ActiveSync
     * for mobile devices. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyUpstreamPollingTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1337)
    public Map<String,Object> setReverseProxyUpstreamPollingTimeout(String zimbraReverseProxyUpstreamPollingTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamPollingTimeout, zimbraReverseProxyUpstreamPollingTimeout);
        return attrs;
    }

    /**
     * The read timeout for long polling support by proxy, e.g. ActiveSync
     * for mobile devices. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1337)
    public void unsetReverseProxyUpstreamPollingTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamPollingTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The read timeout for long polling support by proxy, e.g. ActiveSync
     * for mobile devices. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1337)
    public Map<String,Object> unsetReverseProxyUpstreamPollingTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamPollingTimeout, "");
        return attrs;
    }

    /**
     * The read timeout for the response of upstream server, which determines
     * how long nginx will wait to get the response to a request. . Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getReverseProxyUpstreamReadTimeoutAsString to access value as a string.
     *
     * @see #getReverseProxyUpstreamReadTimeoutAsString()
     *
     * @return zimbraReverseProxyUpstreamReadTimeout in millseconds, or -1 if unset
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1335)
    public long getReverseProxyUpstreamReadTimeout() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyUpstreamReadTimeout, -1L);
    }

    /**
     * The read timeout for the response of upstream server, which determines
     * how long nginx will wait to get the response to a request. . Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraReverseProxyUpstreamReadTimeout, or null if unset
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1335)
    public String getReverseProxyUpstreamReadTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyUpstreamReadTimeout, null);
    }

    /**
     * The read timeout for the response of upstream server, which determines
     * how long nginx will wait to get the response to a request. . Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxyUpstreamReadTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1335)
    public void setReverseProxyUpstreamReadTimeout(String zimbraReverseProxyUpstreamReadTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamReadTimeout, zimbraReverseProxyUpstreamReadTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The read timeout for the response of upstream server, which determines
     * how long nginx will wait to get the response to a request. . Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxyUpstreamReadTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1335)
    public Map<String,Object> setReverseProxyUpstreamReadTimeout(String zimbraReverseProxyUpstreamReadTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamReadTimeout, zimbraReverseProxyUpstreamReadTimeout);
        return attrs;
    }

    /**
     * The read timeout for the response of upstream server, which determines
     * how long nginx will wait to get the response to a request. . Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1335)
    public void unsetReverseProxyUpstreamReadTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamReadTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The read timeout for the response of upstream server, which determines
     * how long nginx will wait to get the response to a request. . Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1335)
    public Map<String,Object> unsetReverseProxyUpstreamReadTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamReadTimeout, "");
        return attrs;
    }

    /**
     * The send timeout of transfering a request to the upstream server. If
     * after this time the upstream server doesn&#039;t take new data, proxy
     * will close the connection. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getReverseProxyUpstreamSendTimeoutAsString to access value as a string.
     *
     * @see #getReverseProxyUpstreamSendTimeoutAsString()
     *
     * @return zimbraReverseProxyUpstreamSendTimeout in millseconds, or -1 if unset
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1336)
    public long getReverseProxyUpstreamSendTimeout() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyUpstreamSendTimeout, -1L);
    }

    /**
     * The send timeout of transfering a request to the upstream server. If
     * after this time the upstream server doesn&#039;t take new data, proxy
     * will close the connection. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraReverseProxyUpstreamSendTimeout, or null if unset
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1336)
    public String getReverseProxyUpstreamSendTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyUpstreamSendTimeout, null);
    }

    /**
     * The send timeout of transfering a request to the upstream server. If
     * after this time the upstream server doesn&#039;t take new data, proxy
     * will close the connection. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyUpstreamSendTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1336)
    public void setReverseProxyUpstreamSendTimeout(String zimbraReverseProxyUpstreamSendTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamSendTimeout, zimbraReverseProxyUpstreamSendTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The send timeout of transfering a request to the upstream server. If
     * after this time the upstream server doesn&#039;t take new data, proxy
     * will close the connection. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyUpstreamSendTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1336)
    public Map<String,Object> setReverseProxyUpstreamSendTimeout(String zimbraReverseProxyUpstreamSendTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamSendTimeout, zimbraReverseProxyUpstreamSendTimeout);
        return attrs;
    }

    /**
     * The send timeout of transfering a request to the upstream server. If
     * after this time the upstream server doesn&#039;t take new data, proxy
     * will close the connection. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1336)
    public void unsetReverseProxyUpstreamSendTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamSendTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The send timeout of transfering a request to the upstream server. If
     * after this time the upstream server doesn&#039;t take new data, proxy
     * will close the connection. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1336)
    public Map<String,Object> unsetReverseProxyUpstreamSendTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamSendTimeout, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. Configuration for pre-login upstream is now
     * handled via zimbraReverseProxyUpstreamLoginServers. Post-login
     * upstreams are now automatically configured per-webapp based on what is
     * present in zimbraServiceEnabled.. Orig desc: The servers to be
     * included in the &quot;upstream&quot; block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * pre-login requests. Leaving empty means using all the servers whose
     * zimbraReverseProxyLookupTarget is TRUE.
     *
     * @return zimbraReverseProxyUpstreamServers, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1378)
    public String[] getReverseProxyUpstreamServers() {
        return getMultiAttr(Provisioning.A_zimbraReverseProxyUpstreamServers);
    }

    /**
     * Deprecated since: 8.5.0. Configuration for pre-login upstream is now
     * handled via zimbraReverseProxyUpstreamLoginServers. Post-login
     * upstreams are now automatically configured per-webapp based on what is
     * present in zimbraServiceEnabled.. Orig desc: The servers to be
     * included in the &quot;upstream&quot; block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * pre-login requests. Leaving empty means using all the servers whose
     * zimbraReverseProxyLookupTarget is TRUE.
     *
     * @param zimbraReverseProxyUpstreamServers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1378)
    public void setReverseProxyUpstreamServers(String[] zimbraReverseProxyUpstreamServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamServers, zimbraReverseProxyUpstreamServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. Configuration for pre-login upstream is now
     * handled via zimbraReverseProxyUpstreamLoginServers. Post-login
     * upstreams are now automatically configured per-webapp based on what is
     * present in zimbraServiceEnabled.. Orig desc: The servers to be
     * included in the &quot;upstream&quot; block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * pre-login requests. Leaving empty means using all the servers whose
     * zimbraReverseProxyLookupTarget is TRUE.
     *
     * @param zimbraReverseProxyUpstreamServers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1378)
    public Map<String,Object> setReverseProxyUpstreamServers(String[] zimbraReverseProxyUpstreamServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamServers, zimbraReverseProxyUpstreamServers);
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. Configuration for pre-login upstream is now
     * handled via zimbraReverseProxyUpstreamLoginServers. Post-login
     * upstreams are now automatically configured per-webapp based on what is
     * present in zimbraServiceEnabled.. Orig desc: The servers to be
     * included in the &quot;upstream&quot; block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * pre-login requests. Leaving empty means using all the servers whose
     * zimbraReverseProxyLookupTarget is TRUE.
     *
     * @param zimbraReverseProxyUpstreamServers new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1378)
    public void addReverseProxyUpstreamServers(String zimbraReverseProxyUpstreamServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyUpstreamServers, zimbraReverseProxyUpstreamServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. Configuration for pre-login upstream is now
     * handled via zimbraReverseProxyUpstreamLoginServers. Post-login
     * upstreams are now automatically configured per-webapp based on what is
     * present in zimbraServiceEnabled.. Orig desc: The servers to be
     * included in the &quot;upstream&quot; block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * pre-login requests. Leaving empty means using all the servers whose
     * zimbraReverseProxyLookupTarget is TRUE.
     *
     * @param zimbraReverseProxyUpstreamServers new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1378)
    public Map<String,Object> addReverseProxyUpstreamServers(String zimbraReverseProxyUpstreamServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyUpstreamServers, zimbraReverseProxyUpstreamServers);
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. Configuration for pre-login upstream is now
     * handled via zimbraReverseProxyUpstreamLoginServers. Post-login
     * upstreams are now automatically configured per-webapp based on what is
     * present in zimbraServiceEnabled.. Orig desc: The servers to be
     * included in the &quot;upstream&quot; block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * pre-login requests. Leaving empty means using all the servers whose
     * zimbraReverseProxyLookupTarget is TRUE.
     *
     * @param zimbraReverseProxyUpstreamServers existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1378)
    public void removeReverseProxyUpstreamServers(String zimbraReverseProxyUpstreamServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyUpstreamServers, zimbraReverseProxyUpstreamServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. Configuration for pre-login upstream is now
     * handled via zimbraReverseProxyUpstreamLoginServers. Post-login
     * upstreams are now automatically configured per-webapp based on what is
     * present in zimbraServiceEnabled.. Orig desc: The servers to be
     * included in the &quot;upstream&quot; block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * pre-login requests. Leaving empty means using all the servers whose
     * zimbraReverseProxyLookupTarget is TRUE.
     *
     * @param zimbraReverseProxyUpstreamServers existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1378)
    public Map<String,Object> removeReverseProxyUpstreamServers(String zimbraReverseProxyUpstreamServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyUpstreamServers, zimbraReverseProxyUpstreamServers);
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. Configuration for pre-login upstream is now
     * handled via zimbraReverseProxyUpstreamLoginServers. Post-login
     * upstreams are now automatically configured per-webapp based on what is
     * present in zimbraServiceEnabled.. Orig desc: The servers to be
     * included in the &quot;upstream&quot; block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * pre-login requests. Leaving empty means using all the servers whose
     * zimbraReverseProxyLookupTarget is TRUE.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1378)
    public void unsetReverseProxyUpstreamServers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamServers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. Configuration for pre-login upstream is now
     * handled via zimbraReverseProxyUpstreamLoginServers. Post-login
     * upstreams are now automatically configured per-webapp based on what is
     * present in zimbraServiceEnabled.. Orig desc: The servers to be
     * included in the &quot;upstream&quot; block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * pre-login requests. Leaving empty means using all the servers whose
     * zimbraReverseProxyLookupTarget is TRUE.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1378)
    public Map<String,Object> unsetReverseProxyUpstreamServers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamServers, "");
        return attrs;
    }

    /**
     * Maximum number of connections that an NGINX Proxy worker process is
     * allowed to handle
     *
     * @return zimbraReverseProxyWorkerConnections, or -1 if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=725)
    public int getReverseProxyWorkerConnections() {
        return getIntAttr(Provisioning.A_zimbraReverseProxyWorkerConnections, -1);
    }

    /**
     * Maximum number of connections that an NGINX Proxy worker process is
     * allowed to handle
     *
     * @param zimbraReverseProxyWorkerConnections new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=725)
    public void setReverseProxyWorkerConnections(int zimbraReverseProxyWorkerConnections) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyWorkerConnections, Integer.toString(zimbraReverseProxyWorkerConnections));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of connections that an NGINX Proxy worker process is
     * allowed to handle
     *
     * @param zimbraReverseProxyWorkerConnections new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=725)
    public Map<String,Object> setReverseProxyWorkerConnections(int zimbraReverseProxyWorkerConnections, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyWorkerConnections, Integer.toString(zimbraReverseProxyWorkerConnections));
        return attrs;
    }

    /**
     * Maximum number of connections that an NGINX Proxy worker process is
     * allowed to handle
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=725)
    public void unsetReverseProxyWorkerConnections() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyWorkerConnections, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of connections that an NGINX Proxy worker process is
     * allowed to handle
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=725)
    public Map<String,Object> unsetReverseProxyWorkerConnections(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyWorkerConnections, "");
        return attrs;
    }

    /**
     * Number of worker processes of NGINX Proxy
     *
     * @return zimbraReverseProxyWorkerProcesses, or -1 if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=724)
    public int getReverseProxyWorkerProcesses() {
        return getIntAttr(Provisioning.A_zimbraReverseProxyWorkerProcesses, -1);
    }

    /**
     * Number of worker processes of NGINX Proxy
     *
     * @param zimbraReverseProxyWorkerProcesses new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=724)
    public void setReverseProxyWorkerProcesses(int zimbraReverseProxyWorkerProcesses) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyWorkerProcesses, Integer.toString(zimbraReverseProxyWorkerProcesses));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Number of worker processes of NGINX Proxy
     *
     * @param zimbraReverseProxyWorkerProcesses new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=724)
    public Map<String,Object> setReverseProxyWorkerProcesses(int zimbraReverseProxyWorkerProcesses, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyWorkerProcesses, Integer.toString(zimbraReverseProxyWorkerProcesses));
        return attrs;
    }

    /**
     * Number of worker processes of NGINX Proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=724)
    public void unsetReverseProxyWorkerProcesses() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyWorkerProcesses, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Number of worker processes of NGINX Proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=724)
    public Map<String,Object> unsetReverseProxyWorkerProcesses(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyWorkerProcesses, "");
        return attrs;
    }

    /**
     * whether nginx should cache upstream routes in memcache
     *
     * @return zimbraReverseProxyZmlookupCachingEnabled, or false if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1785)
    public boolean isReverseProxyZmlookupCachingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyZmlookupCachingEnabled, false);
    }

    /**
     * whether nginx should cache upstream routes in memcache
     *
     * @param zimbraReverseProxyZmlookupCachingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1785)
    public void setReverseProxyZmlookupCachingEnabled(boolean zimbraReverseProxyZmlookupCachingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyZmlookupCachingEnabled, zimbraReverseProxyZmlookupCachingEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether nginx should cache upstream routes in memcache
     *
     * @param zimbraReverseProxyZmlookupCachingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1785)
    public Map<String,Object> setReverseProxyZmlookupCachingEnabled(boolean zimbraReverseProxyZmlookupCachingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyZmlookupCachingEnabled, zimbraReverseProxyZmlookupCachingEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * whether nginx should cache upstream routes in memcache
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1785)
    public void unsetReverseProxyZmlookupCachingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyZmlookupCachingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether nginx should cache upstream routes in memcache
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1785)
    public Map<String,Object> unsetReverseProxyZmlookupCachingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyZmlookupCachingEnabled, "");
        return attrs;
    }

    /**
     * List of included cipher suites for Jetty. If any value is set only
     * these ciphers will be used, in effect superseding
     * zimbraSSLExcludeCipherSuites. Order of selection is based on client
     * preference and default Java order since Java SSLEngine does not allow
     * changing the preference order.
     *
     * @return zimbraSSLIncludeCipherSuites, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1604)
    public String[] getSSLIncludeCipherSuites() {
        return getMultiAttr(Provisioning.A_zimbraSSLIncludeCipherSuites);
    }

    /**
     * List of included cipher suites for Jetty. If any value is set only
     * these ciphers will be used, in effect superseding
     * zimbraSSLExcludeCipherSuites. Order of selection is based on client
     * preference and default Java order since Java SSLEngine does not allow
     * changing the preference order.
     *
     * @param zimbraSSLIncludeCipherSuites new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1604)
    public void setSSLIncludeCipherSuites(String[] zimbraSSLIncludeCipherSuites) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLIncludeCipherSuites, zimbraSSLIncludeCipherSuites);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of included cipher suites for Jetty. If any value is set only
     * these ciphers will be used, in effect superseding
     * zimbraSSLExcludeCipherSuites. Order of selection is based on client
     * preference and default Java order since Java SSLEngine does not allow
     * changing the preference order.
     *
     * @param zimbraSSLIncludeCipherSuites new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1604)
    public Map<String,Object> setSSLIncludeCipherSuites(String[] zimbraSSLIncludeCipherSuites, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLIncludeCipherSuites, zimbraSSLIncludeCipherSuites);
        return attrs;
    }

    /**
     * List of included cipher suites for Jetty. If any value is set only
     * these ciphers will be used, in effect superseding
     * zimbraSSLExcludeCipherSuites. Order of selection is based on client
     * preference and default Java order since Java SSLEngine does not allow
     * changing the preference order.
     *
     * @param zimbraSSLIncludeCipherSuites new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1604)
    public void addSSLIncludeCipherSuites(String zimbraSSLIncludeCipherSuites) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSSLIncludeCipherSuites, zimbraSSLIncludeCipherSuites);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of included cipher suites for Jetty. If any value is set only
     * these ciphers will be used, in effect superseding
     * zimbraSSLExcludeCipherSuites. Order of selection is based on client
     * preference and default Java order since Java SSLEngine does not allow
     * changing the preference order.
     *
     * @param zimbraSSLIncludeCipherSuites new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1604)
    public Map<String,Object> addSSLIncludeCipherSuites(String zimbraSSLIncludeCipherSuites, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSSLIncludeCipherSuites, zimbraSSLIncludeCipherSuites);
        return attrs;
    }

    /**
     * List of included cipher suites for Jetty. If any value is set only
     * these ciphers will be used, in effect superseding
     * zimbraSSLExcludeCipherSuites. Order of selection is based on client
     * preference and default Java order since Java SSLEngine does not allow
     * changing the preference order.
     *
     * @param zimbraSSLIncludeCipherSuites existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1604)
    public void removeSSLIncludeCipherSuites(String zimbraSSLIncludeCipherSuites) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSSLIncludeCipherSuites, zimbraSSLIncludeCipherSuites);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of included cipher suites for Jetty. If any value is set only
     * these ciphers will be used, in effect superseding
     * zimbraSSLExcludeCipherSuites. Order of selection is based on client
     * preference and default Java order since Java SSLEngine does not allow
     * changing the preference order.
     *
     * @param zimbraSSLIncludeCipherSuites existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1604)
    public Map<String,Object> removeSSLIncludeCipherSuites(String zimbraSSLIncludeCipherSuites, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSSLIncludeCipherSuites, zimbraSSLIncludeCipherSuites);
        return attrs;
    }

    /**
     * List of included cipher suites for Jetty. If any value is set only
     * these ciphers will be used, in effect superseding
     * zimbraSSLExcludeCipherSuites. Order of selection is based on client
     * preference and default Java order since Java SSLEngine does not allow
     * changing the preference order.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1604)
    public void unsetSSLIncludeCipherSuites() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLIncludeCipherSuites, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of included cipher suites for Jetty. If any value is set only
     * these ciphers will be used, in effect superseding
     * zimbraSSLExcludeCipherSuites. Order of selection is based on client
     * preference and default Java order since Java SSLEngine does not allow
     * changing the preference order.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1604)
    public Map<String,Object> unsetSSLIncludeCipherSuites(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLIncludeCipherSuites, "");
        return attrs;
    }

    /**
     * whether TLS is required for IMAP/POP GSSAPI auth
     *
     * @return zimbraSaslGssapiRequiresTls, or false if unset
     *
     * @since ZCS 5.0.20
     */
    @ZAttr(id=1068)
    public boolean isSaslGssapiRequiresTls() {
        return getBooleanAttr(Provisioning.A_zimbraSaslGssapiRequiresTls, false);
    }

    /**
     * whether TLS is required for IMAP/POP GSSAPI auth
     *
     * @param zimbraSaslGssapiRequiresTls new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.20
     */
    @ZAttr(id=1068)
    public void setSaslGssapiRequiresTls(boolean zimbraSaslGssapiRequiresTls) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSaslGssapiRequiresTls, zimbraSaslGssapiRequiresTls ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether TLS is required for IMAP/POP GSSAPI auth
     *
     * @param zimbraSaslGssapiRequiresTls new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.20
     */
    @ZAttr(id=1068)
    public Map<String,Object> setSaslGssapiRequiresTls(boolean zimbraSaslGssapiRequiresTls, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSaslGssapiRequiresTls, zimbraSaslGssapiRequiresTls ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * whether TLS is required for IMAP/POP GSSAPI auth
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.20
     */
    @ZAttr(id=1068)
    public void unsetSaslGssapiRequiresTls() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSaslGssapiRequiresTls, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether TLS is required for IMAP/POP GSSAPI auth
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.20
     */
    @ZAttr(id=1068)
    public Map<String,Object> unsetSaslGssapiRequiresTls(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSaslGssapiRequiresTls, "");
        return attrs;
    }

    /**
     * Maximum number of scheduled tasks that can run simultaneously.
     *
     * @return zimbraScheduledTaskNumThreads, or -1 if unset
     */
    @ZAttr(id=522)
    public int getScheduledTaskNumThreads() {
        return getIntAttr(Provisioning.A_zimbraScheduledTaskNumThreads, -1);
    }

    /**
     * Maximum number of scheduled tasks that can run simultaneously.
     *
     * @param zimbraScheduledTaskNumThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=522)
    public void setScheduledTaskNumThreads(int zimbraScheduledTaskNumThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskNumThreads, Integer.toString(zimbraScheduledTaskNumThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of scheduled tasks that can run simultaneously.
     *
     * @param zimbraScheduledTaskNumThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=522)
    public Map<String,Object> setScheduledTaskNumThreads(int zimbraScheduledTaskNumThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskNumThreads, Integer.toString(zimbraScheduledTaskNumThreads));
        return attrs;
    }

    /**
     * Maximum number of scheduled tasks that can run simultaneously.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=522)
    public void unsetScheduledTaskNumThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskNumThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of scheduled tasks that can run simultaneously.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=522)
    public Map<String,Object> unsetScheduledTaskNumThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskNumThreads, "");
        return attrs;
    }

    /**
     * Maximum pending notifications allowed
     *
     * @return zimbraSessionMaxPendingNotifications, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1740)
    public int getSessionMaxPendingNotifications() {
        return getIntAttr(Provisioning.A_zimbraSessionMaxPendingNotifications, -1);
    }

    /**
     * Maximum pending notifications allowed
     *
     * @param zimbraSessionMaxPendingNotifications new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1740)
    public void setSessionMaxPendingNotifications(int zimbraSessionMaxPendingNotifications) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSessionMaxPendingNotifications, Integer.toString(zimbraSessionMaxPendingNotifications));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum pending notifications allowed
     *
     * @param zimbraSessionMaxPendingNotifications new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1740)
    public Map<String,Object> setSessionMaxPendingNotifications(int zimbraSessionMaxPendingNotifications, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSessionMaxPendingNotifications, Integer.toString(zimbraSessionMaxPendingNotifications));
        return attrs;
    }

    /**
     * Maximum pending notifications allowed
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1740)
    public void unsetSessionMaxPendingNotifications() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSessionMaxPendingNotifications, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum pending notifications allowed
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1740)
    public Map<String,Object> unsetSessionMaxPendingNotifications(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSessionMaxPendingNotifications, "");
        return attrs;
    }

    /**
     * Account name for authenticating to share notification MTA.
     *
     * @return zimbraShareNotificationMtaAuthAccount, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1343)
    public String getShareNotificationMtaAuthAccount() {
        return getAttr(Provisioning.A_zimbraShareNotificationMtaAuthAccount, null);
    }

    /**
     * Account name for authenticating to share notification MTA.
     *
     * @param zimbraShareNotificationMtaAuthAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1343)
    public void setShareNotificationMtaAuthAccount(String zimbraShareNotificationMtaAuthAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthAccount, zimbraShareNotificationMtaAuthAccount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Account name for authenticating to share notification MTA.
     *
     * @param zimbraShareNotificationMtaAuthAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1343)
    public Map<String,Object> setShareNotificationMtaAuthAccount(String zimbraShareNotificationMtaAuthAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthAccount, zimbraShareNotificationMtaAuthAccount);
        return attrs;
    }

    /**
     * Account name for authenticating to share notification MTA.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1343)
    public void unsetShareNotificationMtaAuthAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Account name for authenticating to share notification MTA.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1343)
    public Map<String,Object> unsetShareNotificationMtaAuthAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthAccount, "");
        return attrs;
    }

    /**
     * Password for authenticating to share notification MTA.
     *
     * @return zimbraShareNotificationMtaAuthPassword, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1344)
    public String getShareNotificationMtaAuthPassword() {
        return getAttr(Provisioning.A_zimbraShareNotificationMtaAuthPassword, null);
    }

    /**
     * Password for authenticating to share notification MTA.
     *
     * @param zimbraShareNotificationMtaAuthPassword new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1344)
    public void setShareNotificationMtaAuthPassword(String zimbraShareNotificationMtaAuthPassword) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthPassword, zimbraShareNotificationMtaAuthPassword);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Password for authenticating to share notification MTA.
     *
     * @param zimbraShareNotificationMtaAuthPassword new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1344)
    public Map<String,Object> setShareNotificationMtaAuthPassword(String zimbraShareNotificationMtaAuthPassword, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthPassword, zimbraShareNotificationMtaAuthPassword);
        return attrs;
    }

    /**
     * Password for authenticating to share notification MTA.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1344)
    public void unsetShareNotificationMtaAuthPassword() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthPassword, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Password for authenticating to share notification MTA.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1344)
    public Map<String,Object> unsetShareNotificationMtaAuthPassword(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthPassword, "");
        return attrs;
    }

    /**
     * Whether to use credential to authenticate to share notification MTA.
     *
     * @return zimbraShareNotificationMtaAuthRequired, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1346)
    public boolean isShareNotificationMtaAuthRequired() {
        return getBooleanAttr(Provisioning.A_zimbraShareNotificationMtaAuthRequired, false);
    }

    /**
     * Whether to use credential to authenticate to share notification MTA.
     *
     * @param zimbraShareNotificationMtaAuthRequired new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1346)
    public void setShareNotificationMtaAuthRequired(boolean zimbraShareNotificationMtaAuthRequired) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthRequired, zimbraShareNotificationMtaAuthRequired ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to use credential to authenticate to share notification MTA.
     *
     * @param zimbraShareNotificationMtaAuthRequired new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1346)
    public Map<String,Object> setShareNotificationMtaAuthRequired(boolean zimbraShareNotificationMtaAuthRequired, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthRequired, zimbraShareNotificationMtaAuthRequired ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether to use credential to authenticate to share notification MTA.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1346)
    public void unsetShareNotificationMtaAuthRequired() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthRequired, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to use credential to authenticate to share notification MTA.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1346)
    public Map<String,Object> unsetShareNotificationMtaAuthRequired(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthRequired, "");
        return attrs;
    }

    /**
     * Connection mode when connecting to share notification MTA.
     *
     * <p>Valid values: [CLEARTEXT, SSL, STARTTLS]
     *
     * @return zimbraShareNotificationMtaConnectionType, or null if unset and/or has invalid value
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1345)
    public ZAttrProvisioning.ShareNotificationMtaConnectionType getShareNotificationMtaConnectionType() {
        try { String v = getAttr(Provisioning.A_zimbraShareNotificationMtaConnectionType); return v == null ? null : ZAttrProvisioning.ShareNotificationMtaConnectionType.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Connection mode when connecting to share notification MTA.
     *
     * <p>Valid values: [CLEARTEXT, SSL, STARTTLS]
     *
     * @return zimbraShareNotificationMtaConnectionType, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1345)
    public String getShareNotificationMtaConnectionTypeAsString() {
        return getAttr(Provisioning.A_zimbraShareNotificationMtaConnectionType, null);
    }

    /**
     * Connection mode when connecting to share notification MTA.
     *
     * <p>Valid values: [CLEARTEXT, SSL, STARTTLS]
     *
     * @param zimbraShareNotificationMtaConnectionType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1345)
    public void setShareNotificationMtaConnectionType(ZAttrProvisioning.ShareNotificationMtaConnectionType zimbraShareNotificationMtaConnectionType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaConnectionType, zimbraShareNotificationMtaConnectionType.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Connection mode when connecting to share notification MTA.
     *
     * <p>Valid values: [CLEARTEXT, SSL, STARTTLS]
     *
     * @param zimbraShareNotificationMtaConnectionType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1345)
    public Map<String,Object> setShareNotificationMtaConnectionType(ZAttrProvisioning.ShareNotificationMtaConnectionType zimbraShareNotificationMtaConnectionType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaConnectionType, zimbraShareNotificationMtaConnectionType.toString());
        return attrs;
    }

    /**
     * Connection mode when connecting to share notification MTA.
     *
     * <p>Valid values: [CLEARTEXT, SSL, STARTTLS]
     *
     * @param zimbraShareNotificationMtaConnectionType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1345)
    public void setShareNotificationMtaConnectionTypeAsString(String zimbraShareNotificationMtaConnectionType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaConnectionType, zimbraShareNotificationMtaConnectionType);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Connection mode when connecting to share notification MTA.
     *
     * <p>Valid values: [CLEARTEXT, SSL, STARTTLS]
     *
     * @param zimbraShareNotificationMtaConnectionType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1345)
    public Map<String,Object> setShareNotificationMtaConnectionTypeAsString(String zimbraShareNotificationMtaConnectionType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaConnectionType, zimbraShareNotificationMtaConnectionType);
        return attrs;
    }

    /**
     * Connection mode when connecting to share notification MTA.
     *
     * <p>Valid values: [CLEARTEXT, SSL, STARTTLS]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1345)
    public void unsetShareNotificationMtaConnectionType() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaConnectionType, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Connection mode when connecting to share notification MTA.
     *
     * <p>Valid values: [CLEARTEXT, SSL, STARTTLS]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1345)
    public Map<String,Object> unsetShareNotificationMtaConnectionType(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaConnectionType, "");
        return attrs;
    }

    /**
     * Whether share notification MTA is enabled.
     *
     * @return zimbraShareNotificationMtaEnabled, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1361)
    public boolean isShareNotificationMtaEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraShareNotificationMtaEnabled, false);
    }

    /**
     * Whether share notification MTA is enabled.
     *
     * @param zimbraShareNotificationMtaEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1361)
    public void setShareNotificationMtaEnabled(boolean zimbraShareNotificationMtaEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaEnabled, zimbraShareNotificationMtaEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether share notification MTA is enabled.
     *
     * @param zimbraShareNotificationMtaEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1361)
    public Map<String,Object> setShareNotificationMtaEnabled(boolean zimbraShareNotificationMtaEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaEnabled, zimbraShareNotificationMtaEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether share notification MTA is enabled.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1361)
    public void unsetShareNotificationMtaEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether share notification MTA is enabled.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1361)
    public Map<String,Object> unsetShareNotificationMtaEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaEnabled, "");
        return attrs;
    }

    /**
     * SMTP hostname for share notification MTA used for sending email
     * notifications.
     *
     * @return zimbraShareNotificationMtaHostname, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1341)
    public String getShareNotificationMtaHostname() {
        return getAttr(Provisioning.A_zimbraShareNotificationMtaHostname, null);
    }

    /**
     * SMTP hostname for share notification MTA used for sending email
     * notifications.
     *
     * @param zimbraShareNotificationMtaHostname new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1341)
    public void setShareNotificationMtaHostname(String zimbraShareNotificationMtaHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaHostname, zimbraShareNotificationMtaHostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SMTP hostname for share notification MTA used for sending email
     * notifications.
     *
     * @param zimbraShareNotificationMtaHostname new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1341)
    public Map<String,Object> setShareNotificationMtaHostname(String zimbraShareNotificationMtaHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaHostname, zimbraShareNotificationMtaHostname);
        return attrs;
    }

    /**
     * SMTP hostname for share notification MTA used for sending email
     * notifications.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1341)
    public void unsetShareNotificationMtaHostname() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaHostname, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SMTP hostname for share notification MTA used for sending email
     * notifications.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1341)
    public Map<String,Object> unsetShareNotificationMtaHostname(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaHostname, "");
        return attrs;
    }

    /**
     * SMTP port for share notification MTA used for sending email
     * notifications.
     *
     * @return zimbraShareNotificationMtaPort, or -1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1342)
    public int getShareNotificationMtaPort() {
        return getIntAttr(Provisioning.A_zimbraShareNotificationMtaPort, -1);
    }

    /**
     * SMTP port for share notification MTA used for sending email
     * notifications.
     *
     * @param zimbraShareNotificationMtaPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1342)
    public void setShareNotificationMtaPort(int zimbraShareNotificationMtaPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaPort, Integer.toString(zimbraShareNotificationMtaPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SMTP port for share notification MTA used for sending email
     * notifications.
     *
     * @param zimbraShareNotificationMtaPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1342)
    public Map<String,Object> setShareNotificationMtaPort(int zimbraShareNotificationMtaPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaPort, Integer.toString(zimbraShareNotificationMtaPort));
        return attrs;
    }

    /**
     * SMTP port for share notification MTA used for sending email
     * notifications.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1342)
    public void unsetShareNotificationMtaPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SMTP port for share notification MTA used for sending email
     * notifications.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1342)
    public Map<String,Object> unsetShareNotificationMtaPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaPort, "");
        return attrs;
    }

    /**
     * Interval between successive executions of the task that publishes
     * shared item updates to LDAP. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getSharingUpdatePublishIntervalAsString to access value as a string.
     *
     * @see #getSharingUpdatePublishIntervalAsString()
     *
     * @return zimbraSharingUpdatePublishInterval in millseconds, or -1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1220)
    public long getSharingUpdatePublishInterval() {
        return getTimeInterval(Provisioning.A_zimbraSharingUpdatePublishInterval, -1L);
    }

    /**
     * Interval between successive executions of the task that publishes
     * shared item updates to LDAP. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraSharingUpdatePublishInterval, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1220)
    public String getSharingUpdatePublishIntervalAsString() {
        return getAttr(Provisioning.A_zimbraSharingUpdatePublishInterval, null);
    }

    /**
     * Interval between successive executions of the task that publishes
     * shared item updates to LDAP. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraSharingUpdatePublishInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1220)
    public void setSharingUpdatePublishInterval(String zimbraSharingUpdatePublishInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSharingUpdatePublishInterval, zimbraSharingUpdatePublishInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Interval between successive executions of the task that publishes
     * shared item updates to LDAP. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraSharingUpdatePublishInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1220)
    public Map<String,Object> setSharingUpdatePublishInterval(String zimbraSharingUpdatePublishInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSharingUpdatePublishInterval, zimbraSharingUpdatePublishInterval);
        return attrs;
    }

    /**
     * Interval between successive executions of the task that publishes
     * shared item updates to LDAP. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1220)
    public void unsetSharingUpdatePublishInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSharingUpdatePublishInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Interval between successive executions of the task that publishes
     * shared item updates to LDAP. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1220)
    public Map<String,Object> unsetSharingUpdatePublishInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSharingUpdatePublishInterval, "");
        return attrs;
    }

    /**
     * Maximum time an entry in the short term All Effective Rights cache
     * will be regarded as valid. If value is 0, the cache is disabled. The
     * cache is particularly useful when significant use is made of delegated
     * administration. This cache can improve performance by avoiding
     * recomputing All Effective Rights of named entries like accounts
     * frequently in a short period of time. All Effective Rights are
     * computations of the rights that named entries like accounts have -
     * although when used, they are checked separately. The longer the value
     * of this setting is, the more stale the view of the details is likely
     * to be. For this reason, the maximum accepted value is 30m. Larger
     * values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getShortTermAllEffectiveRightsCacheExpirationAsString to access value as a string.
     *
     * @see #getShortTermAllEffectiveRightsCacheExpirationAsString()
     *
     * @return zimbraShortTermAllEffectiveRightsCacheExpiration in millseconds, or -1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1903)
    public long getShortTermAllEffectiveRightsCacheExpiration() {
        return getTimeInterval(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheExpiration, -1L);
    }

    /**
     * Maximum time an entry in the short term All Effective Rights cache
     * will be regarded as valid. If value is 0, the cache is disabled. The
     * cache is particularly useful when significant use is made of delegated
     * administration. This cache can improve performance by avoiding
     * recomputing All Effective Rights of named entries like accounts
     * frequently in a short period of time. All Effective Rights are
     * computations of the rights that named entries like accounts have -
     * although when used, they are checked separately. The longer the value
     * of this setting is, the more stale the view of the details is likely
     * to be. For this reason, the maximum accepted value is 30m. Larger
     * values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraShortTermAllEffectiveRightsCacheExpiration, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1903)
    public String getShortTermAllEffectiveRightsCacheExpirationAsString() {
        return getAttr(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheExpiration, null);
    }

    /**
     * Maximum time an entry in the short term All Effective Rights cache
     * will be regarded as valid. If value is 0, the cache is disabled. The
     * cache is particularly useful when significant use is made of delegated
     * administration. This cache can improve performance by avoiding
     * recomputing All Effective Rights of named entries like accounts
     * frequently in a short period of time. All Effective Rights are
     * computations of the rights that named entries like accounts have -
     * although when used, they are checked separately. The longer the value
     * of this setting is, the more stale the view of the details is likely
     * to be. For this reason, the maximum accepted value is 30m. Larger
     * values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraShortTermAllEffectiveRightsCacheExpiration new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1903)
    public void setShortTermAllEffectiveRightsCacheExpiration(String zimbraShortTermAllEffectiveRightsCacheExpiration) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheExpiration, zimbraShortTermAllEffectiveRightsCacheExpiration);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum time an entry in the short term All Effective Rights cache
     * will be regarded as valid. If value is 0, the cache is disabled. The
     * cache is particularly useful when significant use is made of delegated
     * administration. This cache can improve performance by avoiding
     * recomputing All Effective Rights of named entries like accounts
     * frequently in a short period of time. All Effective Rights are
     * computations of the rights that named entries like accounts have -
     * although when used, they are checked separately. The longer the value
     * of this setting is, the more stale the view of the details is likely
     * to be. For this reason, the maximum accepted value is 30m. Larger
     * values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraShortTermAllEffectiveRightsCacheExpiration new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1903)
    public Map<String,Object> setShortTermAllEffectiveRightsCacheExpiration(String zimbraShortTermAllEffectiveRightsCacheExpiration, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheExpiration, zimbraShortTermAllEffectiveRightsCacheExpiration);
        return attrs;
    }

    /**
     * Maximum time an entry in the short term All Effective Rights cache
     * will be regarded as valid. If value is 0, the cache is disabled. The
     * cache is particularly useful when significant use is made of delegated
     * administration. This cache can improve performance by avoiding
     * recomputing All Effective Rights of named entries like accounts
     * frequently in a short period of time. All Effective Rights are
     * computations of the rights that named entries like accounts have -
     * although when used, they are checked separately. The longer the value
     * of this setting is, the more stale the view of the details is likely
     * to be. For this reason, the maximum accepted value is 30m. Larger
     * values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1903)
    public void unsetShortTermAllEffectiveRightsCacheExpiration() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheExpiration, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum time an entry in the short term All Effective Rights cache
     * will be regarded as valid. If value is 0, the cache is disabled. The
     * cache is particularly useful when significant use is made of delegated
     * administration. This cache can improve performance by avoiding
     * recomputing All Effective Rights of named entries like accounts
     * frequently in a short period of time. All Effective Rights are
     * computations of the rights that named entries like accounts have -
     * although when used, they are checked separately. The longer the value
     * of this setting is, the more stale the view of the details is likely
     * to be. For this reason, the maximum accepted value is 30m. Larger
     * values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1903)
    public Map<String,Object> unsetShortTermAllEffectiveRightsCacheExpiration(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheExpiration, "");
        return attrs;
    }

    /**
     * Maximum number of entries in the short term All Effective Rights
     * cache. This cache can improve performance by avoiding recomputing All
     * Effective Rights of named entries like accounts frequently in a short
     * period of time. Can disable the cache be specifying a value of 0
     *
     * @return zimbraShortTermAllEffectiveRightsCacheSize, or -1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1902)
    public int getShortTermAllEffectiveRightsCacheSize() {
        return getIntAttr(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheSize, -1);
    }

    /**
     * Maximum number of entries in the short term All Effective Rights
     * cache. This cache can improve performance by avoiding recomputing All
     * Effective Rights of named entries like accounts frequently in a short
     * period of time. Can disable the cache be specifying a value of 0
     *
     * @param zimbraShortTermAllEffectiveRightsCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1902)
    public void setShortTermAllEffectiveRightsCacheSize(int zimbraShortTermAllEffectiveRightsCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheSize, Integer.toString(zimbraShortTermAllEffectiveRightsCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the short term All Effective Rights
     * cache. This cache can improve performance by avoiding recomputing All
     * Effective Rights of named entries like accounts frequently in a short
     * period of time. Can disable the cache be specifying a value of 0
     *
     * @param zimbraShortTermAllEffectiveRightsCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1902)
    public Map<String,Object> setShortTermAllEffectiveRightsCacheSize(int zimbraShortTermAllEffectiveRightsCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheSize, Integer.toString(zimbraShortTermAllEffectiveRightsCacheSize));
        return attrs;
    }

    /**
     * Maximum number of entries in the short term All Effective Rights
     * cache. This cache can improve performance by avoiding recomputing All
     * Effective Rights of named entries like accounts frequently in a short
     * period of time. Can disable the cache be specifying a value of 0
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1902)
    public void unsetShortTermAllEffectiveRightsCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the short term All Effective Rights
     * cache. This cache can improve performance by avoiding recomputing All
     * Effective Rights of named entries like accounts frequently in a short
     * period of time. Can disable the cache be specifying a value of 0
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1902)
    public Map<String,Object> unsetShortTermAllEffectiveRightsCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheSize, "");
        return attrs;
    }

    /**
     * Maximum time an entry in the Grantee cache will be regarded as valid.
     * If value is 0, the cache is disabled. This cache can improve
     * performance by avoiding recomputing details frequently in a short
     * period of time, for instance for each entry in search results. The
     * cache is particularly useful when significant use is made of delegated
     * administration. Grantees objects provide a view of what rights a
     * grantee has - although those are checked separately. The longer the
     * value of this setting is, the more stale the view of the details is
     * likely to be. For this reason, the maximum accepted value is 30m.
     * Larger values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getShortTermGranteeCacheExpirationAsString to access value as a string.
     *
     * @see #getShortTermGranteeCacheExpirationAsString()
     *
     * @return zimbraShortTermGranteeCacheExpiration in millseconds, or -1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1901)
    public long getShortTermGranteeCacheExpiration() {
        return getTimeInterval(Provisioning.A_zimbraShortTermGranteeCacheExpiration, -1L);
    }

    /**
     * Maximum time an entry in the Grantee cache will be regarded as valid.
     * If value is 0, the cache is disabled. This cache can improve
     * performance by avoiding recomputing details frequently in a short
     * period of time, for instance for each entry in search results. The
     * cache is particularly useful when significant use is made of delegated
     * administration. Grantees objects provide a view of what rights a
     * grantee has - although those are checked separately. The longer the
     * value of this setting is, the more stale the view of the details is
     * likely to be. For this reason, the maximum accepted value is 30m.
     * Larger values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraShortTermGranteeCacheExpiration, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1901)
    public String getShortTermGranteeCacheExpirationAsString() {
        return getAttr(Provisioning.A_zimbraShortTermGranteeCacheExpiration, null);
    }

    /**
     * Maximum time an entry in the Grantee cache will be regarded as valid.
     * If value is 0, the cache is disabled. This cache can improve
     * performance by avoiding recomputing details frequently in a short
     * period of time, for instance for each entry in search results. The
     * cache is particularly useful when significant use is made of delegated
     * administration. Grantees objects provide a view of what rights a
     * grantee has - although those are checked separately. The longer the
     * value of this setting is, the more stale the view of the details is
     * likely to be. For this reason, the maximum accepted value is 30m.
     * Larger values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraShortTermGranteeCacheExpiration new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1901)
    public void setShortTermGranteeCacheExpiration(String zimbraShortTermGranteeCacheExpiration) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermGranteeCacheExpiration, zimbraShortTermGranteeCacheExpiration);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum time an entry in the Grantee cache will be regarded as valid.
     * If value is 0, the cache is disabled. This cache can improve
     * performance by avoiding recomputing details frequently in a short
     * period of time, for instance for each entry in search results. The
     * cache is particularly useful when significant use is made of delegated
     * administration. Grantees objects provide a view of what rights a
     * grantee has - although those are checked separately. The longer the
     * value of this setting is, the more stale the view of the details is
     * likely to be. For this reason, the maximum accepted value is 30m.
     * Larger values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraShortTermGranteeCacheExpiration new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1901)
    public Map<String,Object> setShortTermGranteeCacheExpiration(String zimbraShortTermGranteeCacheExpiration, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermGranteeCacheExpiration, zimbraShortTermGranteeCacheExpiration);
        return attrs;
    }

    /**
     * Maximum time an entry in the Grantee cache will be regarded as valid.
     * If value is 0, the cache is disabled. This cache can improve
     * performance by avoiding recomputing details frequently in a short
     * period of time, for instance for each entry in search results. The
     * cache is particularly useful when significant use is made of delegated
     * administration. Grantees objects provide a view of what rights a
     * grantee has - although those are checked separately. The longer the
     * value of this setting is, the more stale the view of the details is
     * likely to be. For this reason, the maximum accepted value is 30m.
     * Larger values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1901)
    public void unsetShortTermGranteeCacheExpiration() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermGranteeCacheExpiration, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum time an entry in the Grantee cache will be regarded as valid.
     * If value is 0, the cache is disabled. This cache can improve
     * performance by avoiding recomputing details frequently in a short
     * period of time, for instance for each entry in search results. The
     * cache is particularly useful when significant use is made of delegated
     * administration. Grantees objects provide a view of what rights a
     * grantee has - although those are checked separately. The longer the
     * value of this setting is, the more stale the view of the details is
     * likely to be. For this reason, the maximum accepted value is 30m.
     * Larger values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1901)
    public Map<String,Object> unsetShortTermGranteeCacheExpiration(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermGranteeCacheExpiration, "");
        return attrs;
    }

    /**
     * Maximum number of entries in the short term Grantee cache. This cache
     * can improve performance by avoiding recomputing details frequently in
     * a short period of time, for instance for each entry in search results.
     * Can disable the cache be specifying a value of 0
     *
     * @return zimbraShortTermGranteeCacheSize, or -1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1900)
    public int getShortTermGranteeCacheSize() {
        return getIntAttr(Provisioning.A_zimbraShortTermGranteeCacheSize, -1);
    }

    /**
     * Maximum number of entries in the short term Grantee cache. This cache
     * can improve performance by avoiding recomputing details frequently in
     * a short period of time, for instance for each entry in search results.
     * Can disable the cache be specifying a value of 0
     *
     * @param zimbraShortTermGranteeCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1900)
    public void setShortTermGranteeCacheSize(int zimbraShortTermGranteeCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermGranteeCacheSize, Integer.toString(zimbraShortTermGranteeCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the short term Grantee cache. This cache
     * can improve performance by avoiding recomputing details frequently in
     * a short period of time, for instance for each entry in search results.
     * Can disable the cache be specifying a value of 0
     *
     * @param zimbraShortTermGranteeCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1900)
    public Map<String,Object> setShortTermGranteeCacheSize(int zimbraShortTermGranteeCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermGranteeCacheSize, Integer.toString(zimbraShortTermGranteeCacheSize));
        return attrs;
    }

    /**
     * Maximum number of entries in the short term Grantee cache. This cache
     * can improve performance by avoiding recomputing details frequently in
     * a short period of time, for instance for each entry in search results.
     * Can disable the cache be specifying a value of 0
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1900)
    public void unsetShortTermGranteeCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermGranteeCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the short term Grantee cache. This cache
     * can improve performance by avoiding recomputing details frequently in
     * a short period of time, for instance for each entry in search results.
     * Can disable the cache be specifying a value of 0
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1900)
    public Map<String,Object> unsetShortTermGranteeCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermGranteeCacheSize, "");
        return attrs;
    }

    /**
     * Enable smtp debug
     *
     * @return zimbraSmtpEnableDebug, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1724)
    public boolean isSmtpEnableDebug() {
        return getBooleanAttr(Provisioning.A_zimbraSmtpEnableDebug, false);
    }

    /**
     * Enable smtp debug
     *
     * @param zimbraSmtpEnableDebug new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1724)
    public void setSmtpEnableDebug(boolean zimbraSmtpEnableDebug) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpEnableDebug, zimbraSmtpEnableDebug ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable smtp debug
     *
     * @param zimbraSmtpEnableDebug new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1724)
    public Map<String,Object> setSmtpEnableDebug(boolean zimbraSmtpEnableDebug, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpEnableDebug, zimbraSmtpEnableDebug ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Enable smtp debug
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1724)
    public void unsetSmtpEnableDebug() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpEnableDebug, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable smtp debug
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1724)
    public Map<String,Object> unsetSmtpEnableDebug(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpEnableDebug, "");
        return attrs;
    }

    /**
     * Enable STARTTLS for smtp
     *
     * @return zimbraSmtpEnableStartTls, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1743)
    public boolean isSmtpEnableStartTls() {
        return getBooleanAttr(Provisioning.A_zimbraSmtpEnableStartTls, false);
    }

    /**
     * Enable STARTTLS for smtp
     *
     * @param zimbraSmtpEnableStartTls new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1743)
    public void setSmtpEnableStartTls(boolean zimbraSmtpEnableStartTls) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpEnableStartTls, zimbraSmtpEnableStartTls ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable STARTTLS for smtp
     *
     * @param zimbraSmtpEnableStartTls new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1743)
    public Map<String,Object> setSmtpEnableStartTls(boolean zimbraSmtpEnableStartTls, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpEnableStartTls, zimbraSmtpEnableStartTls ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Enable STARTTLS for smtp
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1743)
    public void unsetSmtpEnableStartTls() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpEnableStartTls, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable STARTTLS for smtp
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1743)
    public Map<String,Object> unsetSmtpEnableStartTls(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpEnableStartTls, "");
        return attrs;
    }

    /**
     * the SMTP server to connect to when sending mail
     *
     * @return zimbraSmtpHostname, or empty array if unset
     */
    @ZAttr(id=97)
    public String[] getSmtpHostname() {
        return getMultiAttr(Provisioning.A_zimbraSmtpHostname);
    }

    /**
     * the SMTP server to connect to when sending mail
     *
     * @param zimbraSmtpHostname new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=97)
    public void setSmtpHostname(String[] zimbraSmtpHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpHostname, zimbraSmtpHostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the SMTP server to connect to when sending mail
     *
     * @param zimbraSmtpHostname new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=97)
    public Map<String,Object> setSmtpHostname(String[] zimbraSmtpHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpHostname, zimbraSmtpHostname);
        return attrs;
    }

    /**
     * the SMTP server to connect to when sending mail
     *
     * @param zimbraSmtpHostname new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=97)
    public void addSmtpHostname(String zimbraSmtpHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSmtpHostname, zimbraSmtpHostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the SMTP server to connect to when sending mail
     *
     * @param zimbraSmtpHostname new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=97)
    public Map<String,Object> addSmtpHostname(String zimbraSmtpHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSmtpHostname, zimbraSmtpHostname);
        return attrs;
    }

    /**
     * the SMTP server to connect to when sending mail
     *
     * @param zimbraSmtpHostname existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=97)
    public void removeSmtpHostname(String zimbraSmtpHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSmtpHostname, zimbraSmtpHostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the SMTP server to connect to when sending mail
     *
     * @param zimbraSmtpHostname existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=97)
    public Map<String,Object> removeSmtpHostname(String zimbraSmtpHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSmtpHostname, zimbraSmtpHostname);
        return attrs;
    }

    /**
     * the SMTP server to connect to when sending mail
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=97)
    public void unsetSmtpHostname() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpHostname, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the SMTP server to connect to when sending mail
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=97)
    public Map<String,Object> unsetSmtpHostname(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpHostname, "");
        return attrs;
    }

    /**
     * the SMTP server port to connect to when sending mail
     *
     * <p>Use getSmtpPortAsString to access value as a string.
     *
     * @see #getSmtpPortAsString()
     *
     * @return zimbraSmtpPort, or -1 if unset
     */
    @ZAttr(id=98)
    public int getSmtpPort() {
        return getIntAttr(Provisioning.A_zimbraSmtpPort, -1);
    }

    /**
     * the SMTP server port to connect to when sending mail
     *
     * @return zimbraSmtpPort, or null if unset
     */
    @ZAttr(id=98)
    public String getSmtpPortAsString() {
        return getAttr(Provisioning.A_zimbraSmtpPort, null);
    }

    /**
     * the SMTP server port to connect to when sending mail
     *
     * @param zimbraSmtpPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=98)
    public void setSmtpPort(int zimbraSmtpPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpPort, Integer.toString(zimbraSmtpPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the SMTP server port to connect to when sending mail
     *
     * @param zimbraSmtpPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=98)
    public Map<String,Object> setSmtpPort(int zimbraSmtpPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpPort, Integer.toString(zimbraSmtpPort));
        return attrs;
    }

    /**
     * the SMTP server port to connect to when sending mail
     *
     * @param zimbraSmtpPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=98)
    public void setSmtpPortAsString(String zimbraSmtpPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpPort, zimbraSmtpPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the SMTP server port to connect to when sending mail
     *
     * @param zimbraSmtpPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=98)
    public Map<String,Object> setSmtpPortAsString(String zimbraSmtpPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpPort, zimbraSmtpPort);
        return attrs;
    }

    /**
     * the SMTP server port to connect to when sending mail
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=98)
    public void unsetSmtpPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the SMTP server port to connect to when sending mail
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=98)
    public Map<String,Object> unsetSmtpPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpPort, "");
        return attrs;
    }

    /**
     * Value of the mail.smtp.sendpartial property
     *
     * @return zimbraSmtpSendPartial, or false if unset
     */
    @ZAttr(id=249)
    public boolean isSmtpSendPartial() {
        return getBooleanAttr(Provisioning.A_zimbraSmtpSendPartial, false);
    }

    /**
     * Value of the mail.smtp.sendpartial property
     *
     * @param zimbraSmtpSendPartial new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=249)
    public void setSmtpSendPartial(boolean zimbraSmtpSendPartial) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendPartial, zimbraSmtpSendPartial ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value of the mail.smtp.sendpartial property
     *
     * @param zimbraSmtpSendPartial new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=249)
    public Map<String,Object> setSmtpSendPartial(boolean zimbraSmtpSendPartial, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendPartial, zimbraSmtpSendPartial ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Value of the mail.smtp.sendpartial property
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=249)
    public void unsetSmtpSendPartial() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendPartial, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value of the mail.smtp.sendpartial property
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=249)
    public Map<String,Object> unsetSmtpSendPartial(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendPartial, "");
        return attrs;
    }

    /**
     * timeout value in seconds
     *
     * @return zimbraSmtpTimeout, or -1 if unset
     */
    @ZAttr(id=99)
    public int getSmtpTimeout() {
        return getIntAttr(Provisioning.A_zimbraSmtpTimeout, -1);
    }

    /**
     * timeout value in seconds
     *
     * @param zimbraSmtpTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=99)
    public void setSmtpTimeout(int zimbraSmtpTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpTimeout, Integer.toString(zimbraSmtpTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * timeout value in seconds
     *
     * @param zimbraSmtpTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=99)
    public Map<String,Object> setSmtpTimeout(int zimbraSmtpTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpTimeout, Integer.toString(zimbraSmtpTimeout));
        return attrs;
    }

    /**
     * timeout value in seconds
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=99)
    public void unsetSmtpTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * timeout value in seconds
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=99)
    public Map<String,Object> unsetSmtpTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpTimeout, "");
        return attrs;
    }

    /**
     * Flag to enable zimbra client for SMTP
     *
     * @return zimbraSmtpUseZimbraClient, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1735)
    public boolean isSmtpUseZimbraClient() {
        return getBooleanAttr(Provisioning.A_zimbraSmtpUseZimbraClient, false);
    }

    /**
     * Flag to enable zimbra client for SMTP
     *
     * @param zimbraSmtpUseZimbraClient new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1735)
    public void setSmtpUseZimbraClient(boolean zimbraSmtpUseZimbraClient) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpUseZimbraClient, zimbraSmtpUseZimbraClient ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable zimbra client for SMTP
     *
     * @param zimbraSmtpUseZimbraClient new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1735)
    public Map<String,Object> setSmtpUseZimbraClient(boolean zimbraSmtpUseZimbraClient, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpUseZimbraClient, zimbraSmtpUseZimbraClient ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Flag to enable zimbra client for SMTP
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1735)
    public void unsetSmtpUseZimbraClient() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpUseZimbraClient, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to enable zimbra client for SMTP
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1735)
    public Map<String,Object> unsetSmtpUseZimbraClient(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpUseZimbraClient, "");
        return attrs;
    }

    /**
     * If TRUE, enables support for GetVersionInfo for account SOAP requests.
     * If FALSE, GetVersionInfoRequest returns a SOAP fault.
     *
     * @return zimbraSoapExposeVersion, or false if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=708)
    public boolean isSoapExposeVersion() {
        return getBooleanAttr(Provisioning.A_zimbraSoapExposeVersion, false);
    }

    /**
     * If TRUE, enables support for GetVersionInfo for account SOAP requests.
     * If FALSE, GetVersionInfoRequest returns a SOAP fault.
     *
     * @param zimbraSoapExposeVersion new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=708)
    public void setSoapExposeVersion(boolean zimbraSoapExposeVersion) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapExposeVersion, zimbraSoapExposeVersion ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, enables support for GetVersionInfo for account SOAP requests.
     * If FALSE, GetVersionInfoRequest returns a SOAP fault.
     *
     * @param zimbraSoapExposeVersion new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=708)
    public Map<String,Object> setSoapExposeVersion(boolean zimbraSoapExposeVersion, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapExposeVersion, zimbraSoapExposeVersion ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * If TRUE, enables support for GetVersionInfo for account SOAP requests.
     * If FALSE, GetVersionInfoRequest returns a SOAP fault.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=708)
    public void unsetSoapExposeVersion() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapExposeVersion, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, enables support for GetVersionInfo for account SOAP requests.
     * If FALSE, GetVersionInfoRequest returns a SOAP fault.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=708)
    public Map<String,Object> unsetSoapExposeVersion(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapExposeVersion, "");
        return attrs;
    }

    /**
     * Maximum number of active soap sessions per account. Carefully increase
     * this.value to avoid &quot;Too many SOAP sessions” errors in
     * mailbox.log.
     *
     * @return zimbraSoapSessionLimit, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1738)
    public int getSoapSessionLimit() {
        return getIntAttr(Provisioning.A_zimbraSoapSessionLimit, -1);
    }

    /**
     * Maximum number of active soap sessions per account. Carefully increase
     * this.value to avoid &quot;Too many SOAP sessions” errors in
     * mailbox.log.
     *
     * @param zimbraSoapSessionLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1738)
    public void setSoapSessionLimit(int zimbraSoapSessionLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapSessionLimit, Integer.toString(zimbraSoapSessionLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of active soap sessions per account. Carefully increase
     * this.value to avoid &quot;Too many SOAP sessions” errors in
     * mailbox.log.
     *
     * @param zimbraSoapSessionLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1738)
    public Map<String,Object> setSoapSessionLimit(int zimbraSoapSessionLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapSessionLimit, Integer.toString(zimbraSoapSessionLimit));
        return attrs;
    }

    /**
     * Maximum number of active soap sessions per account. Carefully increase
     * this.value to avoid &quot;Too many SOAP sessions” errors in
     * mailbox.log.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1738)
    public void unsetSoapSessionLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapSessionLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of active soap sessions per account. Carefully increase
     * this.value to avoid &quot;Too many SOAP sessions” errors in
     * mailbox.log.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1738)
    public Map<String,Object> unsetSoapSessionLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapSessionLimit, "");
        return attrs;
    }

    /**
     * Idle timeout in seconds for SOAP sessions
     *
     * @return zimbraSoapSessionTimeout, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1741)
    public int getSoapSessionTimeout() {
        return getIntAttr(Provisioning.A_zimbraSoapSessionTimeout, -1);
    }

    /**
     * Idle timeout in seconds for SOAP sessions
     *
     * @param zimbraSoapSessionTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1741)
    public void setSoapSessionTimeout(int zimbraSoapSessionTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapSessionTimeout, Integer.toString(zimbraSoapSessionTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Idle timeout in seconds for SOAP sessions
     *
     * @param zimbraSoapSessionTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1741)
    public Map<String,Object> setSoapSessionTimeout(int zimbraSoapSessionTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapSessionTimeout, Integer.toString(zimbraSoapSessionTimeout));
        return attrs;
    }

    /**
     * Idle timeout in seconds for SOAP sessions
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1741)
    public void unsetSoapSessionTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapSessionTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Idle timeout in seconds for SOAP sessions
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1741)
    public Map<String,Object> unsetSoapSessionTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapSessionTimeout, "");
        return attrs;
    }

    /**
     * interface address on which Solr should listen; if empty, binds to all
     * localhost
     *
     * @return zimbraSolrBindAddress, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1666)
    public String getSolrBindAddress() {
        return getAttr(Provisioning.A_zimbraSolrBindAddress, null);
    }

    /**
     * interface address on which Solr should listen; if empty, binds to all
     * localhost
     *
     * @param zimbraSolrBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1666)
    public void setSolrBindAddress(String zimbraSolrBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrBindAddress, zimbraSolrBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which Solr should listen; if empty, binds to all
     * localhost
     *
     * @param zimbraSolrBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1666)
    public Map<String,Object> setSolrBindAddress(String zimbraSolrBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrBindAddress, zimbraSolrBindAddress);
        return attrs;
    }

    /**
     * interface address on which Solr should listen; if empty, binds to all
     * localhost
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1666)
    public void unsetSolrBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which Solr should listen; if empty, binds to all
     * localhost
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1666)
    public Map<String,Object> unsetSolrBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrBindAddress, "");
        return attrs;
    }

    /**
     * HTTP port for Solr service
     *
     * <p>Use getSolrBindPortAsString to access value as a string.
     *
     * @see #getSolrBindPortAsString()
     *
     * @return zimbraSolrBindPort, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1667)
    public int getSolrBindPort() {
        return getIntAttr(Provisioning.A_zimbraSolrBindPort, -1);
    }

    /**
     * HTTP port for Solr service
     *
     * @return zimbraSolrBindPort, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1667)
    public String getSolrBindPortAsString() {
        return getAttr(Provisioning.A_zimbraSolrBindPort, null);
    }

    /**
     * HTTP port for Solr service
     *
     * @param zimbraSolrBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1667)
    public void setSolrBindPort(int zimbraSolrBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrBindPort, Integer.toString(zimbraSolrBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTP port for Solr service
     *
     * @param zimbraSolrBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1667)
    public Map<String,Object> setSolrBindPort(int zimbraSolrBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrBindPort, Integer.toString(zimbraSolrBindPort));
        return attrs;
    }

    /**
     * HTTP port for Solr service
     *
     * @param zimbraSolrBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1667)
    public void setSolrBindPortAsString(String zimbraSolrBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrBindPort, zimbraSolrBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTP port for Solr service
     *
     * @param zimbraSolrBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1667)
    public Map<String,Object> setSolrBindPortAsString(String zimbraSolrBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrBindPort, zimbraSolrBindPort);
        return attrs;
    }

    /**
     * HTTP port for Solr service
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1667)
    public void unsetSolrBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTP port for Solr service
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1667)
    public Map<String,Object> unsetSolrBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrBindPort, "");
        return attrs;
    }

    /**
     * Maximum Idle time in milli seconds for a Solr jetty connector. This is
     * applied when waiting for a new request to be received on a connection;
     * when reading the headers and content of a request; when writing the
     * headers and content of a response.
     *
     * @return zimbraSolrConnectorMaxIdleTimeMillis, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1668)
    public int getSolrConnectorMaxIdleTimeMillis() {
        return getIntAttr(Provisioning.A_zimbraSolrConnectorMaxIdleTimeMillis, -1);
    }

    /**
     * Maximum Idle time in milli seconds for a Solr jetty connector. This is
     * applied when waiting for a new request to be received on a connection;
     * when reading the headers and content of a request; when writing the
     * headers and content of a response.
     *
     * @param zimbraSolrConnectorMaxIdleTimeMillis new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1668)
    public void setSolrConnectorMaxIdleTimeMillis(int zimbraSolrConnectorMaxIdleTimeMillis) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrConnectorMaxIdleTimeMillis, Integer.toString(zimbraSolrConnectorMaxIdleTimeMillis));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum Idle time in milli seconds for a Solr jetty connector. This is
     * applied when waiting for a new request to be received on a connection;
     * when reading the headers and content of a request; when writing the
     * headers and content of a response.
     *
     * @param zimbraSolrConnectorMaxIdleTimeMillis new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1668)
    public Map<String,Object> setSolrConnectorMaxIdleTimeMillis(int zimbraSolrConnectorMaxIdleTimeMillis, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrConnectorMaxIdleTimeMillis, Integer.toString(zimbraSolrConnectorMaxIdleTimeMillis));
        return attrs;
    }

    /**
     * Maximum Idle time in milli seconds for a Solr jetty connector. This is
     * applied when waiting for a new request to be received on a connection;
     * when reading the headers and content of a request; when writing the
     * headers and content of a response.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1668)
    public void unsetSolrConnectorMaxIdleTimeMillis() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrConnectorMaxIdleTimeMillis, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum Idle time in milli seconds for a Solr jetty connector. This is
     * applied when waiting for a new request to be received on a connection;
     * when reading the headers and content of a request; when writing the
     * headers and content of a response.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1668)
    public Map<String,Object> unsetSolrConnectorMaxIdleTimeMillis(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrConnectorMaxIdleTimeMillis, "");
        return attrs;
    }

    /**
     * Value for HttpSolrServer.setMaxRetries. 1 is the recommended setting
     *
     * @return zimbraSolrMaxRetries, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1905)
    public int getSolrMaxRetries() {
        return getIntAttr(Provisioning.A_zimbraSolrMaxRetries, -1);
    }

    /**
     * Value for HttpSolrServer.setMaxRetries. 1 is the recommended setting
     *
     * @param zimbraSolrMaxRetries new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1905)
    public void setSolrMaxRetries(int zimbraSolrMaxRetries) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrMaxRetries, Integer.toString(zimbraSolrMaxRetries));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for HttpSolrServer.setMaxRetries. 1 is the recommended setting
     *
     * @param zimbraSolrMaxRetries new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1905)
    public Map<String,Object> setSolrMaxRetries(int zimbraSolrMaxRetries, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrMaxRetries, Integer.toString(zimbraSolrMaxRetries));
        return attrs;
    }

    /**
     * Value for HttpSolrServer.setMaxRetries. 1 is the recommended setting
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1905)
    public void unsetSolrMaxRetries() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrMaxRetries, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for HttpSolrServer.setMaxRetries. 1 is the recommended setting
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1905)
    public Map<String,Object> unsetSolrMaxRetries(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrMaxRetries, "");
        return attrs;
    }

    /**
     * Limit for how many replicas of the same Solr Collection are allowed to
     * be created on each node. This value is used in maxShardsPerNode
     * parameter when creating Solr Collections in SolrCloud with via
     * Collections API.
     *
     * @return zimbraSolrMaxShardsPerNode, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1970)
    public int getSolrMaxShardsPerNode() {
        return getIntAttr(Provisioning.A_zimbraSolrMaxShardsPerNode, -1);
    }

    /**
     * Limit for how many replicas of the same Solr Collection are allowed to
     * be created on each node. This value is used in maxShardsPerNode
     * parameter when creating Solr Collections in SolrCloud with via
     * Collections API.
     *
     * @param zimbraSolrMaxShardsPerNode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1970)
    public void setSolrMaxShardsPerNode(int zimbraSolrMaxShardsPerNode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrMaxShardsPerNode, Integer.toString(zimbraSolrMaxShardsPerNode));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Limit for how many replicas of the same Solr Collection are allowed to
     * be created on each node. This value is used in maxShardsPerNode
     * parameter when creating Solr Collections in SolrCloud with via
     * Collections API.
     *
     * @param zimbraSolrMaxShardsPerNode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1970)
    public Map<String,Object> setSolrMaxShardsPerNode(int zimbraSolrMaxShardsPerNode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrMaxShardsPerNode, Integer.toString(zimbraSolrMaxShardsPerNode));
        return attrs;
    }

    /**
     * Limit for how many replicas of the same Solr Collection are allowed to
     * be created on each node. This value is used in maxShardsPerNode
     * parameter when creating Solr Collections in SolrCloud with via
     * Collections API.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1970)
    public void unsetSolrMaxShardsPerNode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrMaxShardsPerNode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Limit for how many replicas of the same Solr Collection are allowed to
     * be created on each node. This value is used in maxShardsPerNode
     * parameter when creating Solr Collections in SolrCloud with via
     * Collections API.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1970)
    public Map<String,Object> unsetSolrMaxShardsPerNode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrMaxShardsPerNode, "");
        return attrs;
    }

    /**
     * Number of instances of a Solr Collection that will be created for each
     * mailbox. This value is used in replicationFactor parameter when
     * creating Solr Collections in SolrCloud with via Collections API.
     *
     * @return zimbraSolrReplicationFactor, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1969)
    public int getSolrReplicationFactor() {
        return getIntAttr(Provisioning.A_zimbraSolrReplicationFactor, -1);
    }

    /**
     * Number of instances of a Solr Collection that will be created for each
     * mailbox. This value is used in replicationFactor parameter when
     * creating Solr Collections in SolrCloud with via Collections API.
     *
     * @param zimbraSolrReplicationFactor new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1969)
    public void setSolrReplicationFactor(int zimbraSolrReplicationFactor) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrReplicationFactor, Integer.toString(zimbraSolrReplicationFactor));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Number of instances of a Solr Collection that will be created for each
     * mailbox. This value is used in replicationFactor parameter when
     * creating Solr Collections in SolrCloud with via Collections API.
     *
     * @param zimbraSolrReplicationFactor new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1969)
    public Map<String,Object> setSolrReplicationFactor(int zimbraSolrReplicationFactor, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrReplicationFactor, Integer.toString(zimbraSolrReplicationFactor));
        return attrs;
    }

    /**
     * Number of instances of a Solr Collection that will be created for each
     * mailbox. This value is used in replicationFactor parameter when
     * creating Solr Collections in SolrCloud with via Collections API.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1969)
    public void unsetSolrReplicationFactor() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrReplicationFactor, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Number of instances of a Solr Collection that will be created for each
     * mailbox. This value is used in replicationFactor parameter when
     * creating Solr Collections in SolrCloud with via Collections API.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1969)
    public Map<String,Object> unsetSolrReplicationFactor(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSolrReplicationFactor, "");
        return attrs;
    }

    /**
     * The list of available dictionaries that can be used for spell
     * checking.
     *
     * @return zimbraSpellAvailableDictionary, or empty array if unset
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1042)
    public String[] getSpellAvailableDictionary() {
        return getMultiAttr(Provisioning.A_zimbraSpellAvailableDictionary);
    }

    /**
     * The list of available dictionaries that can be used for spell
     * checking.
     *
     * @param zimbraSpellAvailableDictionary new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1042)
    public void setSpellAvailableDictionary(String[] zimbraSpellAvailableDictionary) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpellAvailableDictionary, zimbraSpellAvailableDictionary);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The list of available dictionaries that can be used for spell
     * checking.
     *
     * @param zimbraSpellAvailableDictionary new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1042)
    public Map<String,Object> setSpellAvailableDictionary(String[] zimbraSpellAvailableDictionary, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpellAvailableDictionary, zimbraSpellAvailableDictionary);
        return attrs;
    }

    /**
     * The list of available dictionaries that can be used for spell
     * checking.
     *
     * @param zimbraSpellAvailableDictionary new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1042)
    public void addSpellAvailableDictionary(String zimbraSpellAvailableDictionary) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSpellAvailableDictionary, zimbraSpellAvailableDictionary);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The list of available dictionaries that can be used for spell
     * checking.
     *
     * @param zimbraSpellAvailableDictionary new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1042)
    public Map<String,Object> addSpellAvailableDictionary(String zimbraSpellAvailableDictionary, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSpellAvailableDictionary, zimbraSpellAvailableDictionary);
        return attrs;
    }

    /**
     * The list of available dictionaries that can be used for spell
     * checking.
     *
     * @param zimbraSpellAvailableDictionary existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1042)
    public void removeSpellAvailableDictionary(String zimbraSpellAvailableDictionary) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSpellAvailableDictionary, zimbraSpellAvailableDictionary);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The list of available dictionaries that can be used for spell
     * checking.
     *
     * @param zimbraSpellAvailableDictionary existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1042)
    public Map<String,Object> removeSpellAvailableDictionary(String zimbraSpellAvailableDictionary, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSpellAvailableDictionary, zimbraSpellAvailableDictionary);
        return attrs;
    }

    /**
     * The list of available dictionaries that can be used for spell
     * checking.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1042)
    public void unsetSpellAvailableDictionary() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpellAvailableDictionary, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The list of available dictionaries that can be used for spell
     * checking.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1042)
    public Map<String,Object> unsetSpellAvailableDictionary(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpellAvailableDictionary, "");
        return attrs;
    }

    /**
     * URL of the server running the spell checking service. Multi-valued
     * attribute that allows multiple spell check servers to be specified. If
     * the request to the first server fails, a request to the second server
     * is sent and so on.
     *
     * @return zimbraSpellCheckURL, or empty array if unset
     */
    @ZAttr(id=267)
    public String[] getSpellCheckURL() {
        return getMultiAttr(Provisioning.A_zimbraSpellCheckURL);
    }

    /**
     * URL of the server running the spell checking service. Multi-valued
     * attribute that allows multiple spell check servers to be specified. If
     * the request to the first server fails, a request to the second server
     * is sent and so on.
     *
     * @param zimbraSpellCheckURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=267)
    public void setSpellCheckURL(String[] zimbraSpellCheckURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpellCheckURL, zimbraSpellCheckURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL of the server running the spell checking service. Multi-valued
     * attribute that allows multiple spell check servers to be specified. If
     * the request to the first server fails, a request to the second server
     * is sent and so on.
     *
     * @param zimbraSpellCheckURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=267)
    public Map<String,Object> setSpellCheckURL(String[] zimbraSpellCheckURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpellCheckURL, zimbraSpellCheckURL);
        return attrs;
    }

    /**
     * URL of the server running the spell checking service. Multi-valued
     * attribute that allows multiple spell check servers to be specified. If
     * the request to the first server fails, a request to the second server
     * is sent and so on.
     *
     * @param zimbraSpellCheckURL new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=267)
    public void addSpellCheckURL(String zimbraSpellCheckURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSpellCheckURL, zimbraSpellCheckURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL of the server running the spell checking service. Multi-valued
     * attribute that allows multiple spell check servers to be specified. If
     * the request to the first server fails, a request to the second server
     * is sent and so on.
     *
     * @param zimbraSpellCheckURL new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=267)
    public Map<String,Object> addSpellCheckURL(String zimbraSpellCheckURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSpellCheckURL, zimbraSpellCheckURL);
        return attrs;
    }

    /**
     * URL of the server running the spell checking service. Multi-valued
     * attribute that allows multiple spell check servers to be specified. If
     * the request to the first server fails, a request to the second server
     * is sent and so on.
     *
     * @param zimbraSpellCheckURL existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=267)
    public void removeSpellCheckURL(String zimbraSpellCheckURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSpellCheckURL, zimbraSpellCheckURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL of the server running the spell checking service. Multi-valued
     * attribute that allows multiple spell check servers to be specified. If
     * the request to the first server fails, a request to the second server
     * is sent and so on.
     *
     * @param zimbraSpellCheckURL existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=267)
    public Map<String,Object> removeSpellCheckURL(String zimbraSpellCheckURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSpellCheckURL, zimbraSpellCheckURL);
        return attrs;
    }

    /**
     * URL of the server running the spell checking service. Multi-valued
     * attribute that allows multiple spell check servers to be specified. If
     * the request to the first server fails, a request to the second server
     * is sent and so on.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=267)
    public void unsetSpellCheckURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpellCheckURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL of the server running the spell checking service. Multi-valued
     * attribute that allows multiple spell check servers to be specified. If
     * the request to the first server fails, a request to the second server
     * is sent and so on.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=267)
    public Map<String,Object> unsetSpellCheckURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpellCheckURL, "");
        return attrs;
    }

    /**
     * spnego auth principal
     *
     * @return zimbraSpnegoAuthPrincipal, or null if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1122)
    public String getSpnegoAuthPrincipal() {
        return getAttr(Provisioning.A_zimbraSpnegoAuthPrincipal, null);
    }

    /**
     * spnego auth principal
     *
     * @param zimbraSpnegoAuthPrincipal new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1122)
    public void setSpnegoAuthPrincipal(String zimbraSpnegoAuthPrincipal) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthPrincipal, zimbraSpnegoAuthPrincipal);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * spnego auth principal
     *
     * @param zimbraSpnegoAuthPrincipal new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1122)
    public Map<String,Object> setSpnegoAuthPrincipal(String zimbraSpnegoAuthPrincipal, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthPrincipal, zimbraSpnegoAuthPrincipal);
        return attrs;
    }

    /**
     * spnego auth principal
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1122)
    public void unsetSpnegoAuthPrincipal() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthPrincipal, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * spnego auth principal
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1122)
    public Map<String,Object> unsetSpnegoAuthPrincipal(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthPrincipal, "");
        return attrs;
    }

    /**
     * spnego auth target name
     *
     * @return zimbraSpnegoAuthTargetName, or null if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1123)
    public String getSpnegoAuthTargetName() {
        return getAttr(Provisioning.A_zimbraSpnegoAuthTargetName, null);
    }

    /**
     * spnego auth target name
     *
     * @param zimbraSpnegoAuthTargetName new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1123)
    public void setSpnegoAuthTargetName(String zimbraSpnegoAuthTargetName) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthTargetName, zimbraSpnegoAuthTargetName);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * spnego auth target name
     *
     * @param zimbraSpnegoAuthTargetName new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1123)
    public Map<String,Object> setSpnegoAuthTargetName(String zimbraSpnegoAuthTargetName, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthTargetName, zimbraSpnegoAuthTargetName);
        return attrs;
    }

    /**
     * spnego auth target name
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1123)
    public void unsetSpnegoAuthTargetName() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthTargetName, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * spnego auth target name
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1123)
    public Map<String,Object> unsetSpnegoAuthTargetName(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthTargetName, "");
        return attrs;
    }

    /**
     * Prefixes of thread names. Each value is a column in threads.csv that
     * tracks the number of threads whose name starts with the given prefix.
     *
     * @return zimbraStatThreadNamePrefix, or empty array if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=792)
    public String[] getStatThreadNamePrefix() {
        return getMultiAttr(Provisioning.A_zimbraStatThreadNamePrefix);
    }

    /**
     * Prefixes of thread names. Each value is a column in threads.csv that
     * tracks the number of threads whose name starts with the given prefix.
     *
     * @param zimbraStatThreadNamePrefix new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=792)
    public void setStatThreadNamePrefix(String[] zimbraStatThreadNamePrefix) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStatThreadNamePrefix, zimbraStatThreadNamePrefix);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Prefixes of thread names. Each value is a column in threads.csv that
     * tracks the number of threads whose name starts with the given prefix.
     *
     * @param zimbraStatThreadNamePrefix new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=792)
    public Map<String,Object> setStatThreadNamePrefix(String[] zimbraStatThreadNamePrefix, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStatThreadNamePrefix, zimbraStatThreadNamePrefix);
        return attrs;
    }

    /**
     * Prefixes of thread names. Each value is a column in threads.csv that
     * tracks the number of threads whose name starts with the given prefix.
     *
     * @param zimbraStatThreadNamePrefix new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=792)
    public void addStatThreadNamePrefix(String zimbraStatThreadNamePrefix) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraStatThreadNamePrefix, zimbraStatThreadNamePrefix);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Prefixes of thread names. Each value is a column in threads.csv that
     * tracks the number of threads whose name starts with the given prefix.
     *
     * @param zimbraStatThreadNamePrefix new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=792)
    public Map<String,Object> addStatThreadNamePrefix(String zimbraStatThreadNamePrefix, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraStatThreadNamePrefix, zimbraStatThreadNamePrefix);
        return attrs;
    }

    /**
     * Prefixes of thread names. Each value is a column in threads.csv that
     * tracks the number of threads whose name starts with the given prefix.
     *
     * @param zimbraStatThreadNamePrefix existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=792)
    public void removeStatThreadNamePrefix(String zimbraStatThreadNamePrefix) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraStatThreadNamePrefix, zimbraStatThreadNamePrefix);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Prefixes of thread names. Each value is a column in threads.csv that
     * tracks the number of threads whose name starts with the given prefix.
     *
     * @param zimbraStatThreadNamePrefix existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=792)
    public Map<String,Object> removeStatThreadNamePrefix(String zimbraStatThreadNamePrefix, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraStatThreadNamePrefix, zimbraStatThreadNamePrefix);
        return attrs;
    }

    /**
     * Prefixes of thread names. Each value is a column in threads.csv that
     * tracks the number of threads whose name starts with the given prefix.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=792)
    public void unsetStatThreadNamePrefix() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStatThreadNamePrefix, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Prefixes of thread names. Each value is a column in threads.csv that
     * tracks the number of threads whose name starts with the given prefix.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=792)
    public Map<String,Object> unsetStatThreadNamePrefix(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStatThreadNamePrefix, "");
        return attrs;
    }

    /**
     * Maximum number of files to keep in ExternalStoreManager&#039;s local
     * file cache
     *
     * @return zimbraStoreExternalLocalCacheMaxFiles, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1753)
    public int getStoreExternalLocalCacheMaxFiles() {
        return getIntAttr(Provisioning.A_zimbraStoreExternalLocalCacheMaxFiles, -1);
    }

    /**
     * Maximum number of files to keep in ExternalStoreManager&#039;s local
     * file cache
     *
     * @param zimbraStoreExternalLocalCacheMaxFiles new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1753)
    public void setStoreExternalLocalCacheMaxFiles(int zimbraStoreExternalLocalCacheMaxFiles) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStoreExternalLocalCacheMaxFiles, Integer.toString(zimbraStoreExternalLocalCacheMaxFiles));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of files to keep in ExternalStoreManager&#039;s local
     * file cache
     *
     * @param zimbraStoreExternalLocalCacheMaxFiles new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1753)
    public Map<String,Object> setStoreExternalLocalCacheMaxFiles(int zimbraStoreExternalLocalCacheMaxFiles, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStoreExternalLocalCacheMaxFiles, Integer.toString(zimbraStoreExternalLocalCacheMaxFiles));
        return attrs;
    }

    /**
     * Maximum number of files to keep in ExternalStoreManager&#039;s local
     * file cache
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1753)
    public void unsetStoreExternalLocalCacheMaxFiles() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStoreExternalLocalCacheMaxFiles, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of files to keep in ExternalStoreManager&#039;s local
     * file cache
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1753)
    public Map<String,Object> unsetStoreExternalLocalCacheMaxFiles(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStoreExternalLocalCacheMaxFiles, "");
        return attrs;
    }

    /**
     * Maximum number of bytes to keep in ExternalStoreManager&#039;s local
     * file cache. Default value is 1GB
     *
     * @return zimbraStoreExternalLocalCacheMaxSize, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1752)
    public int getStoreExternalLocalCacheMaxSize() {
        return getIntAttr(Provisioning.A_zimbraStoreExternalLocalCacheMaxSize, -1);
    }

    /**
     * Maximum number of bytes to keep in ExternalStoreManager&#039;s local
     * file cache. Default value is 1GB
     *
     * @param zimbraStoreExternalLocalCacheMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1752)
    public void setStoreExternalLocalCacheMaxSize(int zimbraStoreExternalLocalCacheMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStoreExternalLocalCacheMaxSize, Integer.toString(zimbraStoreExternalLocalCacheMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of bytes to keep in ExternalStoreManager&#039;s local
     * file cache. Default value is 1GB
     *
     * @param zimbraStoreExternalLocalCacheMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1752)
    public Map<String,Object> setStoreExternalLocalCacheMaxSize(int zimbraStoreExternalLocalCacheMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStoreExternalLocalCacheMaxSize, Integer.toString(zimbraStoreExternalLocalCacheMaxSize));
        return attrs;
    }

    /**
     * Maximum number of bytes to keep in ExternalStoreManager&#039;s local
     * file cache. Default value is 1GB
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1752)
    public void unsetStoreExternalLocalCacheMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStoreExternalLocalCacheMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of bytes to keep in ExternalStoreManager&#039;s local
     * file cache. Default value is 1GB
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1752)
    public Map<String,Object> unsetStoreExternalLocalCacheMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStoreExternalLocalCacheMaxSize, "");
        return attrs;
    }

    /**
     * Minimum time in millis to keep idle entries in
     * ExternalStoreManager&#039;s local file cache
     *
     * @return zimbraStoreExternalLocalCacheMinLifetime, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1754)
    public int getStoreExternalLocalCacheMinLifetime() {
        return getIntAttr(Provisioning.A_zimbraStoreExternalLocalCacheMinLifetime, -1);
    }

    /**
     * Minimum time in millis to keep idle entries in
     * ExternalStoreManager&#039;s local file cache
     *
     * @param zimbraStoreExternalLocalCacheMinLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1754)
    public void setStoreExternalLocalCacheMinLifetime(int zimbraStoreExternalLocalCacheMinLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStoreExternalLocalCacheMinLifetime, Integer.toString(zimbraStoreExternalLocalCacheMinLifetime));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum time in millis to keep idle entries in
     * ExternalStoreManager&#039;s local file cache
     *
     * @param zimbraStoreExternalLocalCacheMinLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1754)
    public Map<String,Object> setStoreExternalLocalCacheMinLifetime(int zimbraStoreExternalLocalCacheMinLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStoreExternalLocalCacheMinLifetime, Integer.toString(zimbraStoreExternalLocalCacheMinLifetime));
        return attrs;
    }

    /**
     * Minimum time in millis to keep idle entries in
     * ExternalStoreManager&#039;s local file cache
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1754)
    public void unsetStoreExternalLocalCacheMinLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStoreExternalLocalCacheMinLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum time in millis to keep idle entries in
     * ExternalStoreManager&#039;s local file cache
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1754)
    public Map<String,Object> unsetStoreExternalLocalCacheMinLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStoreExternalLocalCacheMinLifetime, "");
        return attrs;
    }

    /**
     * Maximum number of consecutive IOExceptions before aborting during
     * mailbox deletion
     *
     * @return zimbraStoreExternalMaxIOExceptionsForDelete, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1751)
    public int getStoreExternalMaxIOExceptionsForDelete() {
        return getIntAttr(Provisioning.A_zimbraStoreExternalMaxIOExceptionsForDelete, -1);
    }

    /**
     * Maximum number of consecutive IOExceptions before aborting during
     * mailbox deletion
     *
     * @param zimbraStoreExternalMaxIOExceptionsForDelete new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1751)
    public void setStoreExternalMaxIOExceptionsForDelete(int zimbraStoreExternalMaxIOExceptionsForDelete) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStoreExternalMaxIOExceptionsForDelete, Integer.toString(zimbraStoreExternalMaxIOExceptionsForDelete));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of consecutive IOExceptions before aborting during
     * mailbox deletion
     *
     * @param zimbraStoreExternalMaxIOExceptionsForDelete new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1751)
    public Map<String,Object> setStoreExternalMaxIOExceptionsForDelete(int zimbraStoreExternalMaxIOExceptionsForDelete, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStoreExternalMaxIOExceptionsForDelete, Integer.toString(zimbraStoreExternalMaxIOExceptionsForDelete));
        return attrs;
    }

    /**
     * Maximum number of consecutive IOExceptions before aborting during
     * mailbox deletion
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1751)
    public void unsetStoreExternalMaxIOExceptionsForDelete() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStoreExternalMaxIOExceptionsForDelete, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of consecutive IOExceptions before aborting during
     * mailbox deletion
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1751)
    public Map<String,Object> unsetStoreExternalMaxIOExceptionsForDelete(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStoreExternalMaxIOExceptionsForDelete, "");
        return attrs;
    }

    /**
     * Maximum number of per session sync listeners for ActiveSync. Carefully
     * increase this value to avoid &quot;Too many SYNCLISTENER
     * sessions&quot; errors in sync.log.
     *
     * @return zimbraSyncSessionLimit, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1739)
    public int getSyncSessionLimit() {
        return getIntAttr(Provisioning.A_zimbraSyncSessionLimit, -1);
    }

    /**
     * Maximum number of per session sync listeners for ActiveSync. Carefully
     * increase this value to avoid &quot;Too many SYNCLISTENER
     * sessions&quot; errors in sync.log.
     *
     * @param zimbraSyncSessionLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1739)
    public void setSyncSessionLimit(int zimbraSyncSessionLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSyncSessionLimit, Integer.toString(zimbraSyncSessionLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of per session sync listeners for ActiveSync. Carefully
     * increase this value to avoid &quot;Too many SYNCLISTENER
     * sessions&quot; errors in sync.log.
     *
     * @param zimbraSyncSessionLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1739)
    public Map<String,Object> setSyncSessionLimit(int zimbraSyncSessionLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSyncSessionLimit, Integer.toString(zimbraSyncSessionLimit));
        return attrs;
    }

    /**
     * Maximum number of per session sync listeners for ActiveSync. Carefully
     * increase this value to avoid &quot;Too many SYNCLISTENER
     * sessions&quot; errors in sync.log.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1739)
    public void unsetSyncSessionLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSyncSessionLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of per session sync listeners for ActiveSync. Carefully
     * increase this value to avoid &quot;Too many SYNCLISTENER
     * sessions&quot; errors in sync.log.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1739)
    public Map<String,Object> unsetSyncSessionLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSyncSessionLimit, "");
        return attrs;
    }

    /**
     * Whether or not Jetty thread monitor is enabled. Used for debugging
     * Jetty, not recommended for extended use in production environment.
     * Defaults to FALSE
     *
     * @return zimbraThreadMonitorEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1583)
    public boolean isThreadMonitorEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraThreadMonitorEnabled, false);
    }

    /**
     * Whether or not Jetty thread monitor is enabled. Used for debugging
     * Jetty, not recommended for extended use in production environment.
     * Defaults to FALSE
     *
     * @param zimbraThreadMonitorEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1583)
    public void setThreadMonitorEnabled(boolean zimbraThreadMonitorEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThreadMonitorEnabled, zimbraThreadMonitorEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not Jetty thread monitor is enabled. Used for debugging
     * Jetty, not recommended for extended use in production environment.
     * Defaults to FALSE
     *
     * @param zimbraThreadMonitorEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1583)
    public Map<String,Object> setThreadMonitorEnabled(boolean zimbraThreadMonitorEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThreadMonitorEnabled, zimbraThreadMonitorEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether or not Jetty thread monitor is enabled. Used for debugging
     * Jetty, not recommended for extended use in production environment.
     * Defaults to FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1583)
    public void unsetThreadMonitorEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThreadMonitorEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not Jetty thread monitor is enabled. Used for debugging
     * Jetty, not recommended for extended use in production environment.
     * Defaults to FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1583)
    public Map<String,Object> unsetThreadMonitorEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThreadMonitorEnabled, "");
        return attrs;
    }

    /**
     * Hosts to ignore during IP based throttling. Account and command rate
     * limits will still be applied. Typically should list nginx hostname and
     * any other mailbox servers which can proxy to this server
     *
     * @return zimbraThrottleSafeHosts, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1383)
    public String[] getThrottleSafeHosts() {
        return getMultiAttr(Provisioning.A_zimbraThrottleSafeHosts);
    }

    /**
     * Hosts to ignore during IP based throttling. Account and command rate
     * limits will still be applied. Typically should list nginx hostname and
     * any other mailbox servers which can proxy to this server
     *
     * @param zimbraThrottleSafeHosts new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1383)
    public void setThrottleSafeHosts(String[] zimbraThrottleSafeHosts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThrottleSafeHosts, zimbraThrottleSafeHosts);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hosts to ignore during IP based throttling. Account and command rate
     * limits will still be applied. Typically should list nginx hostname and
     * any other mailbox servers which can proxy to this server
     *
     * @param zimbraThrottleSafeHosts new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1383)
    public Map<String,Object> setThrottleSafeHosts(String[] zimbraThrottleSafeHosts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThrottleSafeHosts, zimbraThrottleSafeHosts);
        return attrs;
    }

    /**
     * Hosts to ignore during IP based throttling. Account and command rate
     * limits will still be applied. Typically should list nginx hostname and
     * any other mailbox servers which can proxy to this server
     *
     * @param zimbraThrottleSafeHosts new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1383)
    public void addThrottleSafeHosts(String zimbraThrottleSafeHosts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraThrottleSafeHosts, zimbraThrottleSafeHosts);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hosts to ignore during IP based throttling. Account and command rate
     * limits will still be applied. Typically should list nginx hostname and
     * any other mailbox servers which can proxy to this server
     *
     * @param zimbraThrottleSafeHosts new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1383)
    public Map<String,Object> addThrottleSafeHosts(String zimbraThrottleSafeHosts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraThrottleSafeHosts, zimbraThrottleSafeHosts);
        return attrs;
    }

    /**
     * Hosts to ignore during IP based throttling. Account and command rate
     * limits will still be applied. Typically should list nginx hostname and
     * any other mailbox servers which can proxy to this server
     *
     * @param zimbraThrottleSafeHosts existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1383)
    public void removeThrottleSafeHosts(String zimbraThrottleSafeHosts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraThrottleSafeHosts, zimbraThrottleSafeHosts);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hosts to ignore during IP based throttling. Account and command rate
     * limits will still be applied. Typically should list nginx hostname and
     * any other mailbox servers which can proxy to this server
     *
     * @param zimbraThrottleSafeHosts existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1383)
    public Map<String,Object> removeThrottleSafeHosts(String zimbraThrottleSafeHosts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraThrottleSafeHosts, zimbraThrottleSafeHosts);
        return attrs;
    }

    /**
     * Hosts to ignore during IP based throttling. Account and command rate
     * limits will still be applied. Typically should list nginx hostname and
     * any other mailbox servers which can proxy to this server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1383)
    public void unsetThrottleSafeHosts() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThrottleSafeHosts, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hosts to ignore during IP based throttling. Account and command rate
     * limits will still be applied. Typically should list nginx hostname and
     * any other mailbox servers which can proxy to this server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1383)
    public Map<String,Object> unsetThrottleSafeHosts(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThrottleSafeHosts, "");
        return attrs;
    }

    /**
     * Hosts to whitelist during IP based throttling. Account and command
     * rate limits will not be applied. This should only be used for internal
     * servers which cannot service end user traffic; e.g. migration or
     * monitoring hosts
     *
     * @return zimbraThrottleWhitelist, or empty array if unset
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1449)
    public String[] getThrottleWhitelist() {
        return getMultiAttr(Provisioning.A_zimbraThrottleWhitelist);
    }

    /**
     * Hosts to whitelist during IP based throttling. Account and command
     * rate limits will not be applied. This should only be used for internal
     * servers which cannot service end user traffic; e.g. migration or
     * monitoring hosts
     *
     * @param zimbraThrottleWhitelist new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1449)
    public void setThrottleWhitelist(String[] zimbraThrottleWhitelist) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThrottleWhitelist, zimbraThrottleWhitelist);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hosts to whitelist during IP based throttling. Account and command
     * rate limits will not be applied. This should only be used for internal
     * servers which cannot service end user traffic; e.g. migration or
     * monitoring hosts
     *
     * @param zimbraThrottleWhitelist new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1449)
    public Map<String,Object> setThrottleWhitelist(String[] zimbraThrottleWhitelist, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThrottleWhitelist, zimbraThrottleWhitelist);
        return attrs;
    }

    /**
     * Hosts to whitelist during IP based throttling. Account and command
     * rate limits will not be applied. This should only be used for internal
     * servers which cannot service end user traffic; e.g. migration or
     * monitoring hosts
     *
     * @param zimbraThrottleWhitelist new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1449)
    public void addThrottleWhitelist(String zimbraThrottleWhitelist) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraThrottleWhitelist, zimbraThrottleWhitelist);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hosts to whitelist during IP based throttling. Account and command
     * rate limits will not be applied. This should only be used for internal
     * servers which cannot service end user traffic; e.g. migration or
     * monitoring hosts
     *
     * @param zimbraThrottleWhitelist new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1449)
    public Map<String,Object> addThrottleWhitelist(String zimbraThrottleWhitelist, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraThrottleWhitelist, zimbraThrottleWhitelist);
        return attrs;
    }

    /**
     * Hosts to whitelist during IP based throttling. Account and command
     * rate limits will not be applied. This should only be used for internal
     * servers which cannot service end user traffic; e.g. migration or
     * monitoring hosts
     *
     * @param zimbraThrottleWhitelist existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1449)
    public void removeThrottleWhitelist(String zimbraThrottleWhitelist) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraThrottleWhitelist, zimbraThrottleWhitelist);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hosts to whitelist during IP based throttling. Account and command
     * rate limits will not be applied. This should only be used for internal
     * servers which cannot service end user traffic; e.g. migration or
     * monitoring hosts
     *
     * @param zimbraThrottleWhitelist existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1449)
    public Map<String,Object> removeThrottleWhitelist(String zimbraThrottleWhitelist, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraThrottleWhitelist, zimbraThrottleWhitelist);
        return attrs;
    }

    /**
     * Hosts to whitelist during IP based throttling. Account and command
     * rate limits will not be applied. This should only be used for internal
     * servers which cannot service end user traffic; e.g. migration or
     * monitoring hosts
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1449)
    public void unsetThrottleWhitelist() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThrottleWhitelist, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hosts to whitelist during IP based throttling. Account and command
     * rate limits will not be applied. This should only be used for internal
     * servers which cannot service end user traffic; e.g. migration or
     * monitoring hosts
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1449)
    public Map<String,Object> unsetThrottleWhitelist(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThrottleWhitelist, "");
        return attrs;
    }

    /**
     * how often the virus definitions are updated. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getVirusDefinitionsUpdateFrequencyAsString to access value as a string.
     *
     * @see #getVirusDefinitionsUpdateFrequencyAsString()
     *
     * @return zimbraVirusDefinitionsUpdateFrequency in millseconds, or -1 if unset
     */
    @ZAttr(id=191)
    public long getVirusDefinitionsUpdateFrequency() {
        return getTimeInterval(Provisioning.A_zimbraVirusDefinitionsUpdateFrequency, -1L);
    }

    /**
     * how often the virus definitions are updated. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraVirusDefinitionsUpdateFrequency, or null if unset
     */
    @ZAttr(id=191)
    public String getVirusDefinitionsUpdateFrequencyAsString() {
        return getAttr(Provisioning.A_zimbraVirusDefinitionsUpdateFrequency, null);
    }

    /**
     * how often the virus definitions are updated. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraVirusDefinitionsUpdateFrequency new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=191)
    public void setVirusDefinitionsUpdateFrequency(String zimbraVirusDefinitionsUpdateFrequency) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusDefinitionsUpdateFrequency, zimbraVirusDefinitionsUpdateFrequency);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how often the virus definitions are updated. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraVirusDefinitionsUpdateFrequency new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=191)
    public Map<String,Object> setVirusDefinitionsUpdateFrequency(String zimbraVirusDefinitionsUpdateFrequency, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusDefinitionsUpdateFrequency, zimbraVirusDefinitionsUpdateFrequency);
        return attrs;
    }

    /**
     * how often the virus definitions are updated. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=191)
    public void unsetVirusDefinitionsUpdateFrequency() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusDefinitionsUpdateFrequency, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how often the virus definitions are updated. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=191)
    public Map<String,Object> unsetVirusDefinitionsUpdateFrequency(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusDefinitionsUpdateFrequency, "");
        return attrs;
    }

    /**
     * Deprecated since: 9.0.0_BETA1. Obsoleted by use of Consul as a service
     * locator.. Orig desc: Web client URL to directly connect when making
     * service to JS calls from mail server in split mode.
     *
     * @return zimbraWebClientURL, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1445)
    public String getWebClientURL() {
        return getAttr(Provisioning.A_zimbraWebClientURL, null);
    }

    /**
     * Deprecated since: 9.0.0_BETA1. Obsoleted by use of Consul as a service
     * locator.. Orig desc: Web client URL to directly connect when making
     * service to JS calls from mail server in split mode.
     *
     * @param zimbraWebClientURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1445)
    public void setWebClientURL(String zimbraWebClientURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientURL, zimbraWebClientURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 9.0.0_BETA1. Obsoleted by use of Consul as a service
     * locator.. Orig desc: Web client URL to directly connect when making
     * service to JS calls from mail server in split mode.
     *
     * @param zimbraWebClientURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1445)
    public Map<String,Object> setWebClientURL(String zimbraWebClientURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientURL, zimbraWebClientURL);
        return attrs;
    }

    /**
     * Deprecated since: 9.0.0_BETA1. Obsoleted by use of Consul as a service
     * locator.. Orig desc: Web client URL to directly connect when making
     * service to JS calls from mail server in split mode.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1445)
    public void unsetWebClientURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 9.0.0_BETA1. Obsoleted by use of Consul as a service
     * locator.. Orig desc: Web client URL to directly connect when making
     * service to JS calls from mail server in split mode.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1445)
    public Map<String,Object> unsetWebClientURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientURL, "");
        return attrs;
    }

    /**
     * Whether or not to gzip static web content. Defaults to true.
     *
     * @return zimbraWebGzipEnabled, or false if unset
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1468)
    public boolean isWebGzipEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraWebGzipEnabled, false);
    }

    /**
     * Whether or not to gzip static web content. Defaults to true.
     *
     * @param zimbraWebGzipEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1468)
    public void setWebGzipEnabled(boolean zimbraWebGzipEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebGzipEnabled, zimbraWebGzipEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to gzip static web content. Defaults to true.
     *
     * @param zimbraWebGzipEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1468)
    public Map<String,Object> setWebGzipEnabled(boolean zimbraWebGzipEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebGzipEnabled, zimbraWebGzipEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether or not to gzip static web content. Defaults to true.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1468)
    public void unsetWebGzipEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebGzipEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to gzip static web content. Defaults to true.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1468)
    public Map<String,Object> unsetWebGzipEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebGzipEnabled, "");
        return attrs;
    }

    /**
     * Enable XMPP support for IM
     *
     * @return zimbraXMPPEnabled, or false if unset
     */
    @ZAttr(id=397)
    public boolean isXMPPEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraXMPPEnabled, false);
    }

    /**
     * Enable XMPP support for IM
     *
     * @param zimbraXMPPEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=397)
    public void setXMPPEnabled(boolean zimbraXMPPEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraXMPPEnabled, zimbraXMPPEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable XMPP support for IM
     *
     * @param zimbraXMPPEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=397)
    public Map<String,Object> setXMPPEnabled(boolean zimbraXMPPEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraXMPPEnabled, zimbraXMPPEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Enable XMPP support for IM
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=397)
    public void unsetXMPPEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraXMPPEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable XMPP support for IM
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=397)
    public Map<String,Object> unsetXMPPEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraXMPPEnabled, "");
        return attrs;
    }

    /**
     * Timeout for ZooKeeper requests
     *
     * @return zimbraZKClientTimeout, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2040)
    public int getZKClientTimeout() {
        return getIntAttr(Provisioning.A_zimbraZKClientTimeout, -1);
    }

    /**
     * Timeout for ZooKeeper requests
     *
     * @param zimbraZKClientTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2040)
    public void setZKClientTimeout(int zimbraZKClientTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZKClientTimeout, Integer.toString(zimbraZKClientTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout for ZooKeeper requests
     *
     * @param zimbraZKClientTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2040)
    public Map<String,Object> setZKClientTimeout(int zimbraZKClientTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZKClientTimeout, Integer.toString(zimbraZKClientTimeout));
        return attrs;
    }

    /**
     * Timeout for ZooKeeper requests
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2040)
    public void unsetZKClientTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZKClientTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout for ZooKeeper requests
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2040)
    public Map<String,Object> unsetZKClientTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZKClientTimeout, "");
        return attrs;
    }

    /**
     * Timeout for establishing ZooKeeper connection
     *
     * @return zimbraZKConnectTimeout, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2041)
    public int getZKConnectTimeout() {
        return getIntAttr(Provisioning.A_zimbraZKConnectTimeout, -1);
    }

    /**
     * Timeout for establishing ZooKeeper connection
     *
     * @param zimbraZKConnectTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2041)
    public void setZKConnectTimeout(int zimbraZKConnectTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZKConnectTimeout, Integer.toString(zimbraZKConnectTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout for establishing ZooKeeper connection
     *
     * @param zimbraZKConnectTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2041)
    public Map<String,Object> setZKConnectTimeout(int zimbraZKConnectTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZKConnectTimeout, Integer.toString(zimbraZKConnectTimeout));
        return attrs;
    }

    /**
     * Timeout for establishing ZooKeeper connection
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2041)
    public void unsetZKConnectTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZKConnectTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout for establishing ZooKeeper connection
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=2041)
    public Map<String,Object> unsetZKConnectTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZKConnectTimeout, "");
        return attrs;
    }

    /**
     * Timeout for zimlet deployment specified in seconds.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getZimletDeployTimeoutAsString to access value as a string.
     *
     * @see #getZimletDeployTimeoutAsString()
     *
     * @return zimbraZimletDeployTimeout in millseconds, or -1 if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1858)
    public long getZimletDeployTimeout() {
        return getTimeInterval(Provisioning.A_zimbraZimletDeployTimeout, -1L);
    }

    /**
     * Timeout for zimlet deployment specified in seconds.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraZimletDeployTimeout, or null if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1858)
    public String getZimletDeployTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraZimletDeployTimeout, null);
    }

    /**
     * Timeout for zimlet deployment specified in seconds.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraZimletDeployTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1858)
    public void setZimletDeployTimeout(String zimbraZimletDeployTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletDeployTimeout, zimbraZimletDeployTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout for zimlet deployment specified in seconds.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraZimletDeployTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1858)
    public Map<String,Object> setZimletDeployTimeout(String zimbraZimletDeployTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletDeployTimeout, zimbraZimletDeployTimeout);
        return attrs;
    }

    /**
     * Timeout for zimlet deployment specified in seconds.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1858)
    public void unsetZimletDeployTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletDeployTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout for zimlet deployment specified in seconds.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=1858)
    public Map<String,Object> unsetZimletDeployTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletDeployTimeout, "");
        return attrs;
    }

    /**
     * Whether to enable JSP compilation for Zimlets (i.e. for /zimlet
     * webapp)
     *
     * @return zimbraZimletJspEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1575)
    public boolean isZimletJspEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraZimletJspEnabled, false);
    }

    /**
     * Whether to enable JSP compilation for Zimlets (i.e. for /zimlet
     * webapp)
     *
     * @param zimbraZimletJspEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1575)
    public void setZimletJspEnabled(boolean zimbraZimletJspEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletJspEnabled, zimbraZimletJspEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable JSP compilation for Zimlets (i.e. for /zimlet
     * webapp)
     *
     * @param zimbraZimletJspEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1575)
    public Map<String,Object> setZimletJspEnabled(boolean zimbraZimletJspEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletJspEnabled, zimbraZimletJspEnabled ? Provisioning.TRUE : Provisioning.FALSE);
        return attrs;
    }

    /**
     * Whether to enable JSP compilation for Zimlets (i.e. for /zimlet
     * webapp)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1575)
    public void unsetZimletJspEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletJspEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable JSP compilation for Zimlets (i.e. for /zimlet
     * webapp)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1575)
    public Map<String,Object> unsetZimletJspEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletJspEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 9.0.0_BETA1. Multi-server AlwaysOn clusters no
     * longer require ZooKeeper.. Orig desc: list of host:port for ZooKeeper
     * servers; set to empty value to disable the use of ZooKeeper.
     *
     * @return zimbraZookeeperClientServerList, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1447)
    public String[] getZookeeperClientServerList() {
        return getMultiAttr(Provisioning.A_zimbraZookeeperClientServerList);
    }

    /**
     * Deprecated since: 9.0.0_BETA1. Multi-server AlwaysOn clusters no
     * longer require ZooKeeper.. Orig desc: list of host:port for ZooKeeper
     * servers; set to empty value to disable the use of ZooKeeper.
     *
     * @param zimbraZookeeperClientServerList new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1447)
    public void setZookeeperClientServerList(String[] zimbraZookeeperClientServerList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZookeeperClientServerList, zimbraZookeeperClientServerList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 9.0.0_BETA1. Multi-server AlwaysOn clusters no
     * longer require ZooKeeper.. Orig desc: list of host:port for ZooKeeper
     * servers; set to empty value to disable the use of ZooKeeper.
     *
     * @param zimbraZookeeperClientServerList new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1447)
    public Map<String,Object> setZookeeperClientServerList(String[] zimbraZookeeperClientServerList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZookeeperClientServerList, zimbraZookeeperClientServerList);
        return attrs;
    }

    /**
     * Deprecated since: 9.0.0_BETA1. Multi-server AlwaysOn clusters no
     * longer require ZooKeeper.. Orig desc: list of host:port for ZooKeeper
     * servers; set to empty value to disable the use of ZooKeeper.
     *
     * @param zimbraZookeeperClientServerList new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1447)
    public void addZookeeperClientServerList(String zimbraZookeeperClientServerList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraZookeeperClientServerList, zimbraZookeeperClientServerList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 9.0.0_BETA1. Multi-server AlwaysOn clusters no
     * longer require ZooKeeper.. Orig desc: list of host:port for ZooKeeper
     * servers; set to empty value to disable the use of ZooKeeper.
     *
     * @param zimbraZookeeperClientServerList new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1447)
    public Map<String,Object> addZookeeperClientServerList(String zimbraZookeeperClientServerList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraZookeeperClientServerList, zimbraZookeeperClientServerList);
        return attrs;
    }

    /**
     * Deprecated since: 9.0.0_BETA1. Multi-server AlwaysOn clusters no
     * longer require ZooKeeper.. Orig desc: list of host:port for ZooKeeper
     * servers; set to empty value to disable the use of ZooKeeper.
     *
     * @param zimbraZookeeperClientServerList existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1447)
    public void removeZookeeperClientServerList(String zimbraZookeeperClientServerList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraZookeeperClientServerList, zimbraZookeeperClientServerList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 9.0.0_BETA1. Multi-server AlwaysOn clusters no
     * longer require ZooKeeper.. Orig desc: list of host:port for ZooKeeper
     * servers; set to empty value to disable the use of ZooKeeper.
     *
     * @param zimbraZookeeperClientServerList existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1447)
    public Map<String,Object> removeZookeeperClientServerList(String zimbraZookeeperClientServerList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraZookeeperClientServerList, zimbraZookeeperClientServerList);
        return attrs;
    }

    /**
     * Deprecated since: 9.0.0_BETA1. Multi-server AlwaysOn clusters no
     * longer require ZooKeeper.. Orig desc: list of host:port for ZooKeeper
     * servers; set to empty value to disable the use of ZooKeeper.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1447)
    public void unsetZookeeperClientServerList() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZookeeperClientServerList, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 9.0.0_BETA1. Multi-server AlwaysOn clusters no
     * longer require ZooKeeper.. Orig desc: list of host:port for ZooKeeper
     * servers; set to empty value to disable the use of ZooKeeper.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1447)
    public Map<String,Object> unsetZookeeperClientServerList(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZookeeperClientServerList, "");
        return attrs;
    }

    ///// END-AUTO-GEN-REPLACE
}
